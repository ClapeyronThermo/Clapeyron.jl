var documenterSearchIndex = {"docs":
[{"location":"api/#Contents","page":"API","title":"Contents","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#Volume-Temperature-Based-Properties","page":"API","title":"Volume-Temperature Based Properties","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Clapeyron.second_virial_coefficient\nClapeyron.pip","category":"page"},{"location":"api/#Clapeyron.second_virial_coefficient","page":"API","title":"Clapeyron.second_virial_coefficient","text":"second_virial_coefficient(model::EoSModel, T, z=SA[1.])\n\nCalculates the second virial coefficient B, defined as:\n\nB = lim(V->∞)[ V^2/RT *  (∂Aᵣ∂V + V*∂²Aᵣ∂V²) ]\n\nwhere Aᵣ is the residual helmholtz energy\n\n\n\n\n\n","category":"function"},{"location":"api/#Clapeyron.pip","page":"API","title":"Clapeyron.pip","text":"pip(model::EoSModel,V,T,z=[1.0])\n\nPhase identification parameter Π. as described in 1. If Π > 1, then the phase is clasified as a liquid or a liquid-like vapor, being a vapor or vapor-like liquid otherwise.\n\nThis identification parameter fails at temperatures and pressures well aboVe the critical point.\n\nCalculated as:\n\nΠ = V*((∂²p/∂V∂T)/(∂p/∂T) - (∂²p/∂V²)/(∂p/∂V))\n\nG. Venkatarathnama, L.R. Oellrich, Identification of the phase of a fluid using partial derivatives of pressure, volume,and temperature without reference to saturation properties: Applications in phase equilibria calculations, Fluid Phase Equilibria 301 (2011) 225–233\n\n\n\n\n\n","category":"function"},{"location":"api/#Pressure-Temperature-Based-Properties","page":"API","title":"Pressure-Temperature Based Properties","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"volume\nClapeyron.compressibility_factor","category":"page"},{"location":"api/#Clapeyron.volume","page":"API","title":"Clapeyron.volume","text":"volume(model::EoSModel,p,T,z=SA[1.0];phase=:unknown,threaded=true)\n\ncalculates the volume (m³) of the compound modelled by model at a certain pressure,temperature and moles.\n\nphase is a Symbol that determines the initial volume root to look for:\n\nIf phase =:liquid it will return the volume of the phase using a liquid initial point.\nIf phase =:vapor it will return the volume of the phase using a gas initial point.\n\nThe default is phase =:unknown. with this, both liquid and volume roots will be calculated, and  the phase with the least amount of energy is returned.\n\nThe calculation of both volume roots can be calculated in serial (threaded=false) or in parallel (threaded=true)\n\n\n\n\n\n","category":"function"},{"location":"api/#Clapeyron.compressibility_factor","page":"API","title":"Clapeyron.compressibility_factor","text":"compressibility_factor(model::EoSModel, p, T, z=SA[1.]; phase = :unknown,threaded=true)\n\nCalculates the compressibility factor Z, defined as:\n\nZ = p*V(p)/R*T\n\nthe keywords phase and threaded are passed to the volume solver.\n\n\n\n\n\n","category":"function"},{"location":"api/#Single-component-properties","page":"API","title":"Single component properties","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Clapeyron.sat_pure\nClapeyron.enthalpy_vap\nClapeyron.crit_pure\nClapeyron.acentric_factor","category":"page"},{"location":"api/#Clapeyron.sat_pure","page":"API","title":"Clapeyron.sat_pure","text":"sat_pure(model::EoSModel, T, V0 = x0_sat_pure(model,T))\n\nPerforms a single component saturation equilibrium calculation, at the specified temperature T, of one mol of pure sustance specified by model\n\nReturns (p₀, Vₗ, Vᵥ) where p₀ is the saturation pressure (in Pa), Vₗ is the liquid saturation volume (in m³) and Vᵥ is the vapour saturation volume (in m³).\n\nIf the calculation fails, returns  (NaN, NaN, NaN)\n\nV0 is [log10(Vₗ₀),log10(Vᵥ₀)] , where Vₗ₀  and Vᵥ₀ are initial guesses for the liquid and vapour volumes.\n\n\n\n\n\n","category":"function"},{"location":"api/#Clapeyron.enthalpy_vap","page":"API","title":"Clapeyron.enthalpy_vap","text":"enthalpy_vap(model::EoSModel, T)\n\nCalculates ΔH, the difference between saturated vapour and liquid enthalpies at temperature T, in J   \n\n\n\n\n\n","category":"function"},{"location":"api/#Clapeyron.crit_pure","page":"API","title":"Clapeyron.crit_pure","text":"crit_pure(model::EoSModel,x0=nothing)\n\nCalculates the critical point of a single component modelled by model. \n\nReturns (Tc, pc, Vc) where Tc is the critical temperature (in K), pc is the critical pressure (in Pa) and Vc is the critical volume (in  m³)\n\n\n\n\n\n","category":"function"},{"location":"api/#Clapeyron.acentric_factor","page":"API","title":"Clapeyron.acentric_factor","text":"acentric_factor(model::EoSModel)\n\ncalculates the acentric factor using its definition:\n\nω = -log10(psatᵣ) -1, at Tᵣ = 0.7\n\nTo do so, it calculates the critical temperature (using crit_pure) and performs a saturation calculation (with sat_pure)\n\n\n\n\n\n","category":"function"},{"location":"api/#Automatic-Differenciation-functions","page":"API","title":"Automatic Differenciation functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Clapeyron.∂f∂T\nClapeyron.∂f∂V\nClapeyron.∂f\nClapeyron.p∂p∂V\nClapeyron.∂2f\nClapeyron.∂2p\nClapeyron.f_hess\nClapeyron.∂²³f","category":"page"},{"location":"api/#Clapeyron.∂f∂T","page":"API","title":"Clapeyron.∂f∂T","text":"∂f∂T(model,V,T,z=SA[1.0])\n\nreturns f and ∂f/∂T at constant total volume and composition, where f is the total helmholtz energy, given by eos(model,V,T,z)\n\n\n\n\n\n","category":"function"},{"location":"api/#Clapeyron.∂f∂V","page":"API","title":"Clapeyron.∂f∂V","text":"∂f∂V(model,V,T,z=SA[1.0])\n\nreturns f and ∂f/∂V at constant temperature and composition, where f is the total helmholtz energy, given by eos(model,V,T,z), and V is the total volume\n\n\n\n\n\n","category":"function"},{"location":"api/#Clapeyron.∂f","page":"API","title":"Clapeyron.∂f","text":"∂f(model,V,T,z)\n\nreturns zeroth order (value) and first order derivative information of the total helmholtz energy (given by eos(model,V,T,z)). the result is given in two values:\n\ngrad_f,fval = ∂2f(model,V,T,z)\n\nwhere:\n\nfval   = f(V,T) = eos(model,V,T,z)\n\ngrad_f = [ ∂f/∂V; ∂f/∂T]\n\n\nWhere V is the total volume, T is the temperature and f is the total helmholtz energy.\n\n\n\n\n\n","category":"function"},{"location":"api/#Clapeyron.p∂p∂V","page":"API","title":"Clapeyron.p∂p∂V","text":"p∂p∂V(model,V,T,z=SA[1.0])\n\nreturns p and ∂p/∂V at constant temperature, where p is the pressure = pressure(model,V,T,z) and V is the total Volume.\n\n\n\n\n\n","category":"function"},{"location":"api/#Clapeyron.∂2f","page":"API","title":"Clapeyron.∂2f","text":"∂2f(model,V,T,z)\n\nreturns zeroth order (value), first order and second order derivative information of the total helmholtz energy (given by eos(model,V,T,z)). the result is given in three values:\n\nhess_f,grad_f,fval = ∂2f(model,V,T,z)\n\nwhere: ``` fval   = f(V,T) = eos(model,V,T,z)\n\ngrad_f = [ ∂f/∂V; ∂f/∂T]\n\nhess_f = [ ∂²f/∂V²; ∂²f/∂V∂T           ∂²f/∂V∂T; ∂²f/∂V²]  ```\n\nWhere V is the total volume, T is the temperature and f is the total helmholtz energy.\n\n\n\n\n\n","category":"function"},{"location":"api/#Clapeyron.∂2p","page":"API","title":"Clapeyron.∂2p","text":"∂2p(model,V,T,z)\n\nreturns zeroth order (value), first order and second order derivative information of the pressure. the result is given in three values:\n\nhess_p,grad_p,pval = ∂2p(model,V,T,z)\n\nwhere: ``` pval   = p(V,T) = pressure(model,V,T,z)\n\ngrad_p = [ ∂p/∂V; ∂p/∂T]\n\nhess_p = [ ∂²p/∂V²; ∂²p/∂V∂T           ∂²p/∂V∂T; ∂²p/∂V²]  ```\n\nWhere V is the total volume, T is the temperature and p is the pressure.\n\n\n\n\n\n","category":"function"},{"location":"api/#Clapeyron.f_hess","page":"API","title":"Clapeyron.f_hess","text":"f_hess(model,V,T,z)\n\nreturns the second order volume (V) and temperature (T) derivatives of the total helmholtz energy (given by eos(model,V,T,z)). the result is given in a 2x2 SMatrix, in the form:\n\n[ ∂²f/∂V²  ∂²f/∂V∂T  ∂²f/∂V∂T  ∂²f/∂V²]\n\nuse this instead of the ∂2f if you only need second order information. ∂2f also gives zeroth and first order derivative information, but due to a bug in the used AD, it allocates more than necessary.\n\n\n\n\n\n","category":"function"},{"location":"api/#Clapeyron.∂²³f","page":"API","title":"Clapeyron.∂²³f","text":"∂²³f(model,V,T,z=SA[1.0])\n\nreturns ∂²A/∂V² and ∂³A/∂V³, in a single ForwardDiff pass. used mainly in crit_pure objective function\n\n\n\n\n\n","category":"function"},{"location":"api/#Initial-guess-functions","page":"API","title":"Initial guess functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Clapeyron.lb_volume\nClapeyron.T_scale\nClapeyron.p_scale\nClapeyron.x0_volume\nClapeyron.x0_volume_liquid\nClapeyron.x0_volume_gas\nClapeyron.x0_volume\nClapeyron.volume_virial\nClapeyron.x0_sat_pure\nClapeyron.x0_crit_pure","category":"page"},{"location":"api/#Clapeyron.lb_volume","page":"API","title":"Clapeyron.lb_volume","text":"lb_volume(model::EoSModel,z=SA[1.0])\n\nReturns the lower bound volume. \n\nIt has different meanings depending on the Equation of State, but symbolizes the minimum allowable volume at a certain composition:\n\nSAFT EoS: the packing volume\nCubic EoS, covolume (b) parameter\n\nOn empiric equations of state, the value is chosen to match the volume of the conditions at maximum pressure and minimum temperature , but the equation itself normally can be evaluated at lower volumes.\n\nOn SAFT and Cubic EoS, volumes lower than lb_volume will likely error.\n\nThe lower bound volume is used for guesses of liquid volumes at a certain pressure, saturated liquid volumes and critical volumes.\n\n\n\n\n\n","category":"function"},{"location":"api/#Clapeyron.T_scale","page":"API","title":"Clapeyron.T_scale","text":"T_scale(model::EoS,z=SA[1.0])\n\nRepresents a temperature scaling factor. \n\nOn any EoS based on Critical parameters (Cubic or Empiric EoS), the temperature scaling factor is chosen to be the critical temperature.\n\nOn SAFT or other molecular EoS, the temperature scaling factor is chosen to be a function of the potential depth ϵ.\n\nUsed as scaling factors in sat_pure and as input for solving crit_pure\n\n\n\n\n\n","category":"function"},{"location":"api/#Clapeyron.p_scale","page":"API","title":"Clapeyron.p_scale","text":"p_scale(model::SAFTModel,z=SA[1.0])\n\nRepresents a pressure scaling factor\n\nOn any EoS based on Critical parameters (Cubic or   Empiric EoS), the pressure scaling factor is     chosen to be a function of the critical pressure.\n\nOn SAFT or other molecular EoS, the temperature     scaling factor is chosen to a function of ∑(zᵢϵᵢ(σᵢᵢ)³)    \n\nUsed as scaling factors in sat_pure and as input for solving crit_pure\n\n\n\n\n\n","category":"function"},{"location":"api/#Clapeyron.x0_volume","page":"API","title":"Clapeyron.x0_volume","text":"x0_volume(model::EoSModel,p,T,z; phase = :unknown)\n\nReturns an initial guess of the volume at a pressure, temperature, composition and suggested phase.\n\nIf the suggested phase is :unkwown or :liquid, calls x0_volume_liquid.\n\nIf the suggested phase is :gas, calls x0_volume_gas.\n\n\n\n\n\n","category":"function"},{"location":"api/#Clapeyron.x0_volume_liquid","page":"API","title":"Clapeyron.x0_volume_liquid","text":"x0_volume_liquid(model,T,z)\n\nReturns an initial guess to the liquid volume, dependent on temperature and composition. by default is 1.25 times the lower bound volume.\n\n\n\n\n\n","category":"function"},{"location":"api/#Clapeyron.x0_volume_gas","page":"API","title":"Clapeyron.x0_volume_gas","text":"x0_volume_gas(model,p,T,z)\n\nReturns an initial guess to the gas volume, depending of pressure, temperature and composition. by default uses a virial aproximation\n\n\n\n\n\n","category":"function"},{"location":"api/#Clapeyron.volume_virial","page":"API","title":"Clapeyron.volume_virial","text":"volume_virial(model,p,T,z=SA[1.0])\n\nCalculates an aproximation to the gas volume at specified pressure, volume and composition, by aproximating:\n\n\nZ(v) ≈ 1 + B(T)/v \n\nwhere Z is the compressibility factor and B is the second virial coefficient. if B>0, (over the inversion temperature) returns NaN. If the solution to the problem is complex (Z = 1 + B/v implies solving a quadratic polynomial), returns -2*B.\n\n\n\n\n\n","category":"function"},{"location":"api/#Clapeyron.x0_sat_pure","page":"API","title":"Clapeyron.x0_sat_pure","text":"x0_sat_pure(model::EoSModel,T,z=SA[1.0])\n\nReturns a 2-element vector corresponding to [log10(Vₗ),log10(Vᵥ)], where Vₗ and Vᵥ are the liquid and vapor initial guesses.  Used in sat_pure.\n\n\n\n\n\n","category":"function"},{"location":"api/#Clapeyron.x0_crit_pure","page":"API","title":"Clapeyron.x0_crit_pure","text":"x0_crit_pure(model::SAFTModel,z=SA[1.0])\n\nReturns a 2-element vector corresponding to     [k,log10(Vc0)], where k is Tc0/T_scale(model,z)\n\n\n\n\n\n","category":"function"},{"location":"theory/background/#Models","page":"Background","title":"Models","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"Here, we give a high-level description of equations of state and the models provided by Clapeyron.","category":"page"},{"location":"theory/background/#Equations-of-state","page":"Background","title":"Equations of state","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"Equations of state provide a functional form to obtain a thermodynamic property, F, at given conditions boldsymbolOmega:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"F = f(boldsymbolOmegaboldsymbolXi)","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"where f is the equation of state. There are many ways one can develop an equation of state, however, the Gibbs Phase Rule states the following:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"mathrmDoF = N_mathrmspecies - N_mathrmphase + 2","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"As we can see, the largest number of degrees of freedom we can have is N_mathrmspecies+1; as this rule is for intensive properties (i.e. irrespective of system size), we can an additional degree of freedom, giving N_mathrmspecies+2. Taking the simple case of a single species, we can specify at most 3 conditions in our system. Given that most equations of state are derived using what is known as the canonical ensemble (more information can be found in Statistical Mechanics textbooks), the three variable chosen are usually temperature, T, volume, V and number of particles, mathbfN. The output of these equations is usually the Helmholtz free energy, A. It is also typical for an equation of state to require parameters, boldsymbolXi, to model certain species. What these parameters are depend on the equation of state.","category":"page"},{"location":"theory/background/#Ideal-model","page":"Background","title":"Ideal model","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"One equation of state that most engineers and scientists should be very familiar with is the ideal gas equation, commonly expressed as:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"pV = Nk_mathrmBT","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"where p is the pressure, N is the total number of particles and k_mathrmB is the Boltzmann constant. It is possible to derive this equation by assuming that species can be modelled as infinitesimally  small particles. This is surprisingly appropriate for a variety of species in the gas phase at high temperature and low pressure.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"However, if we wish to determine other thermodynamic properties, we would need to integrate the above equation with respect to volume to determine the Helmholtz free energy:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"A_mathrmideal =- int pmathrmdV =- Nk_mathrmBTlnV+c(TmathbfN)","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"We can see that, in just using the original equation, we've lost a temperature and composition dependence in the Helmholtz free energy. If we follow the derivation from statistical or quantum mechanics, we can obtain the following equation (we denote this as the MonomerIdeal model in Clapeyron):","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"fracA_mathrmidealNk_mathrmBT = left(sum_ix_iln(rho_iLambda_i^3)right)-1","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"where x_i, rho_i, and Lambda_i are the molar composition, number density and thermal de Broglie wavelength of species i, respectively. For the purposes of vapour-liquid equilibrium and most thermodynamic properties, this ideal model is sufficient (one can even ignore Lambda_i in the case of the former; we use this as the default BasicIdeal model). In addition, some would argue that this is the only ideal model as it only considers the translational motion of infinitesimally small particles.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"However, polyatomic species typically have vibrational and rotational modes of motion as well which are typically included as part of the ideal term. These can also be derived from statistical mechanics giving:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"fracA_mathrmidealNk_mathrmBT=sum_ix_ibigglnleft(rho_iLambda_i^3right)-fracN_mathrmroti2 ln fracTtheta_mathrmroti+sum^N_mathrmvibi_mathrmvg_imathrmvleftfractheta_mathrmvibimathrmv2T+lnleft(1-exp-(theta_mathrmvibimathrmvT)right)right-1bigg","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"where N_mathrmroti, theta_mathrmroti and N_mathrmvibi are the number of rotations, vibrations and rotational temperature of a species i, respectively. g_imathrmv and theta_mathrmvibimathrmv are the degeneracy and vibrational temperature of a vibrational mode mathrmv on species i, respectively. The WalkerIdeal model provides the necessary parameters to use such an equation. However, the more-commonly used approach is through the use of ideal isobaric heat-capacity, C_pi^0, correlations, such as the ReidIdeal, WilhoitIdeal and AlyLeeIdeal models. With the ideal isobaric heat-capacity, it is possible to determine the ideal Helmholtz free energy using the following equation:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"fracA_mathrmidealNk_mathrmBT = sum_i=1^N_mathrmComponent x_ileftlnfracrho_irho_0     + frac1Nk_mathrmBT int_T_0^T C_pi^0 dT + fracH_0iNk_mathrmBT- frac1Nk_Bint_T_0^T fracC_pi^0T dT -lnfracTT_0-fracS_0iNk_mathrmB - 1right","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Note that the reference states, rho_0, H_0i and S_0i, can typically be neglected as these will not impact or contribute to most thermodynamic properties of interest.","category":"page"},{"location":"theory/background/#Cubic-models","page":"Background","title":"Cubic models","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"Some of the more-popular equations of state have been the engineering cubic equations. The first of these is the van der Waals (vdW) equation of state, written as:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"p = fracNk_mathrmBTV-Nb-fracN^2aV^2","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"where a and b (both in SI units) are the model parameters which can be related to the critical temperature and pressure of a species. Although this equation was originally empirical, it is possible to derive this equation from statistical thermodynamics where b corresponds to the excluded volume of a single species and a quantifies the magnitude of attraction between species. As a result, the first term typically accounts for the repulsive interactions between species and the second accounts for attractive interactions. Although its simple functional form makes calculations quite straight-forward, this model is inadequate for modelling the liquid phase and vapour-liquid equilibrium properties. ","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"As result, wanting to keep with the van der Waals equation's simple form, a few engineering cubic equations have been developed. The first noteworthy one of these is the Redlich-Kwong (RK) equation:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"p = fracNk_mathrmBTV-Nb-fracN^2asqrtTV(V+Nb)","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"There is no physical justification for the change in the second term, however, it was found to give improved modelling of the liquid phase. This equation was subsequently improved upon by Soave, resulting in the SRK equation of state:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"p = fracNk_mathrmBTV-Nb-fracN^2alpha(Tomega)V(V+Nb)","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"The alpha function requires an additional parameter, the acentricity factor, which is effectively a measure of the location of the saturation pressure when TT_c=07. The idea behind this is, if you can capture both the critical point and another point along the vapour curve, you will improve the accuracy of your equation of state. This is indeed what happened. Further improvements were also made by Peng and Robinson who introduced their own equation of state (PR):","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"p = fracNk_mathrmBTV-Nb-fracN^2alpha(Tomega)V^2+2NbV+b^2N^2","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Both the SRK and PR equations of state are comparable in performance, although the latter generally models liquid densities to a greater degree of accuracy. However, when it comes to modelling complex species such as chains or associating species, both models tend to perform badly. We do note that, within Clapeyron,  the cubic plus association (CPA) equation of state has been labelled as a cubic equation; whilst this is the case, we will describe it in greater detail when discussing the SAFT-type models as it main improvement over other cubics is borrowed from the SAFT theory.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Something that may be apparent in all these equations is the fact that these are all functions that give a pressure and, thus, must be integrated to obtain the Helmholtz free energy. Like the ideal gas equation, there will be missing temperature and compositional dependences which need to be included.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"One may also wonder how to model mixtures using such equations; this can be achieved using mixing rules. Although there are many variants, one of the more-popular ones is the van der Waals one-fluid mixing rules which treats the mixture as having the same parameters bara and barb which can be determined from:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"bara=sum_isum_jx_ix_ja_ij","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"barb=sum_isum_jx_ix_jb_ij","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"More-complicated mixing rules do exist (such as the Wong-Sandler mixing rule) which will be made available in Clapeyron. When i=j, a and b are just the normal van der Waals parameters for the pure. However, when ineq j, these parameter characterise the unlike interactions between i and j. We typically need to use combining rules (not to be confused with mixing rules) to determine the unlike parameters. Examples of these include:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"b_ij=fracb_i+b_j2","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"a_ij = (1-k_ij)sqrta_ia_j","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"where k_ij can be set to 0 but, using either more-advanced combining rules or regression to experimental data, can be tuned to improve the effectiveness of the combining rule. Further details on this will be given for the SAFT models.","category":"page"},{"location":"theory/background/#SAFT-models","page":"Background","title":"SAFT models","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"In comparison to the cubic equations of state, equations based on the Statistical Associating Fluid Theory (SAFT) take a more-theoretical approach. As mentioned earlier, the van der Waals equation can be derived from statistical mechanics where the resultant Helmholtz free energy is given by:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"fracANk_mathrmBT = fracA_mathrmidealNk_mathrmBT+fracA_mathrmHSNk_mathrmBT+fracA_mathrm1(Nk_mathrmBT)^2","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"where the ideal and hard-sphere (HS) terms combine to give the repulsive term whilst the A_1 term results in the attractive term. We can see that, in the van der Waals equation, species are effectively modelled as hard-spheres with dispersive interactions (we sometimes can these London dispersion interactions). The last two terms can be merged into what is referred to as the monomer or segment term. Whilst this is a step up from the ideal term, most species can't be modelled effectively as single spheres and, in cases like water, experiences interactions more complex that simple dispersion (dipoles and hydrogen bonding). ","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Using Wertheim's TPT1 theory of association, it is possible to model species as chains which can interact through both dispersive and associative interactions. The latter is described as interactions through associations sites on the segments which are strong and highly directional (like hydrogen bonding and dipole interactions). This results in the addition of two extra contributions to the Helmholtz free energy (note that the HS and dispersive terms have been merged into a monomer term):","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"fracANk_mathrmBT = fracA_mathrmidealNk_mathrmBT+fracA_mathrmmonoNk_mathrmBT+fracA_mathrmchainNk_mathrmBT+fracA_mathrmassocNk_mathrmBT","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"The chain term accounts for the formation of chains of spherical segments and is generally expressed as:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"fracA_mathrmchainNk_mathrmBT=-sum_ix_i(m_i-1)lng_ii(d_ii)","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"where g_ij(r_ij) is the pair-distribution function (i.e. the likelihood of a segment of species i being present at a distance r from another segment of species j) . Many SAFT equations differ in how to express this pair-distribution function. We note here the introduction of the Barker-Henderson hard-sphere diameter, d which is given by:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"d = int_0^sigma (1-exp-betaphi(r))dr","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"where phi(r) is our effective pair potential and beta=1(k_mathrmBT). This effectively gives a temperature dependence to the size of our segment and accounts for our segment becoming softer as temperature rises.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"The association term accounts for the highly-directional associative interactions (for example, hydrogen bonding). For most SAFT equations of state, it is expressed as:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"fracA_mathrmassocNk_mathrmBT=sum_ix_ileft(sum_aleft(lnX_ia-fracX_ia2right)+fracM_i2right)","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"where X_ia is the fraction of association sites a on species i not bonded to another and M_i is the number of association sites on species i.  X_ia can be solved for using the following system of equations:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"X_ia = (1+rhosum_jx_jsum_bX_jbDelta_ijab)^-1","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"An important aspect of the association term is that the above equation results in a system of equations that typically needs to be solved iteratively; this greatly increases the computational cost of the SAFT equations. Delta_ijab is the association strength between site a on species i with site b on species j; this is also an aspect where SAFT equations usually differ but can all be written generally as:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Delta_ijab = F_ijabK_ijabI_ijab","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Where F_ijab is Mayer's function given by:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"F = exp-betaepsilon^mathrmassoc-1","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"where epsilon^mathrmassoc is the potential depth of the association interaction. K and I differ between equations but, generally, these represent the length scale of the interaction and the likelihood that the sites are correctly orientated such that they overlap, respectively.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Surprisingly, the monomer term is one of the aspects that most distinguishes the different SAFT equations where no two variants use the same equation. However, in general, the monomer term is composed of more than one term:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"fracA_mathrmmonoNk_mathrmBT=fracA_mathrmHSNk_mathrmBT+fracA_mathrm1(Nk_mathrmBT)^2+fracA_mathrm2(Nk_mathrmBT)^3+fracA_mathrm3(Nk_mathrmBT)^4+","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"This is known as a Barker-Henderson perturbative expansion; the N^mathrmth order terms account for interactions between N segments. Most SAFT equations truncate this sum at just the second order term. These terms generally account for the dispersive interactions between segments.","category":"page"},{"location":"theory/background/#Parameters","page":"Background","title":"Parameters","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"Although different SAFT equations use different parameters, most share a common set. These include the parameters that characterise the dispersive interactions (which are usually modelled as pair potentials): the potential depth epsilon (in Kelvin) and the segment size sigma (in Angstrom). We point out here that this potential (and its parameters) is not a bare pair potential which only accounts for the interactions of two species; it is an effective pair potential which accounts for the effects of other species being around the interacting pair, in some cases quantum effects and, if associative interactions are not modelled separately, account for non-dispersive interactions.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"As species can now be modelled as chains of segments, the number of segments, m, also becomes a parameter. One thing to point out about this parameter is it need not be an integer (despite what its name suggest); non-integer values of m can usually be interpreted as segments merging within the chain. ","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Only required for associating species, SAFT equations usually require a parameter for the potential well depth of the association, epsilon^mathrmassoc (in Kelvin) and a parameter characterising the length-scale of the interaction (either a bonding volume, kappa^mathrmassoc or length, r_c^mathrmassoc, either in meters or dimensionless). In the case of the dispersive and associative interaction parameters, there will also be the equivalent parameters characterising unlike interactions between species in a mixture (which can also be obtained from combining rules).","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Unfortunately, due to the complex function form of SAFT equations, it is impossible to directly relate these parameters to critical properties like in the engineering cubics. These parameters are typically obtained by regression using experimental data (typical pure-component saturation pressure and saturated liquid density data).","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"We will next go through each of the variants of the SAFT equation available in Clapeyron and what makes these unique.","category":"page"},{"location":"theory/background/#Original-SAFT","page":"Background","title":"Original SAFT","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"Derived by Chapman et al. (1990), this is the first variant of the SAFT equation of state. This equation can be seen as a `proof of concept' as not many parameters are available (none for mixtures). Nevertheless, some noteworthy features of this equation is its use of a semi-empirical equation to obtain the hard-sphere diameter that depends on the number of segments of a species (no other SAFT variant does this). The chain term uses the hard-sphere pair-distribution function, which has a much-simpler analytical form than what some other SAFT equations choose to use. The association strength, Delta is evaluated in a unique way as well:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Delta_ijab=d_ij^3g_ij^mathrmHSF_ijabkappa_ijab","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"where kappa_ijab is dimensionless. Unfortunately, the implementation of ogSAFT in Clapeyron cannot yet replicate the figures from the original paper. The reason for this is that the monomer / segment term presented in the paper is not the one used to generate the results. The actual term used is developed by Twu et al. (1980) and we are currently attempting to implement this within Clapeyron but it is not clear, as of yet, how it was implemented within the original equation.","category":"page"},{"location":"theory/background/#CK-SAFT","page":"Background","title":"CK-SAFT","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"If the SAFT equation derived by Chapman et al. was the prototype, the variant developed by Huang and Radosz (1990) was the first usable SAFT equation, with over 100 pure-component parameters and many unlike parameters available. CKSAFT effectively simplifies many of the computationally-intensive parts of ogSAFT, using a simpler equation to obtain the hard-sphere diameter and actually providing the correct monomer term within the paper. The chain term between the two equations is identical. Similarly, the association strength only has a minor change:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Delta_ijab=sigma_ij^3g_ij^mathrmHSF_ijabkappa_ijab","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"which slightly reduces the computational cost. However, the most-noteworthy simplification came with the association term. As mentioned earlier, the association fraction needs to be solved for iteratively. However, Huang and Radosz proposed approximations of the association fraction that could be used to solve for the association term explicitly, greatly reducing the computational intensity of these calculations. These approximations have not been implemented within Clapeyron as of yet, but these only impact calculations for species other than alcohols and carboxylic acids. We also point out that Huang and Radosz introduced the concept of association schemes which helps classify species based on how they interaction through association.","category":"page"},{"location":"theory/background/#SAFT-VR-SW","page":"Background","title":"SAFT-VR SW","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"Gil-Villegas et al. (1997) developed a new class of SAFT equations known as SAFT variable range. Here, more emphasis was placed on the potentials used to characterise dispersion interactions where a new parameter was introduced through the potential shape. Whilst many versions of SAFT-VR are proposed, each using different underlying potentials, the one that was chosen as the default was SAFT-VR square-well (SW) with the potential shape parameter lambda (characterising the width of the potential well). Within this framework, novel expressions for the monomer and chain terms were proposed, both being based on the SW potential. The association term remained largely unchanged, with the association strength having the most-noteworthy modification:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Delta_ijab=g_ij^mathrmSWF_ijabkappa_ijab","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Here, kappa_ijab now carries units of volume. Not many parameters are available for this equation of state, primarily being use to model alkanes and perfluoro-alkanes. However, compared to most other SAFT variants, SAFT-VR SW has possibly seen the most extensions, having a group-contribution alternative (SAFT-gamma SW), electrolyte (SAFT-VRE SW) and cross-over theory (SAFT-VRX SW). ","category":"page"},{"location":"theory/background/#soft-SAFT","page":"Background","title":"soft-SAFT","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"Developed by Blas and Vega (2001), whereas SAFT equations up until now have used a hard-sphere reference from which to build the equation of state, soft-SAFT chooses to use a Lennard-Jones reference instead. Because of this, compared to all other SAFT equations, soft-SAFT relies heavily on correlations obtained from molecular-dynamic simulations to obtain the monomer term, pair-distribution function and association strength. Like SAFT-VR SW, soft-SAFT does not have an extensive database of parameters, but has been extended multiple times (cross over theory being the more-noteworthy extension).","category":"page"},{"location":"theory/background/#PC-SAFT","page":"Background","title":"PC-SAFT","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"Possibly the most-popular variant of the SAFT equation, Perturbed-Chain (not polymer-chain) SAFT was developed by Gross and Sadowski (2001) and, like soft-SAFT, chooses a different reference state than previous SAFT equations. This time, we start from the hard-chain (HC), not hard-sphere, expressing the SAFT equation as:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"fracANk_mathrmBT = fracA_mathrmidealNk_mathrmBT+fracA_mathrmHCNk_mathrmBT+fracA_mathrmdispNk_mathrmBT+fracA_mathrmassocNk_mathrmBT","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"This isn't as significant a change as one might initially think as, effectively, the hard-sphere and chain terms (which uses a hard-sphere pair distribution function like CK-SAFT) are combined into the hard chain term. The dispersion term is then simply another correlation, only this time depends on the number of segments as well. It carries many similarities with CK-SAFT, using the same expression for the hard-sphere diameter, pair-distribution function and association term.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"The primary reason behind PC-SAFT's popularity is three-fold. For one, the code for PC-SAFT is available open-source. Secondly, there is an abundance of parameters available (over 250), including unlike parameters. Finally, many variants of the PC-SAFT equation have been developed. These include:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Polar PC-SAFT (PPC-SAFT)\nPC-Polar SAFT (PCP-SAFT); yes, these are distinct equations\nElectrolyte PC-SAFT (ePC-SAFT)\nElectrolyte PPC-SAFT (ePPC-SAFT)\nPolyelectrolyte ePC-SAFT (epPC-SAFT)\nCritical-point based PC-SAFT (CP-PC-SAFT)\nCritical-point based PPC-SAFT (CP-PPC-SAFT)\nGroup-contribution PC-SAFT (GC-PC-SAFT)\nGroup contribution PPC-SAFT (GC-PPC-SAFT)","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"We will aim to provide some of these variants at a later date.","category":"page"},{"location":"theory/background/#sPC-SAFT","page":"Background","title":"sPC-SAFT","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"Nevertheless, we do provide one of these variants, being the simplified PC-SAFT equation (developed by Von Solms et al. (2003)). Here, the only modifications are to the hard-chain and association terms where, instead of using the generalised expressions for the hard-sphere term and hard-sphere pair-distribution function, by averaging the hard-sphere diameter (effectively treating mixtures as being made-up of identically-sized segments), the pure-component versions of these properties are used instead. The benefit of this is that pure-component parameters determined for PC-SAFT can still be used here, and only the unlike parameters need to be modified.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Similar to PC-SAFT, variants of the sPC-SAFT equation also exist, although no-where near as extensive. Most notably, a significant group-contribution method is available.","category":"page"},{"location":"theory/background/#SAFT-VR-Mie","page":"Background","title":"SAFT-VR Mie","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"One of the most-novel SAFT equation of state, derived by Lafitte et al. (2013), this equation is effectively an extension of the SAFT-VR framework developed by Gil-Villegas et al. (1997), with further improvements. First of these is extending the Barker-Henderson perturbative expansion to third order instead of second order:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"fracA_mathrmmonoNk_mathrmBT=fracA_mathrmHSNk_mathrmBT+fracA_mathrm1(Nk_mathrmBT)^2+fracA_mathrm2(Nk_mathrmBT)^3+fracA_mathrm3(Nk_mathrmBT)^4","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"We do point out that, whilst the first two terms are developed following the SAFT-VR framework, the third order term is more akin to a correlation regressed using molecular dynamic simulations of Mie fluids. This third order term resulted in significant improvements in the modelling of properties near the critical point (without using cross-over theory). The chain term also received further improvements as a result. This is also the only SAFT equation which evaluates the hard-sphere diameter analytically, although numerical approximations are needed (we note that the original SAFT-VR Mie equation used 10-point Gauss-Legendre quadrature, whilst the newer version uses 5-point Gauss-Laguerre quadrature).","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"However, three different versions of the association strength have been developed:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Hard-sphere kernel:\nDelta_ijab=sigma_ij^3g_ij^mathrmHSF_ijabK_ijab\nLennard-Jones kernel:\nDelta_ijab=F_ijabK_ijabI_ijab(epsilon_ijsigma_ij)\nMie kernel:\nDelta_ijab=F_ijabK_ijabI_ijab(epsilon_ijsigma_ijlambda_ij)","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Unfortunately, it seems that there have been inconsistencies between which of these kernels is used in different publications. The current 'default' SAFT-VR Mie equation uses the Lennard-Jones kernel, as such, this is the one used in Clapeyron. We do intend to provide the option to switch between these kernels.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"As it uses a Mie potential is characterised by two shape parameters, lambda_mathrma (characterising the attractive part) and lambda_mathrmr (characterising the repulsive part), both of these have become parameters for each species (although lambda_mathrma is usually set to 6). An interesting aesthetic change is with the number of segments where this is now separated into the shape factor, S, and the number of segments v^*. The latter must now be an integer and the former is a direct measure of how 'fused' the segments are. As we have different association terms, we also have different sets of parameters where the only difference is the length-scale. In the Lennard-Jones and Mie kernels, K_ijab is the 'bonding volume', whereas, in the hard-sphere kernel, it is a 'bonding length', r_ijab^c.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"The SAFT-VR Mie does not have a significantly large repository of parameters (compensated by its group-contribution variant) and has only been extended to electrolytes (SAFT-VRE Mie and eSAFT-VR Mie). ","category":"page"},{"location":"theory/background/#SAFT-VRQ-Mie","page":"Background","title":"SAFT-VRQ Mie","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"A very recent extension of the SAFT-VR Mie equation is the SAFT-VRQ Mie equation developed by Aasen et al. (2019) which modifies the underlying Mie potential using a Feynman-Hibbs potential, which means that a single species is represented by a sum of three Mie potentials. This method attempts to classically account for quantum effects present in small species such as helium, hydrogen and neon. Unfortunately, this equation is limited to just the monomer term and, even then, it is very computationally intensive. We do note that the current implementation in Clapeyron can only model pure-component properties, but we will extend this to mixture in future versions.","category":"page"},{"location":"theory/background/#SAFT-\\gamma-Mie","page":"Background","title":"SAFT-gamma Mie","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"The group-contribution version of SAFT-VR Mie, developed by Papaioannou et al. (2014), the SAFT-gamma Mie equation uses the same general framework as SAFT-VR Mie, although, as it is a group-contribution method, we are able to model heterogenous chains (in previous SAFT equations, all segments in a chain were the same size). The group-contribution methodology is based on that developed by Lymperiadis et al. (2008). 37 groups are currently available for this equation. A noteworthy advantage of using groups is that unlike parameters between groups can be estimated from pure-component data; these can then be readily extended to mixtures without further regression. ","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"This equation has also been extended to electrolytes through SAFT-gammaE Mie.","category":"page"},{"location":"theory/background/#Methods","page":"Background","title":"Methods","text":"","category":"section"},{"location":"theory/background/#The-problem","page":"Background","title":"The problem","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"This document aims to outline all of the various tools used to obtain the relevant properties from a SAFT-type equation of state. In short, SAFT equations of state provide the Helmholtz free energy of a system at a given composition mathbfz, volume V and temperature T:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"A=A(mathbfzVT)","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Taking derivatives of this function (within the Clapeyron module, this is done using automatic differentiation) can give us a wide range of properties which are given in the appendix. However, it is more common that we are interested in the state of a system at certain conditions (mathbfz_0, p_0 , T_0). The answer to this can be determined from the following, deceptively simple, minimisation of the Gibbs free energy:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"min G(mathbfz_0p_0T_0)","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"In the case of SAFT-type equations of state, this can be expressed as:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"min A(mathbfz_0VT_0)+p_0V","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"What isn't obvious in this formulation of the problem is what the variables to be optimised are. Re-expressing this problem in greater detail:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"min sum_i=1^n_mathrmphasephi_i(A(mathbfz_iV_iT_0)+p_0V_i)","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"mathrmst left(sum_i=1^n_mathrmphasesphi_iz_jiright)-z_j0=0quadforall j in 1n_mathrmspecies","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"where the subscript i denotes properties related to a phase i and phi_i is the molar fraction of phase i. One can already see the difficulties behind solving such a problem as we do not often know before-hand how many phases there may be at the conditions (mathbfz_0, p_0 , T_0) and thus, we won't know what variables to optimise for. In addition, we will want the global minimum and, particularly in systems with many components, there may be many local minima which we will need to eliminate.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Nevertheless, if we know certain things about the system before-hand, we can reduce the problem to one that is easier to solve.","category":"page"},{"location":"theory/background/#Volume-solvers","page":"Background","title":"Volume solvers","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"Let us make one simplifying assumption: we know that the system exists in a single phase. This greatly simplifies the problem to:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"min_V A(mathbfz_0VT_0)+p_0V","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Where, as there is no phase split, the only variable we need to optimise is the volume. We can see that this is equivalent to solving for the volume at which the pressure predicted by the equation of state equals p_0:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"min_V A(mathbfz_0VT_0)+p_0Vrightarrowfracpartial partial V(A(mathbfz_0VT_0)+p_0V)=fracpartial Apartial V(mathbfz_0VT_0)+p_0=-p(mathbfz_0VT_0)+p_0=0","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Effectively, we can re-word this as a root-finding problem. One slight issue with this is that there is often more than one root (there can actually be up to five, even in SAFT-type equations). The true root will be the one that minimises the Gibbs free energy; thus we must first find the candidate phases and determine their Gibbs free energy before reporting the volume.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"For the cubics, this problem is quite straight-forward given that (as the name suggests) all these equations can be re-arranged as a cubic equation in V:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"p_0=fracRT_0V-b-fraca(V-c_1)(V-c_2)rightarrow a_0+a_1V+a_2V^2+a_3V^3=0","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Thus, it is very easy to solve for all the roots in a cubic using analytical expressions. However, for other equations of state, we must use non-linear root-finding algorithms. In order to avoid the unstable phases, we try to use initial guesses close to what will be the 'true' phases:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Vapour: Since we can use automatic differentiation to obtain the virial coefficient for any model, we can actually obtain an initial guess extremely close to the final solution using:\nfracp_0RT_0 = fracn_0V+fracn_0V^2B(T)rightarrow V_0=fracRT_0p_0frac-1+sqrt1+4p_0B(T_0)(RT_0)2 \nLiquid: The best we can do here is to obtain the volume corresponding to a large packing fraction (we typically pick 0.6-0.8): V_0 = fracN_mathrmApi6times 08msigma^3 We are still looking for ways to improve this but the volume function is quite reliable as of now.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"One other issue to consider when solving this problem is that, within the liquid phase, the gradients are very large which can be difficult for algorithms to handle (even when providing the exact derivatives through automatic differentiation). We try to reduce magnitude of these derivatives by solving for the logarithm of the volume instead. ","category":"page"},{"location":"to-do_list/#Clapeyron-to-do-list","page":"To-do list","title":"Clapeyron to-do list","text":"","category":"section"},{"location":"to-do_list/","page":"To-do list","title":"To-do list","text":"Clapeyron is developed entirely by three recently graduated chemical engineers in our free time; none of us are experts in writing algorithms but we decided to build this package due to our experience with commerical thermodynamic modelling tools. We will continue developing Clapeyron in our free time but we welcome any contributions you might be willing to make!","category":"page"},{"location":"to-do_list/","page":"To-do list","title":"To-do list","text":"The current plans of Clapeyron are:","category":"page"},{"location":"to-do_list/","page":"To-do list","title":"To-do list","text":"Support more group contribution (GC) models like SAFT-γ SW and GC versions of PC-SAFT and CK-SAFT.\nSupport for more ideal terms (NASA, Wilhoit, etc).\nSupport for flash calculations, first using Ratchford-Rice, and eventually HELD and RAND.\nSupport extensions of the SAFT model (e.g. electrolyte methods and dipole terms).\nCode optimisation by introducing more macros, and changing all string keys to more efficient symbols.","category":"page"},{"location":"user_guide/custom_dtb/#Definitions","page":"Custom Databases","title":"Definitions","text":"","category":"section"},{"location":"user_guide/custom_dtb/","page":"Custom Databases","title":"Custom Databases","text":"Within Clapeyron, we use CSV files to store our parameters. There are four types of database files for different types of parameters:","category":"page"},{"location":"user_guide/custom_dtb/","page":"Custom Databases","title":"Custom Databases","text":"Like parameters: These CSV files have the structure:\nClapeyron Database File  \n{MODEL NAME} Like Parameters  \nspecies param1 param2\nwater 1234 5.678\nThese are used for parameters which only refer to a single species (such as the critical temperature, molar mass, like segment size, number of segments). These types of files are also used for the ideal model databases (since all of these are just for like species).\nUnlike parameters: These CSV files have the structure:\nClapeyron Database File  \n{MODEL NAME} Unlike Parameters  \nspecies1 species2 param\nwater methanol 0.910\nThese are used for parameters which refer to a pair of different species (such as the unlike interaction parameter k_ij).\nAssociation parameters: These CSV files have the structure:\nClapeyron Database File    \n{MODEL NAME} Assoc Parameters    \nspecies1 site1 species2 site2 param\nwater H water e 1.234\nwater H methanol e 5.678\nThese are used for parameters which refer to a pair of species and sites (such as the association potential depth, epsilon_assoc, and bonding volume, bondvol). Note that this can be for associations between the same species and different sites, or different species and different sites (as shown above).","category":"page"},{"location":"user_guide/custom_dtb/","page":"Custom Databases","title":"Custom Databases","text":"Note that it is extremely important that the cell A2 has the word 'Like', 'Unlike' or 'Assoc' in it so that Clapeyron can identify the type of parameters in it. Feel free to check these out in the package to see some better examples!","category":"page"},{"location":"user_guide/custom_dtb/#Using-your-own-parameters","page":"Custom Databases","title":"Using your own parameters","text":"","category":"section"},{"location":"user_guide/custom_dtb/","page":"Custom Databases","title":"Custom Databases","text":"If you have CSV files formatted as above with your own parameters, and you want to implement these into one of the existing equations of state in Clapeyron, all that is needed is to provide the path to those files in the definition of your model:","category":"page"},{"location":"user_guide/custom_dtb/","page":"Custom Databases","title":"Custom Databases","text":"model1 = PR([\"your_species_1\",\"your_species_2\"];userlocations=[\"path/to/your/database/\"])\nmodel2 = PCSAFT([\"your_species_1\",\"your_species_2\"];userlocations=[\"dtb_like\",\"dtb_unlike\",\"dtb_assoc\"])","category":"page"},{"location":"user_guide/custom_dtb/","page":"Custom Databases","title":"Custom Databases","text":"The rest works exactly as it normally would! We recommend reading the background documentation for the various models to ensure the units of the parameters you provide are correct.","category":"page"},{"location":"user_guide/basic_usage/#Clapeyron-User-Guide","page":"Basic Usage","title":"Clapeyron User Guide","text":"","category":"section"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Welcome to Clapeyron!","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Once Clapeyron is installed, it can be loaded using:","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using Clapeyron","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"We may create a model object by calling the constructor of the respective model. For example,","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"model1 = PCSAFT([\"methanol\", \"ethanol\"])\nmodel2 = softSAFT([\"ethane\", \"water\"])","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"We also support group-contribution models like SAFT-ɣ Mie. We have a database of species with the number of each group associated with it for easy lookup, but you may also use your own combinations. We use a tuple of the name of the molecule and an array of the group-multiplicity mappings.","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"model3 = SAFTgammaMie([\n        \"ethanol\",\n        (\"nonadecanol\", [\"CH3\"=>1, \"CH2\"=>18, \"OH\"=>1]),\n        (\"ibuprofen\", [\"CH3\"=>3, \"COOH\"=>1, \"aCCH\"=>1, \"aCCH2\"=>1, \"aCH\"=>4])\n        ]\n    )","category":"page"},{"location":"user_guide/basic_usage/#Available-equations-of-state","page":"Basic Usage","title":"Available equations of state","text":"","category":"section"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Cubic-type:","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"van der Waals (vdW)\nRedlich-Kwong (RK)\nSoave-Redlich-Kwong (SRK)\nPeng-Robinson (PR)\nCubic-plus-association (CPA)","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"SAFT-type:","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"PC-SAFT (PCSAFT)\nsPC-SAFT (sPCSAFT)\nSAFT-ɣ Mie (SAFTgammaMie)\nSAFT-VR Mie (SAFTVRMie)\nSAFT-VRQ Mie (SAFTVRQMie)\nsoft-SAFT (softSAFT)\nOriginal SAFT (ogSAFT)\nCK-SAFT (CKSAFT)\nsCK-SAFT (sCKSAFT)\nLJ-SAFT (LJSAFT)\nBACK-SAFT (BACKSAFT)\nSAFT-VR SW (SAFTVRSW)","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Multi-parameter equations:","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"IAPWS-95 (IAWPS95)\nGERG-2008 (GERG2008)\nPropane Reference (PropaneRef)","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"We also support the SPUNG method (SPUNG)","category":"page"},{"location":"user_guide/basic_usage/#Available-properties","page":"Basic Usage","title":"Available properties","text":"","category":"section"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Once we have our model object, we will be able to call the respective thermodynamic methods to obtain the properties that we are looking for. For example, to find the isobaric heat capacity of a 0.5 mol methanol and 0.5 mol ethanol mixture using PC-SAFT at a pressure of 10 bar and a temperature of 300 K, we just call the isobaric_heat_capacity(model, p, T, z) function with the desired model and conditions as parameters.","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Cp = isobaric_heat_capacity(model1, 10e5, 300, [0.5, 0.5])","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"The functions for the physical properties that we currently support are as follows:","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Bulk properties (must specify p, T, z):\nV = volume(model, p, T, z)\np = pressure(model, V, T, z)\nS = entropy(model, p, T, z)\nmu = chemical_potential(model, p, T, z)\nU = internal_energy(model, p, T, z)\nH = enthalpy(model, p, T, z)\nG = Gibbs_free_energy(model, p, T, z)\nA = Helmholtz_free_energy(model, p, T, z)\nCv = isochoric_heat_capacity(model, p, T, z)\nCp = isobaric_heat_capacity(model, p, T, z)\nbetaT = thermal_compressibility(model, p, T, z)\nbetaS = isentropic_compressibility(model, p, T, z)\nu = speed_of_sound(model, p, T, z)\nalphaV = isobaric_expansitivity(model, p, T, z)\nmuJT = joule_thomson_coefficient(model, p, T, z)\nZ = compressibility_factor(model, p, T, z)\nNote that all of the above functions can be broadcast i.e. if T is an array, instead of a for loop, we can simply:\nCp = isobaric_heat_capacity.(model, p, T, z)\nVapour-liquid equilibrium properties (must specify T, z):\n(p_sat, V_l_sat, V_v_sat) = sat_pure(model, T)\nH_vap = enthalpy_vap(model, T)\nMixture VLE properties are currently in development\nCritical properties:\n(T_c, p_c, V_c) = crit_pure(model)\nMiscellaneous:\nT = inversion_temperature(model, p, z)\nB = second_virial_coefficient(model, T, z)","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"We note that whilst the bulk properties are all compatible with mixtures, the VLE and critical properties methods are only compatible with pure systems. The extension to mixtures is currently in development.","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Clapeyron also supports physical units through the use of Unitful.jl.","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using Unitful\nimport Unitful: bar, °C, mol\n\nCp2 = isobaric_heat_capacity(model1, 5bar, 25°C, [0.5mol, 0.5mol])","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Note that if you do not wish to import specific units, you may also just use a Unitful string, pressure = 20u\"psi\".","category":"page"},{"location":"user_guide/basic_usage/#Customisation","page":"Basic Usage","title":"Customisation","text":"","category":"section"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Although we provide many models, methods and parameters, Clapeyron also allows for easy customisation in all three of these aspects. To find out more how to customise your models, please read the relevant sections in the documentation.","category":"page"},{"location":"#Clapeyron.jl","page":"Home","title":"Clapeyron.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for the modelling of fluids using thermodynamic equations of state. These include the standard cubics (van der Waals, Redlich-Kwong, Peng-Robinson, etc.), SAFT-type equations (PC-SAFT, SAFT-VR Mie, SAFT-gamma Mie, etc.), empirical equations (GERG2008, IAWPS95) and many more.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The documentation is laid out as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Background: Find more information about the origin and differences for each equation of state provided in this package, as well as some of the methods used to obtain the various thermodynamic properties\nUser guide: Find out how to use the equations of state provided in the package, how to use your own parameters, implement your own equation of state or algorithm.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pierre J. Walker, California Institute of Technology\nHon-Wa (Paul) Yew, Imperial College London\nAndrès Riedemann, University of Concepción","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Clapeyron.jl is licensed under the MIT license.","category":"page"},{"location":"#Instillation","page":"Home","title":"Instillation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Clapeyron.jl is not currently a registered package (will be soon!) but can be installed by running:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add git@github.com:ypaul21/Clapeyron.jl.git ","category":"page"},{"location":"user_guide/custom_methods/#Definitions","page":"Custom Methods","title":"Definitions","text":"","category":"section"},{"location":"user_guide/custom_methods/","page":"Custom Methods","title":"Custom Methods","text":"Within Clapeyron, we provide a few methods which we use to obtain thermodynamic properties (you can find out more details on how we implement these methods in our background information):","category":"page"},{"location":"user_guide/custom_methods/","page":"Custom Methods","title":"Custom Methods","text":"volume(model, p, T, z): Obtains the volume of a system at a given temperature, pressure and composition. If the phase is unknown, it will find the vapour and liquid roots and return the one that minimises the Gibbs free energy. This function is called by all of our bulk property methods.\nsat_pure(model, T): Obtains the saturation pressures and volumes for a pure species.\ncrit_pure(model): Obtains the critical point for a pure species.","category":"page"},{"location":"user_guide/custom_methods/","page":"Custom Methods","title":"Custom Methods","text":"Clearly this is not an exhaustive list and we make absolutely no guarantees as to the quality of these methods. However, if you have a new method or algorithm you would like to implement or test out, it is possible to do so.","category":"page"},{"location":"user_guide/custom_methods/#Custom-initial-guesses-example","page":"Custom Methods","title":"Custom initial guesses example","text":"","category":"section"},{"location":"user_guide/custom_methods/","page":"Custom Methods","title":"Custom Methods","text":"One of the most common reasons for our methods to fail (that we've seen) is due to poor initial guesses. If you are experiencing issues with our sat_pure method specifically, you could try modifying the initial guess for a particular equation of state (see the custom models documentation for explanation on abstract types):","category":"page"},{"location":"user_guide/custom_methods/","page":"Custom Methods","title":"Custom Methods","text":"function Clapeyron.x0_sat_pure(model::PCSAFTModel,T,z=SA[1.0])\n  # Obtain the volume lower bound for that particular system\n  Vlb = lb_volume(model,z)*one(T)\n  \n  # Relative to the lower bound, define your initial guesses. We log10 the results as our solvers solve for the log10 of the volume.\n  return log10.([Vlb*1.5,Vlb*100])\nend","category":"page"},{"location":"user_guide/custom_methods/","page":"Custom Methods","title":"Custom Methods","text":"Note that we do need prefix x0_sat_pure with Clapeyron. as we do not export this function normally; including this function in our script with force Clapeyron to use it instead of the default. These modifications can also be done for x0_crit_pure although crit_pure has proven to be quite reliable.","category":"page"},{"location":"user_guide/custom_methods/#Custom-volume-solver-example","page":"Custom Methods","title":"Custom volume solver example","text":"","category":"section"},{"location":"user_guide/custom_methods/","page":"Custom Methods","title":"Custom Methods","text":"For something a bit more substantial, you can also modify the volume function itself. Since this function is exported in Clapeyron, you do not need to prefix with Clapeyron.:","category":"page"},{"location":"user_guide/custom_methods/","page":"Custom Methods","title":"Custom Methods","text":"function volume(model::EoSModel,p,T,z=SA[1.0];phase=:unknown,threaded=true)\n  \n  # INSERT YOUR ALGORITHM HERE\n  \n  return vol\nend","category":"page"},{"location":"user_guide/custom_methods/","page":"Custom Methods","title":"Custom Methods","text":"Clapeyron will automatically overwrite the default function and use this one instead. ","category":"page"},{"location":"user_guide/custom_methods/","page":"Custom Methods","title":"Custom Methods","text":"If your custom methods end up being more-efficient than ours or you develop one that we do not currently support, please do start a pull request and we will gladly add it to the package!","category":"page"},{"location":"user_guide/custom_model/#Definitions","page":"Custom Models","title":"Definitions","text":"","category":"section"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"Within Clapeyron, it is possible to create your own model/equation of state whilst still using all of the property estimation tools we provide. In order to do this, you must create the model. We provide a macro to make it easy to set it up. If you wish to create a new model called CustomEoS, you just need call the @newmodel macro with three parameters:","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"@newmodel CustomEoS CustomEosModel CustomEosParam","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"Model struct name\nModel abstract type\nModel parameters struct","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"We will now give a brief overview of each of these aspects.","category":"page"},{"location":"user_guide/custom_model/#Model-struct-name","page":"Custom Models","title":"Model struct name","text":"","category":"section"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"This is the concrete type, which is simply the name of the equation of state which will be used to generate the model. Within Clapeyron, we've tried to keep these names as obvious as possible (e.g. vdW, PR, PCSAFT, SAFTVRMie, GERG2008, etc.). For your own model, this can be whatever you want as long is the identification makes sense to you.","category":"page"},{"location":"user_guide/custom_model/#Model-abstract-type","page":"Custom Models","title":"Model abstract type","text":"","category":"section"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"In Julia, objects can only be sub-types of abstract types (and not concrete types), which will allow you to inherit the behaviour of the parent(s). In order to maintain a hierarchy of models, we highly encourage you to create an abstract type for your model that is a subtype one of these families of EoS, and dispatch on this newly created abstract type instead of on your model's concrete type. This is not enforced, but we suffix all abstract types in this category with Model as a convention. The abstract type that is at the top of the hierarchy is EoSModel. From this parent, we branch into more-specific EoS sub-types:","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"SAFTModel: These are the models which have three parameters in common: segment size, sigma, potential depth, epsilon, and number of segments, m. All other SAFT-type models branch from this parent (PCSAFTModel, SAFTVRMieModel, softSAFTModel, etc.). \nCubicModel: These are the models whose parameters can be obtained from the critical temperature and pressure. With the exception of CPAModel, all cubics have a common structure where one can re-arrange the equation for the pressure as a third-order polynomial. As such, we define a subtype of CubicModel, ABCubicModel (e.g. vdWModel, RKModel, SRKModel, PRModel).\nEmpiricHelmholtzModel: These are the high-accuracy, multi-parameter models for specific species or systems (e.g. GERG2008Model, IAPWS95Model). There is no general structure to the models and they are treated as self-contained.\nIdealModel: Often overlooked, these models supplement the SAFTModel and CubicModel by providing the ideal contribution. Whilst the parameters and structure aren't usually the same between ideal models, this is unnecessary as the equation for the pressure is always pV=Nk_mathrmBT . ","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"For example, if we wish to create a new EoS model called CustomEoS, we will create an abstract type CustomEoSModel, that is a sub-type of another abstract type, say CubicModel (but it could also inherit from something further down the hierarchy, like vdWModel):","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"abstract type CustomEoSModel <: CubicModel end","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"For models that are sub-types of SAFTModel or CubicModel, most methods will be instantly compatible because methods will be able to make use of a set of the EoS parameters for finding the initial guesses. If your model is not of either of these types, it will be necessary to define a few additional functions:","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"lb_volume(model::CustomEoSModel,T,z): This must output the smallest possible value of the volume for your particular model using the model parameters. In SAFT equations, this is equivalent to a packing fraction of one (eta=1) whilst in cubics, it is equivalent to the b parameter.\nT_scale(model::CustomEoSModel,z): This must output the temperature scaling for your model using the model parameters. In SAFT equations, this is usually the potential depth whilst in cubics it is the critical temperature.\np_scale(model::CustomEoSModel,z): This must output the pressure scaling for your model using the model parameters. In cubics, this is the critical pressure whilst in SAFT we use a more complicated definition using the segment sizes and potential depths.","category":"page"},{"location":"user_guide/custom_model/#Model-parameters-struct","page":"Custom Models","title":"Model parameters struct","text":"","category":"section"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"The parameters for a particular system are all stored within a struct that is a subtype of EoSParam. By convention, we suffix these with Param. These structs should contain the model parameters, which comprise objects of types SingleParam{T}, PairParam{T}, and AssocParam{T}, where T is usually a base type (Float64, Integer, String, etc). Below is an example of a generic param struct for a SAFT and cubic model.","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"struct GenericSAFTParam <: EoSParam\n    Mw::SingleParam{Float64}\n    segment::SingleParam{Float64}\n    sigma::PairParam{Float64}\n    epsilon::PairParam{Float64}\n    epsilon_assoc::AssocParam{Float64}\n    bondvol::AssocParam{Float64}\nend","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"struct GenericCubicParam <: EoSParam\n    Tc::SingleParam{Float64}\n    pc::SingleParam{Float64}\n    Mw::SingleParam{Float64}\n    a::PairParam{Float64}\n    b::PairParam{Float64}\nend","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"The parameters are wrapped in one of the following structs:","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"SingleParam{T}: These are the parameters associated with a pure species or indexed by a single index (i). For example, the molecular weight, number of segments, critical temperature and pressure.\nPairParam{T}: These are the parameters associated with a pair of species or indexed by two indices (i and j). If the two indices are the same (i=j), they refer to the like species, otherwise (ineq j), they refer to the unlike species. For example, the cubic a and b parameters, the SAFT segment size (sigma) and potential depth (epsilon) parameters.\nAssocParam{T}: There are the parameters associated with both a pair of species and association sites (see background documentation for what these are). They are indexed by four indices (the species i and j, and the sites a and b). For example, potential depth of the association interaction (epsilon_assoc) and the bonding volume (bondvol).","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"If there exists a model parameter struct that contains exactly the same parameters as the one that you are about to create, you can also directly use that existing struct.","category":"page"},{"location":"user_guide/custom_model/#PC-SAFT-Example","page":"Custom Models","title":"PC-SAFT Example","text":"","category":"section"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"Once all the above has been defined, we are ready to build our own model. Let us imagine we are trying to implement PCSAFT. ","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"We first define the Model name, type and parameters:","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"# Defining an abstract type for this model type\nabstract type PCSAFTModel <: SAFTModel end\n\n# Defining the parameters used by the model\nstruct PCSAFTParam <: EoSParam\n    Mw::SingleParam{Float64}\n    segment::SingleParam{Float64}\n    sigma::PairParam{Float64}\n    epsilon::PairParam{Float64}\n    epsilon_assoc::AssocParam{Float64}\n    bondvol::AssocParam{Float64}\nend\n\n# Creating a model struct called PCSAFT, which is a sub-type of PCSAFTModel, and uses parameters defined in PCSAFTParam\n@newmodel PCSAFT PCSAFTModel PCSAFTParam","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"The next step is to create an outer constructor for the model that you have just defined. It should have the same name as the struct above. It can take the following arguments, although these can be hard-coded if you so wish:\ncomponents: A list of strings that identify the components.\nidealmodel: An ideal model, but this can be left as an optional parameter.\nuserlocations: A list of strings that are paths to the databases that you are using.\nideal_userlocations: Same as above, but for ideal models.\nverbose: For when you want to print more information to the console.","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"function PCSAFT(components; idealmodel=BasicIdeal, userlocations=String[], ideal_userlocations=String[], verbose=false)\n  \t# Obtain a Dict of parameters. We pass in custom locations through the optional parameter userlocations.\n    params = getparams(components; userlocations=userlocations, verbose=verbose)\n  \n    # For clarity, we assign the contents of the returned dict to their own variables.\n    segment = params[\"m\"]\n    k = params[\"k\"]\n    Mw = params[\"Mw\"]\n    # Here, we modify the values of the sigma parameter first.\n    params[\"sigma\"].values .*= 1E-10\n  \n    # In some cases, we may not have the unlike parameters and will need to use combining rules. You can also define your own combining rules for this.\n    sigma = sigma_LorentzBerthelot(params[\"sigma\"])\n    epsilon = epsilon_LorentzBerthelot(params[\"epsilon\"], k)\n  \n    epsilon_assoc = params[\"epsilon_assoc\"]\n    bondvol = params[\"bondvol\"]\n  \n    # Build the sites object for associating species. The input is a Dict that links the name of the site with the multiplicity.\n    sites = SiteParam(Dict(\"e\" => params[\"n_e\"], \"H\" => params[\"n_H\"]))\n  \n    # Now we can create the parameter struct that we have defined.\n    packagedparams = PCSAFTParam(Mw, segment, sigma, epsilon, epsilon_assoc, bondvol)\n  \n    # Although optional, it's generally good practise to cite your models!\n    references = [\"10.1021/ie0003887\", \"10.1021/ie010954d\"]\n\n    # Build the model.\n    model = PCSAFT(packagedparams, sites, idealmodel; ideal_userlocations=ideal_userlocations, references=references, verbose=verbose)\n  \n    # Return the PCSAFT object that you have just created.\n    return model\nend","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"Define all of the model equations. We encourage you to use the full range of Unicode characters where it makes your code clearer to read!\nAs convention, the first four arguments should be model, V, T and z; any other variables should come after them.\nIf we obey that convention, we may use the @f macro, which automatically substitutes the first four parameters for compactness. For example, @f(func,i,j) is equivalent to calling func(model,V,T,z,i,j).\nfunction a_res(model::PCSAFTModel, V, T, z)\n    return @f(a_hc) + @f(a_disp) + @f(a_assoc)\nend\n\nfunction a_hc(model::PCSAFTModel, V, T, z)\n    x = z/∑(z)\n    m = model.params.segment.values\n    m̄ = ∑(x .* m)\n    return m̄*@f(a_hs) - ∑(x[i]*(m[i]-1)*log(@f(g_hs,i,i)) for i ∈ @comps)\nend\n\nfunction d(model::PCSAFTModel, V, T, z, i)\n    ϵii = model.params.epsilon.diagvalues[i]\n    σii = model.params.sigma.diagvalues[i]\n    return σii * (1 - 0.12exp(-3ϵii/T))\nend\n\nfunction ζ(model::PCSAFTModel, V, T, z, n)\n    ∑z = ∑(z)\n    x = z * (one(∑z)/∑z)\n    m = model.params.segment.values\n    res = N_A*∑z*π/6/V * ∑((x[i]*m[i]*@f(d,i)^n for i ∈ @comps))\nend\n\nfunction g_hs(model::PCSAFTModel, V, T, z, i, j)\n    di = @f(d,i)\n    dj = @f(d,j)\n    ζ2 = @f(ζ,2)\n    ζ3 = @f(ζ,3)\n    return 1/(1-ζ3) + di*dj/(di+dj)*3ζ2/(1-ζ3)^2 + (di*dj/(di+dj))^2*2ζ2^2/(1-ζ3)^3\nend\n\nfunction a_hs(model::PCSAFTModel, V, T, z)\n    ζ0 = @f(ζ,0)\n    ζ1 = @f(ζ,1)\n    ζ2 = @f(ζ,2)\n    ζ3 = @f(ζ,3)\n    return 1/ζ0 * (3ζ1*ζ2/(1-ζ3) + ζ2^3/(ζ3*(1-ζ3)^2) + (ζ2^3/ζ3^2-ζ0)*log(1-ζ3))\nend\n\n# INSERT REST OF CODE\nWith all the above defined in a single script, we can save the file as PCSAFT.jl and then include it in our jupyter notebooks (for example) and use the model with all of our existing method:\ninclude(\"PCSAFT.jl\")\n\nmodel = PCSAFT([\"carbon dioxide\"])\n\np = 20e6\nT = range(290,460,length=200)\n\nCp = isobaric_heat_capacity.(model, p, T)\n\n(T_c, p_c, V_c) = crit_pure(model)\n\nT_sat = range(220,T_c,length=200)\n\n(p_sat, V_l_sat, V_v_sat) = sat_pure(model,T_sat)","category":"page"},{"location":"user_guide/custom_model/#sPC-SAFT-Example","page":"Custom Models","title":"sPC-SAFT Example","text":"","category":"section"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"Instead of developing an entirely new model, some of us may want to modify or extend an existing one. sPCSAFT is an example where we want to modify parts of regular PCSAFT but keep the rest the same. We can do this in a very succinct way making this new model a sub-type of the abstract type associated with another model.","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"When we define the model type, sPCSAFT is a sub-type of PCSAFT:\nabstract type sPCSAFTModel <: PCSAFTModel end\nSince the parameters are the same, we can just use the same model params when creating the model:\n@newmodel sPCSAFT sPCSAFTModel PCSAFTParam\nThis may not be the case if we're extending a model (e.g. if we're adding polar or ionic terms, we may need to define a new parameter struct to include the new parameters).\nWhen defining the model equations, we only need to write those that have been changed in sPCSAFT:\nfunction a_hc(model::sPCSAFTModel, V, T, z)\n    x = z/sum(z)\n    m = model.params.segment.values\n    m̄ = ∑(x .* m)\n    return m̄*@f(a_hs) - (m̄-1)*log(@f(g_hs))\nend\n\nfunction g_hs(model::sPCSAFTModel, V, T, z)\n    η = @f(ζ,3)\n    return (1-η/2)/(1-η)^3\nend\n\nfunction a_hs(model::sPCSAFTModel, V, T, z)\n    η = @f(ζ,3)\n    return (4η-3η^2)/(1-η)^2\nend","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"The rest works exactly as it would with the PCSAFT example.","category":"page"}]
}
