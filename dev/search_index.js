var documenterSearchIndex = {"docs":
[{"location":"notebook_examples/#Notebook-Examples","page":"Notebook Examples","title":"Notebook Examples","text":"","category":"section"},{"location":"notebook_examples/","page":"Notebook Examples","title":"Notebook Examples","text":"This is a list of currently available example notebooks for Clapeyron.jl:","category":"page"},{"location":"notebook_examples/","page":"Notebook Examples","title":"Notebook Examples","text":"Ideal Equations of State: Examples of how one can use ideal equations of state within Clapeyron.jl, whether it be supplementing a residual equation of state or independently.\nCubic equations of state: Examples of how one can use cubic equations of state, along with customizing those with different α-functions, Volume translation or mixing rules.\nSAFT equations of state: Examples of how one can use SAFT-type equations.\nActivity models: Examples on how to use activity models, standalone or as a mixing rule in a cubic equation of state.\nUser defined equations of state: Example of how to implement a new equation of state within Clapeyron.jl. In this case will be the SAFT-VR Mie+AT model developed by Walker et al. which is simply a modification of the regular SAFT-VR Mie equation of state.\nMiscellaneous pure vapour-liquid equilibrium properties: Examples of pure component vapour-liquid equilibrium properties\nMixing functions: Examples of calculation of mixing and excess properties\nMulti-component equilibrium and critical points: Examples of the various equilibrium and critical properties. focused on the uncommon, more-complex types of diagrams.\nDifferential Evolution Flash Algorithm in Clapeyron.jl: demonstration of a multicomponent flash algorithm for use with Clapeyron.jl, which utilizes the excellent differential evolution black box optimization algorithms in BlackBoxOptim.jl.","category":"page"},{"location":"api/properties/","page":"Properties","title":"Properties","text":"CurrentModule = Clapeyron","category":"page"},{"location":"api/properties/#Contents","page":"Properties","title":"Contents","text":"","category":"section"},{"location":"api/properties/","page":"Properties","title":"Properties","text":"Pages = [\"properties.md\"]","category":"page"},{"location":"api/properties/#Index","page":"Properties","title":"Index","text":"","category":"section"},{"location":"api/properties/","page":"Properties","title":"Properties","text":"Pages = [\"properties.md\"]","category":"page"},{"location":"api/properties/#Automatic-Differenciation-functions","page":"Properties","title":"Automatic Differenciation functions","text":"","category":"section"},{"location":"api/properties/","page":"Properties","title":"Properties","text":"All bulk properties in Clapeyron are calculated via a combination of these Automatic Differenciation Primitives. ","category":"page"},{"location":"api/properties/","page":"Properties","title":"Properties","text":"Clapeyron.∂f∂T\nClapeyron.∂f∂V\nClapeyron.∂f\nClapeyron.p∂p∂V\nClapeyron.∂2f\nClapeyron.∂2p\nClapeyron.f_hess\nClapeyron.∂²³f","category":"page"},{"location":"api/properties/#Clapeyron.∂f∂T","page":"Properties","title":"Clapeyron.∂f∂T","text":"∂f∂T(model,V,T,z=SA[1.0])\n\nreturns f and ∂f/∂T at constant total volume and composition, where f is the total helmholtz energy, given by eos(model,V,T,z)\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.∂f∂V","page":"Properties","title":"Clapeyron.∂f∂V","text":"∂f∂V(model,V,T,z=SA[1.0])\n\nreturns f and ∂f/∂V at constant temperature and composition, where f is the total helmholtz energy, given by eos(model,V,T,z), and V is the total volume\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.∂f","page":"Properties","title":"Clapeyron.∂f","text":"∂f(model,V,T,z)\n\nreturns zeroth order (value) and first order derivative information of the total helmholtz energy (given by eos(model,V,T,z)). the result is given in two values:\n\ngrad_f,fval = ∂2f(model,V,T,z)\n\nwhere:\n\nfval   = f(V,T) = eos(model,V,T,z)\n\ngrad_f = [ ∂f/∂V; ∂f/∂T]\n\n\nWhere V is the total volume, T is the temperature and f is the total helmholtz energy.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.p∂p∂V","page":"Properties","title":"Clapeyron.p∂p∂V","text":"p∂p∂V(model,V,T,z=SA[1.0])\n\nreturns p and ∂p/∂V at constant temperature, where p is the pressure = pressure(model,V,T,z) and V is the total Volume.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.∂2f","page":"Properties","title":"Clapeyron.∂2f","text":"∂2f(model,V,T,z)\n\nreturns zeroth order (value), first order and second order derivative information of the total helmholtz energy (given by eos(model,V,T,z)). the result is given in three values:\n\nhess_f,grad_f,fval = ∂2f(model,V,T,z)\n\nwhere: ``` fval   = f(V,T) = eos(model,V,T,z)\n\ngrad_f = [ ∂f/∂V; ∂f/∂T]\n\nhess_f = [ ∂²f/∂V²; ∂²f/∂V∂T           ∂²f/∂V∂T; ∂²f/∂V²]  ```\n\nWhere V is the total volume, T is the temperature and f is the total helmholtz energy.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.∂2p","page":"Properties","title":"Clapeyron.∂2p","text":"∂2p(model,V,T,z)\n\nreturns zeroth order (value), first order and second order derivative information of the pressure. the result is given in three values:\n\nhess_p,grad_p,pval = ∂2p(model,V,T,z)\n\nwhere: ``` pval   = p(V,T) = pressure(model,V,T,z)\n\ngrad_p = [ ∂p/∂V; ∂p/∂T]\n\nhess_p = [ ∂²p/∂V²; ∂²p/∂V∂T           ∂²p/∂V∂T; ∂²p/∂V²]  ```\n\nWhere V is the total volume, T is the temperature and p is the pressure.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.f_hess","page":"Properties","title":"Clapeyron.f_hess","text":"f_hess(model,V,T,z)\n\nreturns the second order volume (V) and temperature (T) derivatives of the total helmholtz energy (given by eos(model,V,T,z)). the result is given in a 2x2 SMatrix, in the form:\n\n[ ∂²f/∂V²  ∂²f/∂V∂T  ∂²f/∂V∂T  ∂²f/∂T²]\n\nuse this instead of the ∂2f if you only need second order information. ∂2f also gives zeroth and first order derivative information, but due to a bug in the used AD, it allocates more than necessary.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.∂²³f","page":"Properties","title":"Clapeyron.∂²³f","text":"∂²³f(model,V,T,z=SA[1.0])\n\nreturns ∂²A/∂V² and ∂³A/∂V³, in a single ForwardDiff pass. used mainly in crit_pure objective function\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Volume-Temperature-Based-Properties","page":"Properties","title":"Volume-Temperature Based Properties","text":"","category":"section"},{"location":"api/properties/","page":"Properties","title":"Properties","text":"Clapeyron.pressure\nClapeyron.second_virial_coefficient\nClapeyron.pip","category":"page"},{"location":"api/properties/#Clapeyron.pressure","page":"Properties","title":"Clapeyron.pressure","text":"pressure(model::EoSModel, V, T, z=SA[1.])\n\ndefault units: [Pa]\n\nReturns the pressure of the model at a given volume, temperature and composition, defined as:\n\np =  -∂A/∂V\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.second_virial_coefficient","page":"Properties","title":"Clapeyron.second_virial_coefficient","text":"second_virial_coefficient(model::EoSModel, T, z=SA[1.])\n\nCalculates the second virial coefficient B, defined as:\n\nB = lim(V->∞)[ V^2/RT *  (∂Aᵣ∂V + V*∂²Aᵣ∂V²) ]\n\nwhere Aᵣ is the residual helmholtz energy.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.pip","page":"Properties","title":"Clapeyron.pip","text":"pip(model::EoSModel,V,T,z=[1.0])\n\nPhase identification parameter Π. as described in 1. If Π > 1, then the phase is clasified as a liquid or a liquid-like vapor, being a vapor or vapor-like liquid otherwise.\n\nThis identification parameter fails at temperatures and pressures well aboVe the critical point.\n\nCalculated as:\n\nΠ = V*((∂²p/∂V∂T)/(∂p/∂T) - (∂²p/∂V²)/(∂p/∂V))\n\nG. Venkatarathnama, L.R. Oellrich, Identification of the phase of a fluid using partial derivatives of pressure, volume,and temperature without reference to saturation properties: Applications in phase equilibria calculations, Fluid Phase Equilibria 301 (2011) 225–233\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Pressure-Temperature-Based-Bulk-Properties","page":"Properties","title":"Pressure-Temperature Based Bulk Properties","text":"","category":"section"},{"location":"api/properties/","page":"Properties","title":"Properties","text":"In general almost all bulk properties follow the pattern:","category":"page"},{"location":"api/properties/","page":"Properties","title":"Properties","text":"function property(model::EoSModel, p, T, z=SA[1.]; phase = :unknown,threaded=true)\n    V = volume(model, p, T, z; phase=phase, threaded=threaded)\n    return VT_property(model,V,T,z)\nend","category":"page"},{"location":"api/properties/","page":"Properties","title":"Properties","text":"So, you can calculate the property with Volume-Temperature variables by calling VT_property(model,V,T,z). Another way to do this is by using units,provided by Unitful.jl:","category":"page"},{"location":"api/properties/","page":"Properties","title":"Properties","text":"using Unitful\nr = 18u\"kg/m^3\"\nT = 373.15\"K\"\nprop = helholtz_free_energy(model,r,T,z,output = u\"kJ\")","category":"page"},{"location":"api/properties/","page":"Properties","title":"Properties","text":"Where r could be any molar or mass density, molar or mass volume, total volume or pressure. it also supports mass and mol amounts defined as units for the composition (z) If no units are provided for the composition, they will be considered moles.","category":"page"},{"location":"api/properties/#Methods-that-require-first-order-VT-derivatives","page":"Properties","title":"Methods that require first order VT derivatives","text":"","category":"section"},{"location":"api/properties/","page":"Properties","title":"Properties","text":"Clapeyron.volume\nClapeyron.helmholtz_free_energy\nClapeyron.molar_density\nClapeyron.mass_density\nClapeyron.compressibility_factor\nClapeyron.gibbs_free_energy\nClapeyron.entropy\nClapeyron.entropy_res\nClapeyron.enthalpy\nClapeyron.internal_energy","category":"page"},{"location":"api/properties/#Clapeyron.volume","page":"Properties","title":"Clapeyron.volume","text":"volume(model::EoSModel,p,T,z=SA[1.0];phase=:unknown,threaded=true)\n\ncalculates the volume (m³) of the compound modelled by model at a certain pressure,temperature and moles.\n\nphase is a Symbol that determines the initial volume root to look for:\n\nIf phase =:unknown (Default), it will return the physically correct volume root with the least gibbs energy. \nIf phase =:liquid, it will return the volume of the phase using a liquid initial point.\nIf phase =:vapor, it will return the volume of the phase using a gas initial point.\nIf phase =:stable, it will return the physically correct volume root with the least gibbs energy, and perform a stability test on the result.\n\nAll volume calculations are checked for mechanical stability, that is: dP/dV <= 0.\n\nThe calculation of both volume roots can be calculated in serial (threaded=false) or in parallel (threaded=true)\n\nwarning: Stability checks\nThe stability check is disabled by default. that means that the volume obtained just follows the the relation P = pressure(model,V,T,z). For single component models, this is alright, but phase splits (with different compositions that the input) can and will occur, meaning that the volume solution does not correspond to an existing phase.For unknown multicomponent mixtures, it is recommended to use a phase equilibrium procedure (like tp_flash) to obtain a list of valid compositions, and then perform a volume calculation over those compositions. You can also pass phase=:stable to perform the stability test inside the volume solver. Finally, you can perform the stability test after the volume solver:v = volume(model,p,T,z)\nisstable(model,v,T,z)\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.helmholtz_free_energy","page":"Properties","title":"Clapeyron.helmholtz_free_energy","text":"helmholtz_free_energy(model::EoSModel, p, T, z=SA[1.]; phase = :unknown, threaded=true)\n\nDefault units: [J]\n\nCalculates the helmholtz free energy, defined as:\n\nA = eos(model,V(p),T,z)\n\nInternally, it calls Clapeyron.volume to obtain V and calculates the property via eos(model,V,T,z).\n\nThe keywords phase and threaded are passed to the volume solver.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.molar_density","page":"Properties","title":"Clapeyron.molar_density","text":"molar_density(model::EoSModel, p, T, z=SA[1.]; phase = :unknown, threaded=true)\n\ndefault units: [mol/m^3]\n\nCalculates the molar density, defined as:\n\nρₙ =  ∑nᵢ/V\n\nInternally, it calls Clapeyron.volume to obtain V and  calculates the property via VT_molar_density(model,V,T,z).\n\nThe keywords phase and threaded are passed to the volume solver.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.mass_density","page":"Properties","title":"Clapeyron.mass_density","text":"mass_density(model::EoSModel, p, T, z=SA[1.]; phase = :unknown, threaded=true)\n\ndefault units: [kg/m^3]\n\nCalculates the molar density, defined as:\n\nρₙ =  Mr/V\n\nWhere Mr is the molecular weight of the model at the input composition.\n\nInternally, it calls Clapeyron.volume to obtain V and  calculates the property via VT_mass_density(model,V,T,z).\n\nThe keywords phase and threaded are passed to the volume solver.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.compressibility_factor","page":"Properties","title":"Clapeyron.compressibility_factor","text":"compressibility_factor(model::EoSModel, p, T, z=SA[1.]; phase = :unknown, threaded=true)\n\nCalculates the compressibility factor Z, defined as:\n\nZ = p*V(p)/R*T\n\nThe keywords phase and threaded are passed to Clapeyron.volume.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.gibbs_free_energy","page":"Properties","title":"Clapeyron.gibbs_free_energy","text":"gibbs_free_energy(model::EoSModel, p, T, z=SA[1.]; phase = :unknown, threaded=true)\n\nDefault units: [J]\n\nCalculates the gibbs free energy, defined as:\n\nG = A - V * ∂A/∂V\n\nInternally, it calls Clapeyron.volume to obtain V and calculates the property via VT_gibbs_free_energy(model,V,T,z).\n\nThe keywords phase and threaded are passed to the volume solver.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.entropy","page":"Properties","title":"Clapeyron.entropy","text":"entropy(model::EoSModel, p, T, z=SA[1.]; phase = :unknown, threaded=true)\n\nDefault units: [J/K]\n\nCalculates entropy, defined as:\n\nS = -∂A/∂T\n\nInternally, it calls Clapeyron.volume to obtain V and calculates the property via VT_entropy(model,V,T,z).\n\nThe keywords phase and threaded are passed to the volume solver.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.entropy_res","page":"Properties","title":"Clapeyron.entropy_res","text":"entropy_res(model::EoSModel, p, T, z=SA[1.]; phase = :unknown, threaded=true)\n\nDefault units: [J/K]\n\nCalculates residual entropy, defined as:\n\nS = -∂Ares/∂T\n\nInternally, it calls Clapeyron.volume to obtain V and calculates the property via VT_entropy_res(model,V,T,z).\n\nThe keywords phase and threaded are passed to the volume solver.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.enthalpy","page":"Properties","title":"Clapeyron.enthalpy","text":"enthalpy(model::EoSModel, p, T, z=SA[1.]; phase = :unknown, threaded=true)\n\nDefault units: [J]\n\nCalculates the enthalpy, defined as:\n\nH = A - T * ∂A/∂T - V * ∂A/∂V\n\nInternally, it calls Clapeyron.volume to obtain V and calculates the property via VT_enthalpy(model,V,T,z).\n\nThe keywords phase and threaded are passed to the volume solver.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.internal_energy","page":"Properties","title":"Clapeyron.internal_energy","text":"internal_energy(model::EoSModel, p, T, z=SA[1.]; phase = :unknown, threaded=true)\n\nDefault units: [J]\n\nCalculates the internal energy, defined as:\n\nU = A - T * ∂A/∂T\n\nInternally, it calls Clapeyron.volume to obtain V and calculates the property via VT_internal_energy(model,V,T,z).\n\nThe keywords phase and threaded are passed to the volume solver.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Methods-that-require-second-order-VT-derivatives","page":"Properties","title":"Methods that require second order VT derivatives","text":"","category":"section"},{"location":"api/properties/","page":"Properties","title":"Properties","text":"Clapeyron.isochoric_heat_capacity\nClapeyron.isobaric_heat_capacity\nClapeyron.isothermal_compressibility\nClapeyron.isentropic_compressibility\nClapeyron.speed_of_sound\nClapeyron.isobaric_expansivity\nClapeyron.joule_thomson_coefficient","category":"page"},{"location":"api/properties/#Clapeyron.isochoric_heat_capacity","page":"Properties","title":"Clapeyron.isochoric_heat_capacity","text":"isochoric_heat_capacity(model::EoSModel, p, T, z=SA[1.]; phase = :unknown, threaded=true)\n\nDefault units: [J/T]\n\nCalculates the isochoric heat capacity, defined as:\n\nCv = -T * ∂²A/∂T²\n\nInternally, it calls Clapeyron.volume to obtain V and  calculates the property via VT_isochoric_heat_capacity(model,V,T,z).\n\nThe keywords phase and threaded are passed to the volume solver.\n\nwarning: Accurate ideal model required\nThis property requires at least second order ideal model temperature derivatives. If you are computing these properties, consider using a different ideal model than the BasicIdeal default (e.g. EoS([\"species\"];idealmodel=ReidIdeal)).\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.isobaric_heat_capacity","page":"Properties","title":"Clapeyron.isobaric_heat_capacity","text":"isobaric_heat_capacity(model::EoSModel, p, T, z=SA[1.]; phase = :unknown, threaded=true)\n\nDefault units: [J/T]\n\nCalculates the isobaric heat capacity, defined as:\n\nCp =  -T*(∂²A/∂T² - (∂²A/∂V∂T)^2 / ∂²A/∂V²)\n\nInternally, it calls Clapeyron.volume to obtain V and  calculates the property via VT_isobaric_heat_capacity(model,V,T,z).\n\nThe keywords phase and threaded are passed to the volume solver.\n\nwarning: Accurate ideal model required\nThis property requires at least second order ideal model temperature derivatives. If you are computing these properties, consider using a different ideal model than the BasicIdeal default (e.g. EoS([\"species\"];idealmodel=ReidIdeal)).\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.isothermal_compressibility","page":"Properties","title":"Clapeyron.isothermal_compressibility","text":"isothermal_compressibility(model::EoSModel, p, T, z=SA[1.]; phase = :unknown, threaded=true)\n\ndefault units: [Pa^-1]\n\nCalculates the isothermal compressibility, defined as:\n\nκT =  (V*∂p/∂V)^-1\n\nInternally, it calls Clapeyron.volume to obtain V and  calculates the property via VT_isothermal_compressibility(model,V,T,z).\n\nThe keywords phase and threaded are passed to the volume solver.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.isentropic_compressibility","page":"Properties","title":"Clapeyron.isentropic_compressibility","text":"isentropic_compressibility(model::EoSModel, p, T, z=SA[1.]; phase = :unknown, threaded=true)\n\ndefault units: [Pa^-1]    \n\nCalculates the isentropic compressibility, defined as:\n\nκS =  (V*( ∂²A/∂V² - ∂²A/∂V∂T^2 / ∂²A/∂T² ))^-1\n\nInternally, it calls Clapeyron.volume to obtain V and  calculates the property via VT_isentropic_compressibility(model,V,T,z).\n\nThe keywords phase and threaded are passed to the volume solver.\n\nwarning: Accurate ideal model required\nThis property requires at least second order ideal model temperature derivatives. If you are computing these properties, consider using a different ideal model than the BasicIdeal default (e.g. EoS([\"species\"];idealmodel=ReidIdeal)).\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.speed_of_sound","page":"Properties","title":"Clapeyron.speed_of_sound","text":"speed_of_sound(model::EoSModel, p, T, z=SA[1.]; phase = :unknown, threaded=true)\n\ndefault units: [m/s]\n\nCalculates the speed of sound, defined as:\n\nc =  V * √(∂²A/∂V² - ∂²A/∂V∂T^2 / ∂²A/∂T²)/Mr)\n\nWhere Mr is the molecular weight of the model at the input composition.\n\nInternally, it calls Clapeyron.volume to obtain V and  calculates the property via VT_speed_of_sound(model,V,T,z).\n\nThe keywords phase and threaded are passed to the volume solver.\n\nwarning: Accurate ideal model required\nThis property requires at least second order ideal model temperature derivatives. If you are computing these properties, consider using a different ideal model than the BasicIdeal default (e.g. EoS([\"species\"];idealmodel=ReidIdeal)).\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.isobaric_expansivity","page":"Properties","title":"Clapeyron.isobaric_expansivity","text":"isobaric_expansivity(model::EoSModel, p, T, z=SA[1.]; phase = :unknown, threaded=true)\n\ndefault units: [K^-1]\n\nCalculates the isobaric expansivity, defined as:\n\nα =  -∂²A/∂V∂T / (V*∂²A/∂V²)\n\nInternally, it calls Clapeyron.volume to obtain V and  calculates the property via VT_isobaric_expansivity(model,V,T,z).\n\nThe keywords phase and threaded are passed to the volume solver.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.joule_thomson_coefficient","page":"Properties","title":"Clapeyron.joule_thomson_coefficient","text":"joule_thomson_coefficient(model::EoSModel, p, T, z=SA[1.]; phase = :unknown, threaded=true)\n\ndefault units: [K/Pa]\n\nCalculates the joule thomson coefficient, defined as:\n\nμⱼₜ =  -(∂²A/∂V∂T - ∂²A/∂V² * ((T*∂²A/∂T² + V*∂²A/∂V∂T) / (T*∂²A/∂V∂T + V*∂²A/∂V²)))^-1\n\nInternally, it calls Clapeyron.volume to obtain V and  calculates the property via VT_joule_thomson_coefficient(model,V,T,z).\n\nThe keywords phase and threaded are passed to the volume solver.\n\nwarning: Accurate ideal model required\nThis property requires at least second order ideal model temperature derivatives. If you are computing these properties, consider using a different ideal model than the BasicIdeal default (e.g. EoS([\"species\"];idealmodel=ReidIdeal)).\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Methods-that-first-order-composition-derivatives","page":"Properties","title":"Methods that first order composition derivatives","text":"","category":"section"},{"location":"api/properties/","page":"Properties","title":"Properties","text":"Clapeyron.chemical_potential\nClapeyron.chemical_potential_res\nClapeyron.fugacity_coefficient","category":"page"},{"location":"api/properties/#Clapeyron.chemical_potential","page":"Properties","title":"Clapeyron.chemical_potential","text":"chemical_potential(model::EoSModel, p, T, z=SA[1.]; phase = :unknown, threaded=true)\n\nDefault units: [J/mol]    \n\nCalculates the chemical potential, defined as:\n\nμᵢ = ∂A/∂nᵢ\n\nInternally, it calls Clapeyron.volume to obtain V and calculates the property via VT_chemical_potential(model,V,T,z).\n\nThe keywords phase and threaded are passed to the volume solver.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.chemical_potential_res","page":"Properties","title":"Clapeyron.chemical_potential_res","text":"chemical_potential_res(model::EoSModel, p, T, z=SA[1.]; phase = :unknown, threaded=true)\n\nDefault units: [J/mol]\n\nCalculates the residual chemical potential, defined as:\n\nμresᵢ = ∂Ares/∂nᵢ\n\nInternally, it calls Clapeyron.volume to obtain V and calculates the property via VT_chemical_potential_res(model,V,T,z).\n\nThe keywords phase and threaded are passed to the volume solver.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.fugacity_coefficient","page":"Properties","title":"Clapeyron.fugacity_coefficient","text":"fugacity_coefficient(model::EoSModel, p, T, z=SA[1.]; phase = :unknown, threaded=true)\n\nCalculates the fugacity coefficient φᵢ, defined as:\n\nlog(φᵢ) =  μresᵢ/RT - log(Z)\n\nWhere μresᵢ is the vector of residual chemical potentials and Z is the compressibility factor.\n\nThe keywords phase and threaded are passed to Clapeyron.volume.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Mixing","page":"Properties","title":"Mixing","text":"","category":"section"},{"location":"api/properties/","page":"Properties","title":"Properties","text":"Clapeyron.mixing","category":"page"},{"location":"api/properties/#Clapeyron.mixing","page":"Properties","title":"Clapeyron.mixing","text":"mixing(model::EoSModel, p, T, z=SA[1.], property; phase = :unknown,threaded=true)\n\nCalculates the mixing function for a specified property as:\n\nf_mix = f(p,T,z) - ∑zᵢ*f_pureᵢ(p,T)\n\nThe keywords phase and threaded are passed to the volume solver.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Single-component-properties","page":"Properties","title":"Single component properties","text":"","category":"section"},{"location":"api/properties/","page":"Properties","title":"Properties","text":"Clapeyron.saturation_pressure\nClapeyron.enthalpy_vap\nClapeyron.crit_pure\nClapeyron.acentric_factor","category":"page"},{"location":"api/properties/#Clapeyron.saturation_pressure","page":"Properties","title":"Clapeyron.saturation_pressure","text":"saturation_pressure(model::EoSModel, T, V0 = x0_sat_pure(model,T))\n\nPerforms a single component saturation equilibrium calculation, at the specified temperature T, of one mol of pure sustance specified by model\n\nReturns (p₀, Vₗ, Vᵥ) where p₀ is the saturation pressure (in Pa), Vₗ is the liquid saturation volume (in m³) and Vᵥ is the vapour saturation volume (in m³).\n\nIf the calculation fails, returns  (NaN, NaN, NaN)\n\nV0 is [log10(Vₗ₀),log10(Vᵥ₀)] , where Vₗ₀  and Vᵥ₀ are initial guesses for the liquid and vapour volumes.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.enthalpy_vap","page":"Properties","title":"Clapeyron.enthalpy_vap","text":"enthalpy_vap(model::EoSModel, T)\n\nCalculates ΔH, the difference between saturated vapour and liquid enthalpies at temperature T, in J   \n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.crit_pure","page":"Properties","title":"Clapeyron.crit_pure","text":"crit_pure(model::EoSModel,x0=nothing)\n\nCalculates the critical point of a single component modelled by model. \n\nReturns (Tc, pc, Vc) where Tc is the critical temperature (in K), pc is the critical pressure (in Pa) and Vc is the critical volume (in  m³)\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.acentric_factor","page":"Properties","title":"Clapeyron.acentric_factor","text":"acentric_factor(model::EoSModel)\n\ncalculates the acentric factor using its definition:\n\nω = -log10(psatᵣ) -1, at Tᵣ = 0.7\n\nTo do so, it calculates the critical temperature (using crit_pure) and performs a saturation calculation (with sat_pure)\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Multi-component-properties","page":"Properties","title":"Multi component properties","text":"","category":"section"},{"location":"api/properties/","page":"Properties","title":"Properties","text":"Clapeyron.bubble_pressure\nClapeyron.bubble_temperature\nClapeyron.dew_pressure\nClapeyron.dew_temperature\nClapeyron.azeotrope_pressure\nClapeyron.azeotrope_temperature\nClapeyron.LLE_pressure\nClapeyron.LLE_temperature\nClapeyron.VLLE_pressure\nClapeyron.VLLE_temperature\nClapeyron.crit_mix\nClapeyron.UCEP_mix\nClapeyron.UCST_mix\nClapeyron.gibbs_solvation","category":"page"},{"location":"api/properties/#Clapeyron.bubble_pressure","page":"Properties","title":"Clapeyron.bubble_pressure","text":"bubble_pressure(model::EoSModel, T, x; v0 = x0_bubble_pressure(model,T,x))\n\ncalculates the bubble pressure and properties at a given temperature. Returns a tuple, containing:\n\nBubble Pressure [Pa]\nliquid volume at Bubble Point [m³]\nvapour volume at Bubble Point [m³]\nGas composition at Bubble Point\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.bubble_temperature","page":"Properties","title":"Clapeyron.bubble_temperature","text":"bubble_temperature(model::EoSModel, p, x; T0 = x0_bubble_pressure(model,p,x))\n\ncalculates the bubble temperature and properties at a given pressure. Returns a tuple, containing:\n\nBubble Temperature [K]\nliquid volume at Bubble Point [m³]\nvapour volume at Bubble Point [m³]\nGas composition at Bubble Point\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.dew_pressure","page":"Properties","title":"Clapeyron.dew_pressure","text":"dew_pressure(model::EoSModel, T, y; v0 = x0_dew_pressure(model,T,y))\n\ncalculates the dew pressure and properties at a given temperature. Returns a tuple, containing:\n\nDew Pressure [Pa]\nliquid volume at Dew Point [m³]\nvapour volume at Dew Point [m³]\nLiquid composition at Dew Point\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.dew_temperature","page":"Properties","title":"Clapeyron.dew_temperature","text":"dew_temperature(model::EoSModel, p, y; T0 = x0_dew_temperature(model,p,y))\n\ncalculates the dew temperature and properties at a given pressure. Returns a tuple, containing:\n\nDew Temperature [K]\nliquid volume at Dew Point [m³]\nvapour volume at Dew Point [m³]\nLiquid composition at Dew Point\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.azeotrope_pressure","page":"Properties","title":"Clapeyron.azeotrope_pressure","text":"azeotrope_pressure(model::EoSModel, T; v0 = x0_azeotrope_pressure(model,T))\n\ncalculates the azeotrope pressure and properties at a given temperature. Returns a tuple, containing:\n\nAzeotrope Pressure [Pa]\nliquid volume at Azeotrope Point [m³]\nvapour volume at Azeotrope Point [m³]\nAzeotrope composition\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.azeotrope_temperature","page":"Properties","title":"Clapeyron.azeotrope_temperature","text":"azeotrope_temperature(model::EoSModel, T; v0 = x0_bubble_pressure(model,T,[0.5,0.5]))\n\nCalculates the azeotrope temperature and properties at a given pressure. Returns a tuple, containing:\n\nAzeotrope Temperature [K]\nliquid volume at Azeotrope Point [m³]\nvapour volume at Azeotrope Point [m³]\nAzeotrope composition\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.LLE_pressure","page":"Properties","title":"Clapeyron.LLE_pressure","text":"LLE_pressure(model::EoSModel, T, x; v0 = x0_LLE_pressure(model,T,x))\n\ncalculates the Liquid-Liquid equilibrium pressure and properties at a given temperature.\n\nReturns a tuple, containing:\n\nLLE Pressure [Pa]\nliquid volume of composition x₁ = x at LLE Point [m³]\nliquid volume of composition x₂ at LLE Point  [m³]\nLiquid composition x₂\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.LLE_temperature","page":"Properties","title":"Clapeyron.LLE_temperature","text":"LLE_temperature(model::EoSModel, p, x; T0 = x0_LLE_temperature(model,p,x))\n\ncalculates the Liquid-Liquid equilibrium temperature and properties at a given pressure.\n\nReturns a tuple, containing:\n\nLLE Pressure [Pa]\nliquid volume of composition x₁ = x at LLE Point [m³]\nliquid volume of composition x₂ at LLE Point  [m³]\nLiquid composition x₂\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.VLLE_pressure","page":"Properties","title":"Clapeyron.VLLE_pressure","text":"VLLE_pressure(model::EoSModel, T; v0 = x0_LLE_pressure(model,T))\n\ncalculates the Vapor-Liquid-Liquid equilibrium pressure and properties of a binary mixture at a given temperature.\n\nReturns a tuple, containing:\n\nVLLE Pressure [Pa]\nLiquid volume of composition x₁ at VLLE Point [m³]\nLiquid volume of composition x₂ at VLLE Point  [m³]\nVapour volume of composition y at VLLE Point  [m³]\nLiquid composition x₁\nLiquid composition x₂\nLiquid composition y\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.VLLE_temperature","page":"Properties","title":"Clapeyron.VLLE_temperature","text":"VLLE_temperature(model::EoSModel, p; T0 = x0_LLE_temperature(model,p))\n\ncalculates the Vapor-Liquid-Liquid equilibrium temperature and properties of a binary mixture at a given temperature.\n\nReturns a tuple, containing:\n\nVLLE temperature [K]\nLiquid volume of composition x₁ at VLLE Point [m³]\nLiquid volume of composition x₂ at VLLE Point  [m³]\nVapour volume of composition y at VLLE Point  [m³]\nLiquid composition x₁\nLiquid composition x₂\nLiquid composition y\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.crit_mix","page":"Properties","title":"Clapeyron.crit_mix","text":"crit_mix(model::EoSModel,z;v0=x=x0_crit_mix(model,z))\n\nReturns the critical mixture point at a ginven composition.\n\nReturns a tuple, containing:\n\nCritical Mixture Temperature [K]\nCritical Mixture Pressure [Pa]\nCritical Mixture Volume [m³]\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.UCEP_mix","page":"Properties","title":"Clapeyron.UCEP_mix","text":"UCEP_mix(model::EoSModel;v0=x0_UCEP_mix(model))\n\nCalculates the Upper Critical End Point of a binary mixture.\n\nreturns:\n\nUCEP Temperature [K]\nUCEP Pressure [Pa]\nliquid volume at UCEP Point [m³]\nvapour volume at UCEP Point [m³]\nliquid molar composition at UCEP Point\nvapour molar composition at UCEP Point\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.UCST_mix","page":"Properties","title":"Clapeyron.UCST_mix","text":"UCST_mix(model::EoSModel,T;v0=x0_UCST_mix(model,T))\n\nCalculates the Upper critical solution point of a mixture at a given Temperature.\n\nreturns:\n\nUCST Pressure [Pa]\nvolume at UCST Point [m³]\nmolar composition at UCST Point\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.gibbs_solvation","page":"Properties","title":"Clapeyron.gibbs_solvation","text":"gibbs_solvation(model::EoSModel, T)\n\nCalculates the solvation free energy as:\n\ng_solv = -R̄*T*log(K)\n\nwhere the first component is the solvent and second is the solute.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Consistency-and-Stability","page":"Properties","title":"Consistency and Stability","text":"","category":"section"},{"location":"api/properties/","page":"Properties","title":"Properties","text":"Clapeyron.gibbs_duhem\nClapeyron.isstable\nClapeyron.mechanical_stability\nClapeyron.diffusive_stability","category":"page"},{"location":"api/properties/#Clapeyron.gibbs_duhem","page":"Properties","title":"Clapeyron.gibbs_duhem","text":"gibbs_duhem(model,V,T,z=[1.0])\n\nperforms a Gibbs-Duhem check on the input conditions:\n\n∑zᵢμᵢ - G ≈ 0\n\nWhere G is the total gibbs energy. it can help diagnose if a user-defined eos is consistent.\n\nreturn |∑zᵢμᵢ - G|, ∑zᵢμᵢ and G at the specified conditions.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.isstable","page":"Properties","title":"Clapeyron.isstable","text":"isstable(model,V,T,z)::Bool\n\nPerforms stability tests for a (V,T,z) pair, and warn if any tests fail. returns true/false.\n\nChecks:\n\nmechanical stability: isothermal compressibility is not negative.\ndiffusive stability: all eigenvalues of ∂²A/∂n² are positive.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.mechanical_stability","page":"Properties","title":"Clapeyron.mechanical_stability","text":"mechanical_stability(model,V,T,z)::Bool\n\nPerforms a mechanical stability for a (V,T,z) pair, returns true/false. Checks if isothermal compressibility is not negative. \n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.diffusive_stability","page":"Properties","title":"Clapeyron.diffusive_stability","text":"diffusive_stability(model,V,T,z)::Bool\n\nPerforms a diffusive stability for a (V,T,z) pair, returns true/false. Checks if all eigenvalues of ∂²A/∂n² are positive.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#TP-Flash","page":"Properties","title":"TP Flash","text":"","category":"section"},{"location":"api/properties/","page":"Properties","title":"Properties","text":"Clapeyron.tp_flash\nClapeyron.TPFlashMethod\nClapeyron.DETPFlash\nClapeyron.RRTPFlash\nClapeyron.numphases","category":"page"},{"location":"api/properties/#Clapeyron.tp_flash","page":"Properties","title":"Clapeyron.tp_flash","text":"tp_flash(model, p, T, n, method::TPFlashMethod =DETPFlash())\n\nRoutine to solve non-reactive multicomponent flash problem. The default method uses Global Optimization. see DETPFlash\n\nInputs: \n\nT, Temperature\np, Pressure\nn, vector of number of moles of each species\n\nOutputs - Tuple containing: \n\nxᵢⱼ, Array of mole fractions of species j in phase i\nnᵢⱼ, Array of mole numbers of species j in phase i, [mol]\nG, Gibbs Free Energy of Equilibrium Mixture [J]\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.TPFlashMethod","page":"Properties","title":"Clapeyron.TPFlashMethod","text":"TPFlashMethod\n\nAbstract type for tp_flash routines. it requires defining numphases(method) and tp_flash_impl(model,p,T,n,method).\n\n\n\n\n\n","category":"type"},{"location":"api/properties/#Clapeyron.DETPFlash","page":"Properties","title":"Clapeyron.DETPFlash","text":"DETPFlash(;numphases = 2;max_steps = 1e4*(numphases-1),population_size =20,time_limit = Inf,verbose = false, logspace = false)\n\nMethod to solve non-reactive multicomponent flash problem by finding global minimum of Gibbs Free Energy via Differential Evolution.\n\nUser must assume a number of phases, numphases. If true number of phases is smaller than numphases, model should predict either (a) identical composition in two or more phases, or (b) one phase with negligible total number of moles. If true number of phases is larger than numphases, a thermodynamically unstable solution will be predicted.\n\nThe optimizer will stop at max_steps evaluations or at time_limit seconds\n\n\n\n\n\n","category":"type"},{"location":"api/properties/#Clapeyron.RRTPFlash","page":"Properties","title":"Clapeyron.RRTPFlash","text":"RRTPFlash{T}(;K0 = nothing,rtol= 1e-10,atol = 1e-10,max_iters = 100)\n\nMethod to solve non-reactive multicomponent flash problem by using successive substitution in the Rachford-Rice equation.\n\nOnly two phases are supported. if K0 is nothing, it will be calculated via the Wilson correlation.\n\nThe optimizer will stop at max_iters evaluations, when the absolute tolerance is less than atol or when the relative tolerance is less than rtol\n\n\n\n\n\n","category":"type"},{"location":"api/properties/#Clapeyron.numphases","page":"Properties","title":"Clapeyron.numphases","text":"numphases(method::TPFlashMethod)\n\nreturn the number of phases supported by the TP flash method. by default its set to 2. it the method allows it, you can set the number of phases by doing method(;numphases = n).\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Initial-guess-functions","page":"Properties","title":"Initial guess functions","text":"","category":"section"},{"location":"api/properties/","page":"Properties","title":"Properties","text":"Clapeyron.lb_volume\nClapeyron.T_scale\nClapeyron.p_scale\nClapeyron.x0_volume\nClapeyron.x0_volume_liquid\nClapeyron.x0_volume_gas\nClapeyron.volume_virial\nClapeyron.x0_sat_pure\nClapeyron.x0_crit_pure","category":"page"},{"location":"api/properties/#Clapeyron.lb_volume","page":"Properties","title":"Clapeyron.lb_volume","text":"lb_volume(model::EoSModel,z=SA[1.0])\n\nReturns the lower bound volume. \n\nIt has different meanings depending on the Equation of State, but symbolizes the minimum allowable volume at a certain composition:\n\nSAFT EoS: the packing volume\nCubic EoS, covolume (b) parameter\n\nOn empiric equations of state, the value is chosen to match the volume of the conditions at maximum pressure and minimum temperature , but the equation itself normally can be evaluated at lower volumes.\n\nOn SAFT and Cubic EoS, volumes lower than lb_volume will likely error.\n\nThe lower bound volume is used for guesses of liquid volumes at a certain pressure, saturated liquid volumes and critical volumes.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.T_scale","page":"Properties","title":"Clapeyron.T_scale","text":"T_scale(model::EoS,z=SA[1.0])\n\nRepresents a temperature scaling factor. \n\nOn any EoS based on Critical parameters (Cubic or Empiric EoS), the temperature scaling factor is chosen to be the critical temperature.\n\nOn SAFT or other molecular EoS, the temperature scaling factor is chosen to be a function of the potential depth ϵ.\n\nUsed as scaling factors in saturation_pressure and as input for solving crit_pure\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.p_scale","page":"Properties","title":"Clapeyron.p_scale","text":"p_scale(model::SAFTModel,z=SA[1.0])\n\nRepresents a pressure scaling factor\n\nOn any EoS based on Critical parameters (Cubic or   Empiric EoS), the pressure scaling factor is     chosen to be a function of the critical pressure.\n\nOn SAFT or other molecular EoS, the temperature     scaling factor is chosen to a function of ∑(zᵢϵᵢ(σᵢᵢ)³)    \n\nUsed as scaling factors in saturation_pressure and as input for solving crit_pure\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.x0_volume","page":"Properties","title":"Clapeyron.x0_volume","text":"x0_volume(model,p,T,z; phase = :unknown)\n\nReturns an initial guess of the volume at a pressure, temperature, composition and suggested phase.\n\nIf the suggested phase is :unkwown or :liquid, calls x0_volume_liquid.\n\nIf the suggested phase is :gas, calls x0_volume_gas.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.x0_volume_liquid","page":"Properties","title":"Clapeyron.x0_volume_liquid","text":"x0_volume_liquid(model,T,z)\n\nReturns an initial guess to the liquid volume, dependent on temperature and composition. by default is 1.25 times lb_volume.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.x0_volume_gas","page":"Properties","title":"Clapeyron.x0_volume_gas","text":"x0_volume_gas(model,p,T,z)\n\nReturns an initial guess to the gas volume, depending of pressure, temperature and composition. by default uses volume_virial\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.volume_virial","page":"Properties","title":"Clapeyron.volume_virial","text":"volume_virial(model::EoSModel,p,T,z=SA[1.0])\nvolume_virial(B::Real,p,T,z=SA[1.0])\n\nCalculates an aproximation to the gas volume at specified pressure, volume and composition, by aproximating:\n\n\nZ(v) ≈ 1 + B(T)/v \n\nwhere Z is the compressibility factor and B is the second virial coefficient. If B>0, (over the inversion temperature) returns NaN. If the solution to the problem is complex (Z = 1 + B/v implies solving a quadratic polynomial), returns -2*B.\n\nIf you pass an EoSModel as the first argument, B will be calculated from the EoS at the input T. You can provide your own second virial coefficient instead of a model.\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.x0_sat_pure","page":"Properties","title":"Clapeyron.x0_sat_pure","text":"x0_sat_pure(model::EoSModel,T,z=SA[1.0])\n\nReturns a 2-tuple corresponding to (log10(Vₗ),log10(Vᵥ)), where Vₗ and Vᵥ are the liquid and vapor initial guesses.  Used in saturation_pressure\n\n\n\n\n\n","category":"function"},{"location":"api/properties/#Clapeyron.x0_crit_pure","page":"Properties","title":"Clapeyron.x0_crit_pure","text":"x0_crit_pure(model::SAFTModel)\n\nReturns a 2-tuple corresponding to     (k,log10(Vc0)), where k is Tc0/T_scale(model,z)\n\n\n\n\n\n","category":"function"},{"location":"eos/misc/","page":"Other Models","title":"Other Models","text":"CurrentModule = Clapeyron","category":"page"},{"location":"eos/misc/#Index","page":"Other Models","title":"Index","text":"","category":"section"},{"location":"eos/misc/","page":"Other Models","title":"Other Models","text":"Pages = [\"misc.md\"]","category":"page"},{"location":"eos/misc/#Sanchez-Lacombe-Model","page":"Other Models","title":"Sanchez-Lacombe Model","text":"","category":"section"},{"location":"eos/misc/","page":"Other Models","title":"Other Models","text":"Clapeyron.SanchezLacombe\nClapeyron.mix_vε\nClapeyron.SLKRule\nClapeyron.SLk0k1lMixingRule","category":"page"},{"location":"eos/misc/#Clapeyron.SanchezLacombe","page":"Other Models","title":"Clapeyron.SanchezLacombe","text":"SanchezLacombe(components::Vector{String}; \nidealmodel=BasicIdeal, \nmixing = SLk0k1lMixingRule, \nuserlocations=String[], \nideal_userlocations=String[], \nmixing_userlocations = String[],\nverbose=false)\n\nInput parameters\n\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nsegment: Single Parameter (Float64) - Number of segments (no units)\nepsilon: Single Parameter (Float64) - Nonbonded interaction energy per monomer [J/mol]\nvol: Single Parameter (Float64) - Closed Packed Specific volume [m^3/mol]\n\nModel Parameters\n\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nsegment: Single Parameter (Float64) - Number of segments (no units)\nepsilon: Pair Parameter (Float64) - Nonbonded interaction energy per monomer [J/mol]\nvol: Pair Parameter (Float64) - Closed Packed Specific volume [m^3/mol]\n\nInput models\n\nidealmodel: Ideal Model\nmixing: Mixing model\n\nDescription\n\nSanchez-Lacombe Lattice Fluid Equation of State.\n\nxᵢ = zᵢ/∑zᵢ\nr̄ = ∑xᵢrᵢ\nvᵣ,εᵣ = mix_vε(model,V,T,z,model.mixing,r̄,∑zᵢ)\nρ̃ = r̄*vᵣ/v\nT̃ = R̄*T/εᵣ\naᵣ = r̄*(- ρ̃ /T̃ + (1/ρ̃  - 1)*log(1 - ρ̃ ) + 1)\n\nReferences\n\nNeau, E. (2002). A consistent method for phase equilibrium calculation using the Sanchez–Lacombe lattice–fluid equation-of-state. Fluid Phase Equilibria, 203(1–2), 133–140. doi:10.1016/s0378-3812(02)00176-0\n\n\n\n\n\n","category":"type"},{"location":"eos/misc/#Clapeyron.mix_vε","page":"Other Models","title":"Clapeyron.mix_vε","text":"mix_vε(model::SanchezLacombeModel,V,T,z,mix::SLMixingRule,r̄ = @f(rmix),∑z = sum(z))\n\nFunction used to dispatch on the different mixing rules available for Sanchez-Lacombe.\n\nExample:\n\nfunction mix_vε(model::SanchezLacombe,V,T,z,mix::SLKRule,r̄,Σz = sum(z))\n    v = model.params.vol.values\n    ε = model.params.epsilon.values\n    r =  model.params.segment.values\n    k = mix.k.values\n    x = z ./ Σz\n    ϕ = @. r * x / r̄\n    εᵣ = sum(ε[i,j]*(1-k[i,j])*ϕ[i]*ϕ[j] for i ∈ @comps for j ∈ @comps)\n    vᵣ = sum(v[i,j]*ϕ[i]*ϕ[j] for i ∈ @comps for j ∈ @comps)\n    return vᵣ,εᵣ\n\n\n\n\n\n","category":"function"},{"location":"eos/misc/#Clapeyron.SLKRule","page":"Other Models","title":"Clapeyron.SLKRule","text":"SLKRule(components; userlocations=String[], verbose=false)\n\nInput parameters\n\nk: Pair Parameter (Float64) - Binary Interaction Parameter (no units)\n\nConstant Kᵢⱼ mixing rule for Sanchez-Lacombe:\n\nεᵢⱼ = √εᵢεⱼ*(1-kᵢⱼ)\nvᵢⱼ = (vᵢ + vⱼ)/2\nϕᵢ = rᵢ*xᵢ/r̄\nεᵣ = ΣΣϕᵢϕⱼεᵢⱼ\nvᵣ = ΣΣϕᵢϕⱼvᵢⱼ\n\n\n\n\n\n","category":"type"},{"location":"eos/misc/#Clapeyron.SLk0k1lMixingRule","page":"Other Models","title":"Clapeyron.SLk0k1lMixingRule","text":"SLKRule(components; userlocations=String[], verbose=false)\n\nInput parameters\n\nk0: Pair Parameter (Float64) - Binary Interaction Parameter (no units)\nk1: Pair Parameter (Float64) - Binary Interaction Parameter (no units)\nl: Pair Parameter (Float64) - Binary Interaction Parameter (no units)\n\nNeau's Consistent k₀,k₁,l mixing rule for Sanchez-Lacombe:\n\nεᵢⱼ = √εᵢεⱼ\nvᵢⱼ = (1 - lᵢⱼ)(vᵢ + vⱼ)/2\nϕᵢ = rᵢ*xᵢ/r̄\nεᵣ = ΣΣϕᵢϕⱼεᵢⱼ*(1 - k₀ᵢⱼ + (1 - δᵢⱼ)(Σϕₖk₁ᵢₖ + Σϕₖk₁ₖⱼ))\nvᵣ = ΣΣϕᵢϕⱼvᵢⱼ\n\nWhere δᵢⱼ is i == j ? 1 : 0\n\nReferences\n\nNeau, E. (2002). A consistent method for phase equilibrium calculation using the Sanchez–Lacombe lattice–fluid equation-of-state. Fluid Phase Equilibria, 203(1–2), 133–140. doi:10.1016/s0378-3812(02)00176-0\n\n\n\n\n\n","category":"type"},{"location":"eos/misc/#Extended-Corresponding-states-Model","page":"Other Models","title":"Extended Corresponding states Model","text":"","category":"section"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Once Clapeyron is installed, it can be loaded using:","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using Clapeyron","category":"page"},{"location":"user_guide/basic_usage/#Creating-a-thermodynamic-model","page":"Basic Usage","title":"Creating a thermodynamic model","text":"","category":"section"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"We may create a model object by calling the constructor of the respective equation of state. For example,","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"model1 = PCSAFT([\"methanol\"])\nmodel2 = PR([\"ethane\", \"water\"])\nmodel3 = GERG2008([\"propane\",\"pentane\"])","category":"page"},{"location":"user_guide/basic_usage/#Group-Contribution-Models","page":"Basic Usage","title":"Group Contribution Models","text":"","category":"section"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"We also support group-contribution models like SAFT-ɣ Mie. We have a database of species with the number of each group associated with it for easy lookup, but you may also use your own combinations. We use a tuple of the name of the molecule and an array of the group-multiplicity mappings. For example","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"model4 = SAFTgammaMie([\n        \"ethanol\",\n        (\"ibuprofen\", [\"CH3\"=>3, \"COOH\"=>1, \"aCCH\"=>1, \"aCCH2\"=>1, \"aCH\"=>4])])","category":"page"},{"location":"user_guide/basic_usage/#Available-models","page":"Basic Usage","title":"Available models","text":"","category":"section"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"One can find out more about the information stored within these model objects in the API documentation. In terms of equations of state available, we have the following default models:","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Cubics:","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"van der Waals (vdW)\nRedlich-Kwong (RK)\nSoave-Redlich-Kwong (SRK)\nPredictive Soave-Redlich-Kwong (PSRK)\nPeng-Robinson (PR)\nPeng-Robinson (1978) (PR78)\n\"Universal Mixing Rule\" Peng-Robinson (UMRPR)\nVolume-Translated Peng-Robinson (VTPR)\nQuantum Corrected Peng-Robinson (QCPR)\nEnhanced Predictive Peng-Robinson (1978) (EPPR78)","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"SAFT:","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"SAFT (ogSAFT)\nCK (Chen and Kreglewski) SAFT (CKSAFT)\nSimplified CK-SAFT (sCKSAFT)\nBACKSAFT\nLennard-Jones SAFT (LJSAFT)\nSAFT, Variable Range (VR) ,Square Well (SW) (SAFTVRSW)\nCubic plus Associacion (CPA)\nSimplified CPA (sCPA) \nSoft SAFT, with Lennard-Jones function from Johnson et al. (1993) (softSAFT)\nSoft SAFT, with Lennard-Jones function from Thol et al. (2016)  (softSAFT2016)\nPerturbed-Chain SAFT (PCSAFT)\nSimplified PC-SAFT (sPCSAFT)\nPC-SAFT with T-dependent kᵢⱼ and special correlation for water (pharmaPCSAFT)\nSAFT-VR with Mie potential (SAFTVRMie)\nSAFT-VR with quantum corrected Mie potential (SAFTVRQMie)\nSAFT-γ-Mie (SAFTgammaMie)","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Activity coefficient (N.B. these models only provide VLE properties for mixtures):","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Wilson\nNon-random two-liquid (NRTL)\nUniversal quasichemical Activity Coefficients (UNIQUAC): (UNIQUAC)\nUNIQUAC Functional-group Activity Coefficients (UNIFAC): (UNIFAC)\nConductor-like Screening Model Segment Activity Model (COSMO-SAC)\nCOSMO-SAC (2002 version) (COSMOSAC02)\nCOSMO-SAC (2010 version) (COSMOSAC10)\nCOSMO-SAC with dispersive interactions (COSMOSACdsp)","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Empirical:","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"GERG-2008 EoS for Natural Gas (GERG2008)\nEOS-LNG for Liquified Natural Gas (EOS_LNG)\nIAPWS-95 Water reference (IAPWS95)\nPropane Reference (PropaneRef)\nLennard Jones Reference from Thol et al. (2016) (LJRef)","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"We also support the SPUNG model. One can find out more about each of these equations of state within our background documentation. Nevertheless, all of these equations are compatible with all methods availble in our package. ","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"There a few optional arguments available for these equations which will be explained below. One of these is specifying the location of the parameter databases, the details of which can be found in our Custom databases documentation.","category":"page"},{"location":"user_guide/basic_usage/#Specifying-an-ideal-term","page":"Basic Usage","title":"Specifying an ideal term","text":"","category":"section"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Both SAFT and cubic-type equations of state rely upon an ideal model. By default, Clapeyron uses what we refer to as the BasicIdeal model to account for the ideal contribution which does not require any parameters. For properties which only have derivatives with respect to volume or composition (e.g. volume, isothermal compressibility, critical points, saturation points), or monoatomic species (e.g. noble gases), this is perfectly fine. However, for any other properties or species, the results obtained will most likely be quite poor. This is because this model does not account for the rotational and vibrational modes of the species. To amend this, we provide three additional ideal models to be used instead:","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Monomer ideal correlation (MonomerIdeal)\nWalker and Haslam's ideal correlation (WalkerIdeal)\nJoback's ideal correlation (JobackIdeal)\nReid's polynomial correlation (ReidIdeal)","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"These can be specified for any of the SAFT or cubic-type equations of state using:","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"model5 = PCSAFT([\"carbon dioxide\"]; idealmodel = WalkerIdeal)","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Everything else will work as normal.","category":"page"},{"location":"user_guide/basic_usage/#Specifying-an-alpha-function","page":"Basic Usage","title":"Specifying an alpha function","text":"","category":"section"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"vdW, RK and PR cubic equations rely on an alpha function (SRK is technically just RK but with a different alpha function). Whilst we use the defaults for both RK and PR, it is possible to toggle between them. For example:","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"model6 = RK([\"ethane\",\"propane\"];alpha=SoaveAlpha)","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"The above model would be equivalent to a model built by SRK directly. We support the following alpha functions:","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"RKAlpha: This is the default alpha function for regular RK .\nSoaveAlpha: This is the default alpha function for SRK.\nPRAlpha: This is the default alpha function for regular PR.\nPR78Alpha: This is the default alpha function for PR78.\nBMAlpha: This is the modified alpha function proposed by Boston and Mathias designed to improve estimates above the critical point. This works for both PR and RK.\nTwuAlpha: Proposed by Twu et al., this alpha function uses species-specific parameters rather than correlation and, thus, is slightly more accurate than regular alpha functions. It was intended to be used with PR and is used in VTPR.\nMTAlpha: Proposed by Magoulas and Tassios, this alpha function is essentially like the regular PR alpha function only to a higher order. It is used within UMRPR.","category":"page"},{"location":"user_guide/basic_usage/#Specifying-a-mixing-rule","page":"Basic Usage","title":"Specifying a mixing rule","text":"","category":"section"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Only relevant to cubic equations of state and mixtures, we can alternate between different mixing rules in case these may result in better predictions. We can toggle between these mixing rules:","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"model7 = RK([\"ethane\",\"propane\"];mixing=KayRule)","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"We currently support:","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"vdW1fRule: The standard van der Waals one-fluid mixing rule which is the default in all cubics.\nKayRule: Takes an approach closer to the mixing rules used in SAFT.\nHVRule: The Huron-Vidal mixing rule with uses information from activity coefficient models to form the mixing rule. It is meant to be more accurate than regular mixing rules. As it requires an activity coefficient model, this must be specified:\nmodel7 = RK([\"methanol\",\"benzene\"];mixing=HVRule,activity=Wilson)\nMHV1Rule: The modified Huron-Vidal mixing rule proposed by Michelsen to first order. This has rather significant improvements over the regular mixing rule. Also needs an activity model to be specified.\nMHV2Rule: The modified Huron-Vidal mixing rule proposed by Michelsen to second order. This is meant to be an improvement over the first order rule. Also needs an activity model to be specified.\nWSRule: The Wong-Sandler mixing rule which also relies on an activity model. The equations are slightly more complicated but it is meant to be an improvement compared to HVRule. Also needs an activity model to be specified.\nLCVMRule: The Linear Combiniation of Vidal and Michelsen mixing rules is designed for asymmetric mixtures. Also needs an activity model to be specified.","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"If one goes looking within the source code, they will also find [VTPRRule, PSRKRule,PPR78Rule, QCPRRule and UMRRule; these are only intended for use in their respective models and shouldn't be used otherwise. However, it is still possible to toggle between them.","category":"page"},{"location":"user_guide/basic_usage/#Specifying-a-volume-translation-method","page":"Basic Usage","title":"Specifying a volume translation method","text":"","category":"section"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"In order to improve the predictions of bulk properties in cubics, without affecting VLE properties, a volume translation method can be used which simply shifts the volume within the cubics by c. The default for all cubics is NoTranslation, however, we can toggle between the methods:","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"model7 = RK([\"ethane\",\"propane\"];translation=PenelouxTranslation)","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"We support the following methods:","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"PenelouxTranslation: Used in PSRK.\nRackettTranslation: Used in VTPR.\nMTTranslation: Used in UMRPR.","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Note that not all these methods will be compatible with all species as they require the critical volume of the species.","category":"page"},{"location":"user_guide/basic_usage/#Using-an-Activity-coefficient-model","page":"Basic Usage","title":"Using an Activity coefficient model","text":"","category":"section"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Activity coefficient models are primarily designed to obtain accurate estimate of mixture VLE properties below the critical point of all species. Whilst not as flexible as other equations of state, they are computationally cheaper and, generally, more accurate. The activity coefficients are obtained as only a function of temperature and composition (gamma (Tmathbfx)), meaning we can simply use modified Raoult's law to obtain the bubble (and dew) point:","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"y_ip= x_igamma_ip_mathrmsati","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"The only problem here is that another model must provide the saturation pressure p_mathrmsati. By default, this is chosen to be PR; however, one can toggle this setting as well:","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"model3 = UNIFAC([\"methanol\",\"benzene\"];puremodel=PCSAFT)","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Everything else will work as normal (so long as the species are also available within the specified pure model).","category":"page"},{"location":"user_guide/basic_usage/#Available-properties","page":"Basic Usage","title":"Available properties","text":"","category":"section"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Once we have our model object, we will be able to call the respective thermodynamic methods to obtain the properties that we are looking for. For example, to find the isobaric heat capacity of a 0.5 mol methanol and 0.5 mol ethanol mixture using PC-SAFT at a pressure of 10 bar and a temperature of 300 K, we just call the isobaric_heat_capacity(model, p, T, z) function with the desired model and conditions as parameters.","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Cp = isobaric_heat_capacity(model1, 10e5, 300, [0.5, 0.5])","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"The functions for the physical properties that we currently support are as follows:","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Bulk properties:\nV = volume(model, p, T, z)\np = pressure(model, V, T, z)\nS = entropy(model, p, T, z)\nmu = chemical_potential(model, p, T, z)\nU = internal_energy(model, p, T, z)\nH = enthalpy(model, p, T, z)\nG = Gibbs_free_energy(model, p, T, z)\nA = Helmholtz_free_energy(model, p, T, z)\nCv = isochoric_heat_capacity(model, p, T, z)\nCp = isobaric_heat_capacity(model, p, T, z)\nbetaT = thermal_compressibility(model, p, T, z)\nbetaS = isentropic_compressibility(model, p, T, z)\nu = speed_of_sound(model, p, T, z)\nalphaV = isobaric_expansitivity(model, p, T, z)\nmuJT = joule_thomson_coefficient(model, p, T, z)\nZ = compressibility_factor(model, p, T, z)\ngamma = activity_coefficients(model, p, T, z)\nAll the above functions have two optional arguments (although, technically, z is an optional argument if you're only obtaining properties for a pure species):\nphase: If you already know the phase of the species and want a (minor) speed-up, you can specify it. For example:\nV = volume(model, p, T, z; phase=:liquid)\nThe default value is :unknown where it will find both the vapour and liquid roots first and determine which has the lowest Gibbs free energy.\nthreaded: This determines whether or not to run the vapour and liquid calculations in parallel or not and is only relevant for when the phases are unknown and non-cubic models. \nV = volume(model, p, T, z; threaded=false)\nThe default value is true. This shouldn't change the results.\nNote that all of the above functions can be broadcast i.e. if T is an array, instead of a for loop, we can simply:\nCp = isobaric_heat_capacity.(model, p, T, z)\nVapour-liquid, liquid-liquid and vapour-liquid-liquid equilibrium properties:\nFor pure species:\n(p_sat, V_l_sat, V_v_sat) = saturation_pressure(model, T)\n(T_sat, V_l_sat, V_v_sat) = saturation_temperature(model, p)\nH_vap = enthalpy_vap(model, T)\nFor mixtures:\n(p_bub, V_l_bub, V_v_bub, y) = bubble_pressure(model, T, x)\n(T_bub, V_l_bub, V_v_bub, y) = bubble_temperature(model, p, x)\n(p_dew, V_l_dew, V_v_dew, x) = dew_pressure(model, T, y)\n(T_dew, V_l_dew, V_v_dew, x) = dew_temperature(model, p, y)\n(p_LLE, V_l_LLE, V_ll_LLE, xx) = LLE_pressure(model, T, x)\n(T_LLE, V_l_LLE, V_ll_LLE, xx) = LLE_temperature(model, p, x)\n(p_az, V_l_az, V_v_az, x) = azeotrope_pressure(model, T)\n(T_az, V_l_az, V_v_az, x) = azeotrope_temperature(model, p)\n(p_VLLE,V_l_sat, V_ll_sat, V_v_sat, x, xx, y) = VLLE_pressure(model, T)\n(T_VLLE,V_l_sat, V_ll_sat, V_v_sat, x, xx, y) = VLLE_temperature(model, p)\nAll the above arguments take in an optional argument for the initial guess:\n(p_sat, V_l_sat, V_v_sat) = saturation_pressure(model, T;v0=log10.([V_l0,V_v0]))\nAlthough our calculations tend to be quite robust, this argument is generally useful for when one wants to obtain smooth VLE envelopes quicly when making figures. Here, you'd use a for loop where each iteration uses the previous' iteration value as an initial guess (except the first iteration). For example:\n(p_sat, V_l_sat, V_v_sat) = saturation_pressure(model, T[1])\nfor i in 2:length(T)\n  A = saturation_pressure(model,T[i];v0=log10.([V_l_sat[i-1],V_v_sat[i-1]]))\n  append!(p_sat,A[1])\n  append!(V_l_sat,A[2])\n  append!(V_v_sat,A[3])\nend\nCritical properties:\nFor pure species:\n(T_c, p_c, V_c) = crit_pure(model)\nFor mixtures:\n(T_c, p_c, V_c) = crit_mix(model, z)\n(p_UCST, V_UCST, x_UCST) = UCST_mix(model, T)\n(T_UCEP, p_UCEP, V_l_UCEP, V_v_UCEP, x, y) = UCEP_mix(model)\nLike the above functions, for crit_mix, you can also specify initial guesses to produce smooth critical curves. \nMiscellaneous:\nT = inversion_temperature(model, p, z)\nB = second_virial_coefficient(model, T, z)","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Clapeyron also supports physical units through the use of Unitful.jl.","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using Unitful\nimport Unitful: bar, °C, mol, kg, l\nmodel_unit = PCSAFT([\"methanol\",\"water\"])\nCp2 = isobaric_heat_capacity(model_unit, 5bar, 25°C, [0.5kg, 0.5kg]) # isobaric heat capacity of 1 mol of mixture, at a pressure of 5 bar\nCp2 = isobaric_heat_capacity(model_unit, 1.0l/kg, 25°C, [0.4kg, 0.6kg])  # isobaric heat capacity of 1 kg of mixture, at a volume of 1 L/kg","category":"page"},{"location":"user_guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Note that if you do not wish to import specific units, you may also just use a Unitful string, pressure = 20u\"psi\". This is only supported for bulk properties.","category":"page"},{"location":"to-do_list/#Clapeyron-to-do-list","page":"To-do list","title":"Clapeyron to-do list","text":"","category":"section"},{"location":"to-do_list/","page":"To-do list","title":"To-do list","text":"Clapeyron is developed entirely by three recently graduated chemical engineers in our free time; none of us are experts in writing algorithms but we decided to build this package due to our experience with commercial thermodynamic modelling tools. We will continue developing Clapeyron in our free time but we welcome any contributions you might be willing to make!","category":"page"},{"location":"to-do_list/","page":"To-do list","title":"To-do list","text":"The current plans of Clapeyron are:","category":"page"},{"location":"to-do_list/","page":"To-do list","title":"To-do list","text":"Support more group contribution (GC) models like SAFT-γ SW and GC versions of PC-SAFT and CK-SAFT.\nSupport for more ideal terms (NASA, Wilhoit, etc).\nSupport for flash calculations, first using Ratchford-Rice, and eventually HELD and RAND.\nSupport extensions of the SAFT model (e.g. electrolyte methods and dipole terms).\nMake our code the fastest available. Julia makes this easy.","category":"page"},{"location":"api/macros/","page":"Macros","title":"Macros","text":"CurrentModule = Clapeyron","category":"page"},{"location":"api/macros/#Contents","page":"Macros","title":"Contents","text":"","category":"section"},{"location":"api/macros/","page":"Macros","title":"Macros","text":"Pages = [\"macros.md\"]","category":"page"},{"location":"api/macros/#Index","page":"Macros","title":"Index","text":"","category":"section"},{"location":"api/macros/","page":"Macros","title":"Macros","text":"Pages = [\"macros.md\"]","category":"page"},{"location":"api/macros/#Model-Macros","page":"Macros","title":"Model Macros","text":"","category":"section"},{"location":"api/macros/","page":"Macros","title":"Macros","text":"Clapeyron.@newmodelgc\nClapeyron.@newmodel\nClapeyron.@newmodelsimple\nClapeyron.@registermodel","category":"page"},{"location":"api/macros/#Clapeyron.@newmodelgc","page":"Macros","title":"Clapeyron.@newmodelgc","text":"@newmodelgc modelname parent paramstype\n\nThis is a data type that contains all the information needed to use an EoS model. It also functions as an identifier to ensure that the right functions are called.\n\nThe user is expected to create an outter constructor that takes this signature\n\nfunction modelname(components::Array{String,1})\n\nIt should then return name(params::paramtype, groups::GroupParam, sites::SiteParam, idealmodel::IdealModel)\n\n= Fields = The Struct consists of the following fields:\n\ncomponents: a string lists of components\nicomponents: an iterator that goes through the indices corresponding to each component\ngroups: a GroupParam\nsites: a SiteParam\nparams: the Struct paramstype that contains all parameters in the model\nidealmodel: the IdealModel struct that determines which ideal model to use\nassoc_options: struct containing options for the association solver. see AssocOptions\nreferences: reference for this EoS\n\nSee the tutorial or browse the implementations to see how this is used.\n\n\n\n\n\n","category":"macro"},{"location":"api/macros/#Clapeyron.@newmodel","page":"Macros","title":"Clapeyron.@newmodel","text":"@newmodel name parent paramstype\n\nThis is exactly the same as the above but for non-GC models. All group parameters are absent in this struct. The sites are associated to the main component rather than the groups, and the respective fieldnames are named correspondingly.\n\n\n\n\n\n","category":"macro"},{"location":"api/macros/#Clapeyron.@newmodelsimple","page":"Macros","title":"Clapeyron.@newmodelsimple","text":"@newmodelsimple\n\nEven simpler model, primarily for the ideal models. Contains neither sites nor ideal models.\n\n\n\n\n\n","category":"macro"},{"location":"api/macros/#Clapeyron.@registermodel","page":"Macros","title":"Clapeyron.@registermodel","text":"@registermodel(model)\n\ngiven an existing model, composed of Clapeyron EoS models, ClapeyronParams or EoSParams, it will generate  the necessary traits to make the model compatible with Clapeyron routines.\n\n\n\n\n\n","category":"macro"},{"location":"api/macros/#Utility-Macros","page":"Macros","title":"Utility Macros","text":"","category":"section"},{"location":"api/macros/","page":"Macros","title":"Macros","text":"Clapeyron.@comps\nClapeyron.@groups\nClapeyron.@sites\nClapeyron.@f\nClapeyron.@nan","category":"page"},{"location":"api/macros/#Clapeyron.@comps","page":"Macros","title":"Clapeyron.@comps","text":"@comps\n\nThis macro is an alias to\n\n1:length(model)\n\nThe caveat is that model has to exist in the local namespace. model is expected to be an EoSModel type that contains the icomponents field. icomponents is an iterator that goes through all component indices.\n\n\n\n\n\n","category":"macro"},{"location":"api/macros/#Clapeyron.@groups","page":"Macros","title":"Clapeyron.@groups","text":"@groups\n\nThis macro is an alias to\n\nmodel.groups.i_flattenedgroups\n\niflattenedgroups is an iterator that goes through all groups in flattenedgroups.\n\n\n\n\n\n@groups(component)\n\nThis macro is an alias to\n\nmodel.groups.i_groups[component]\n\ni_groups[component] is an iterator that goes through all groups in relevent to a given component.\n\n\n\n\n\n","category":"macro"},{"location":"api/macros/#Clapeyron.@sites","page":"Macros","title":"Clapeyron.@sites","text":"@sites(component)\n\nThis macro is an alias to\n\nmodel.sites.i_sites[component]\n\ni_sites[component] is an iterator that goes through all sites relevant to each group in a GC model, and to each main component in a non-GC model.\n\n\n\n\n\n","category":"macro"},{"location":"api/macros/#Clapeyron.@f","page":"Macros","title":"Clapeyron.@f","text":"@f(func,a,b,c,...)\n\nThis macro is an alias to\n\nfunc(model, V, T, z, a, b, c, ...)\n\nwhere func is the name of the function, model is the model struct, V is the volume, T is the absolute temperature, z is an array of number of moles of each component, and a, b, c, ... are arbitrary parameters that get passed to func.\n\nIt is very common for functions that are involved in the models to contain the model, V, T and z parameters, so this macro helps reduce code repetition as long as the first four parameters in the function are written exactly as above.\n\n\n\n\n\n","category":"macro"},{"location":"api/macros/#Clapeyron.@nan","page":"Macros","title":"Clapeyron.@nan","text":"@nan(function_call,default=NaN)\n\nWraps the function in a try-catch block, and if a DomainError or DivideError is raised, then returns default. for better results, its best to generate the default result beforehand\n\n\n\n\n\n","category":"macro"},{"location":"eos/ideal/","page":"Ideal Models","title":"Ideal Models","text":"CurrentModule = Clapeyron","category":"page"},{"location":"eos/ideal/#Index","page":"Ideal Models","title":"Index","text":"","category":"section"},{"location":"eos/ideal/","page":"Ideal Models","title":"Ideal Models","text":"Pages = [\"ideal.md\"]","category":"page"},{"location":"eos/ideal/#Ideal-Models","page":"Ideal Models","title":"Ideal Models","text":"","category":"section"},{"location":"eos/ideal/","page":"Ideal Models","title":"Ideal Models","text":"All Clapeyron.jl models can be separated between an ideal and a residual contribution. The ideal contribution can be obtained via integration of the ideal isobaric heat capacity:","category":"page"},{"location":"eos/ideal/","page":"Ideal Models","title":"Ideal Models","text":"fracA_mathrmidealNk_mathrmBT = sum_i=1^N_mathrmComponent x_ileftlnfracrho_irho_0     + frac1Nk_mathrmBT int_T_0^T C_pi^0 dT + fracH_0iNk_mathrmBT- frac1Nk_Bint_T_0^T fracC_pi^0T dT -lnfracTT_0-fracS_0iNk_mathrmB - 1right","category":"page"},{"location":"eos/ideal/","page":"Ideal Models","title":"Ideal Models","text":"Clapeyron.idealmodel\nClapeyron.BasicIdeal\nClapeyron.ReidIdeal\nClapeyron.JobackIdeal\nClapeyron.MonomerIdeal\nClapeyron.WalkerIdeal\nClapeyron.IAPWS95Ideal\nClapeyron.LJRefIdeal","category":"page"},{"location":"eos/ideal/#Clapeyron.idealmodel","page":"Ideal Models","title":"Clapeyron.idealmodel","text":"idealmodel(model::EoSModel)\n\nretrieves the ideal model from the input's model.\n\nExamples:\n\njulia> pr = PR([\"water\"],idealmodel=IAPWS95Ideal)   \nPR{IAPWS95Ideal} with 1 component:\n \"water\"\nContains parameters: a, b, acentricfactor, Tc, Mw   \njulia> Clapeyron.idealmodel(pr)\nIAPWS95Ideal()\n\n\n\n\n\n","category":"function"},{"location":"eos/ideal/#Clapeyron.BasicIdeal","page":"Ideal Models","title":"Clapeyron.BasicIdeal","text":"BasicIdeal <: IdealModel\nBasicIdeal(components::Array{String,1}; \nuserlocations::Array{String,1}=String[], \nverbose=false)\n\nInput parameters\n\nNone\n\nDescription\n\nDefault Ideal Model. Constant specific heat capacity equal to 5R/2. it's Helmholtz energy is equal to:\n\n    a₀ = A₀/nRT =  ∑(xᵢlog(nxᵢ/V)) - 1 - 1.5log(T)\n\n\n\n\n\n","category":"type"},{"location":"eos/ideal/#Clapeyron.ReidIdeal","page":"Ideal Models","title":"Clapeyron.ReidIdeal","text":"ReidIdeal <: IdealModel\nReidIdeal(components; \nuserlocations::Array{String,1}=String[], \nverbose=false)\n\nInput parameters\n\na: Single Parameter (Float64)\nb: Single Parameter (Float64)\nc: Single Parameter (Float64)\nd: Single Parameter (Float64)\n\nModel parameters\n\ncoeffs: Single Parameter (NTuple{4,Float64})\n\nDescription\n\nReid Ideal Model. Helmholtz energy obtained via integration of specific heat capacity:\n\nCpᵢ(T) = aᵢ  + bᵢT + cᵢT^2 + dᵢT^3\nCp(T) = ∑Cpᵢxᵢ\n\n\n\n\n\n","category":"type"},{"location":"eos/ideal/#Clapeyron.JobackIdeal","page":"Ideal Models","title":"Clapeyron.JobackIdeal","text":"JobackIdeal <: JobackIdealModel\nJobackIdeal(components; \nuserlocations::Array{String,1}=String[], \nverbose=false)\n\nInput parameters\n\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nN_a: Single Parameter (Float64)\nT_c: Single Parameter (Float64)\nP_c: Single Parameter (Float64)\nV_c: Single Parameter (Float64)\nT_b: Single Parameter (Float64)\nT_m: Single Parameter (Float64)\nH_form: Single Parameter (Float64)\nG_form: Single Parameter (Float64)\na: Single Parameter (Float64)\nb: Single Parameter (Float64)\nc: Single Parameter (Float64)\nd: Single Parameter (Float64)\nH_fusion: Single Parameter (Float64)\nH_vap: Single Parameter (Float64)\neta_a: Single Parameter (Float64)\neta_b: Single Parameter (Float64)\n\nDescription\n\nJoback Group Contribution Ideal Model. GC version of ReidIdeal. Helmholtz energy obtained via integration of specific heat capacity:\n\naᵢ = ∑(νᵢₖbₖ) - 37.93\nbᵢ = ∑(νᵢₖbₖ) + 0.210\ncᵢ = ∑(νᵢₖcₖ) - 3.91e-4\ndᵢ = ∑(νᵢₖbₖ) + 2.06e-7\nCpᵢ(T) = aᵢ  + bᵢT + cᵢT^2 + dᵢT^3\n\nThe GC-averaged Reid Model is available by using ReidIdeal(model::JobackIdeal).\n\nThe estimated critical point of a single component can be obtained via crit_pure(model::JobackIdeal)\n\nReferences\n\nJoback, K. G., & Reid, R. C. (1987). Estimation of pure-component properties from group-contributions. Chemical Engineering Communications, 57(1–6), 233–243. doi:10.1080/00986448708960487\n\n\n\n\n\n","category":"type"},{"location":"eos/ideal/#Clapeyron.MonomerIdeal","page":"Ideal Models","title":"Clapeyron.MonomerIdeal","text":"MonomerIdeal <: MonomerIdealModel\nMonomerIdeal(components::Array{String,1}; \nuserlocations::Array{String,1}=String[], \nverbose=false)\n\nInput parameters\n\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\n\nModel Parameters\n\nNone\n\nDescription\n\nMonomer Ideal Model, result obtained from statistical mechanics Λ\n\n    Λᵢ = h/√(kᵦTMwᵢ/Nₐ)    \n    a₀ = A₀/nRT = ∑xᵢlog(ρᵢΛᵢ^3)\n\n\n\n\n\n","category":"type"},{"location":"eos/ideal/#Clapeyron.WalkerIdeal","page":"Ideal Models","title":"Clapeyron.WalkerIdeal","text":"WalkerIdeal <: WalkerIdealModel\nWalkerIdeal(components::Array{String,1}; \nuserlocations::Array{String,1}=String[], \nverbose=false)\n\nInput parameters\n\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nNrot: Single Parameter (Int)\ntheta1: Single Parameter (Float64)\ntheta2: Single Parameter (Float64)\ntheta3: Single Parameter (Float64)\ntheta4: Single Parameter (Float64)\ndeg1: Single Parameter (Int)\ndeg2: Single Parameter (Int)\ndeg3: Single Parameter (Int)\ndeg4: Single Parameter (Int)\n\nDescription\n\nWalker [1] Group Contribution Ideal Model.\n\nCpᵢ(T)/R = (5+NRot)/2 ∑νᵢₖ∑gₖᵥ(θₖᵥ/T)^2*exp(θₖᵥ/T)/(1-exp(θₖᵥ/T)) , v ∈ 1:4 \n\nReferences\n\nWalker, P. J., & Haslam, A. J. (2020). A new predictive group-contribution ideal-heat-capacity model and its influence on second-derivative properties calculated using a free-energy equation of state. Journal of Chemical and Engineering Data, 65(12), 5809–5829. doi:10.1021/acs.jced.0c00723\n\n\n\n\n\n","category":"type"},{"location":"eos/ideal/#Clapeyron.IAPWS95Ideal","page":"Ideal Models","title":"Clapeyron.IAPWS95Ideal","text":"IAPWS95Ideal <: IdealModel\nIAPWS95Ideal(components; \nuserlocations::Array{String,1}=String[], \nverbose=false)\n\nIAPWS95Ideal()\n\nInput parameters\n\nNone\n\nDescription\n\nIAPWS95 ideal helmholtz model for use in other models. Only valid for water. Check IAPWS95 for more information.\n\nReferences\n\nWagner, W., & Pruß, A. (2002). The IAPWS formulation 1995 for the thermodynamic properties of ordinary water substance for general and scientific use. Journal of physical and chemical reference data, 31(2), 387–535. doi:10.1063/1.1461829\nIAPWS R6-95 (2018). Revised Release on the IAPWS Formulation 1995 for the Thermodynamic Properties of Ordinary Water Substance for General and Scientific Use\n\n\n\n\n\n","category":"type"},{"location":"eos/ideal/#Clapeyron.LJRefIdeal","page":"Ideal Models","title":"Clapeyron.LJRefIdeal","text":"LJRefIdeal <: IdealModel\nLJRef(components;\nuserlocations=String[],\nverbose=false)\n\nInput parameters\n\nsigma: Single Parameter (Float64) - particle size [Å]\nepsilon: Single Parameter (Float64) - dispersion energy [K]\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\n\nDescription\n\nLennard-Jones Reference equation of state. Ideal Part. valid from 0.5 < T/Tc < 7 and pressures up to p/pc = 500.\n\nτᵢ = 1.32ϵᵢ/T\nδᵢ = n(Nₐσᵢ^3)/0.31V\na⁰ᵢ(δ,τ) = log(δᵢ) + 1.5log(τᵢ) + 1.515151515τᵢ + 6.262265814 \na⁰(δ,τ,z) = ∑xᵢ(a⁰ᵢ + log(xᵢ))\n\n\nLJRefIdeal acts as a wrapper of LJRef model, you can access it with LJRef(model::LJRefIdeal).\n\nwarning: Mutiple component warning\nThe original model was done with only one component in mind. to support multiple components, a VDW 1-fluid mixing rule (shown above) is implemented, but it is not tested.\n\nReferences\n\nThol, M., Rutkai, G., Köster, A., Lustig, R., Span, R., & Vrabec, J. (2016). Equation of state for the Lennard-Jones fluid. Journal of physical and chemical reference data, 45(2), 023101. doi:10.1063/1.4945000\n\n\n\n\n\n","category":"type"},{"location":"user_guide/custom_dtb/#Definitions","page":"Custom Databases","title":"Definitions","text":"","category":"section"},{"location":"user_guide/custom_dtb/","page":"Custom Databases","title":"Custom Databases","text":"Within Clapeyron, we use CSV files to store our parameters. There are four types of database files for different types of parameters:","category":"page"},{"location":"user_guide/custom_dtb/","page":"Custom Databases","title":"Custom Databases","text":"Like parameters: These CSV files have the structure:\nClapeyron Database File  \n{MODEL NAME} Like Parameters  \nspecies param1 param2\nwater 1234 5.678\nThese are used for parameters which only refer to a single species (such as the critical temperature, molar mass, like segment size, number of segments). These types of files are also used for the ideal model databases (since all of these are just for like species).\nUnlike parameters: These CSV files have the structure:\nClapeyron Database File  \n{MODEL NAME} Unlike Parameters  \nspecies1 species2 param\nwater methanol 0.910\nThese are used for parameters which refer to a pair of different species (such as the unlike interaction parameter k_ij).\nAssociation parameters: These CSV files have the structure:\nClapeyron Database File    \n{MODEL NAME} Assoc Parameters    \nspecies1 site1 species2 site2 param\nwater H water e 1.234\nwater H methanol e 5.678\nThese are used for parameters which refer to a pair of species and sites (such as the association potential depth, epsilon_assoc, and bonding volume, bondvol). Note that this can be for associations between the same species and different sites, or different species and different sites (as shown above).","category":"page"},{"location":"user_guide/custom_dtb/","page":"Custom Databases","title":"Custom Databases","text":"Note that it is extremely important that the cell A2 has the word 'Like', 'Unlike' or 'Assoc' in it so that Clapeyron can identify the type of parameters in it. Feel free to check these out in the package to see some better examples!","category":"page"},{"location":"user_guide/custom_dtb/#Using-your-own-parameters","page":"Custom Databases","title":"Using your own parameters","text":"","category":"section"},{"location":"user_guide/custom_dtb/","page":"Custom Databases","title":"Custom Databases","text":"If you have CSV files formatted as above with your own parameters, and you want to implement these into one of the existing equations of state in Clapeyron, all that is needed is to provide the path to those files in the definition of your model (note that ideal term related parameters are specified separately):","category":"page"},{"location":"user_guide/custom_dtb/","page":"Custom Databases","title":"Custom Databases","text":"model1 = PR([\"your_species_1\",\"your_species_2\"];userlocations=[\"path/to/your/database/\"], ideal_userlocations=[\"path/to/your/ideal_database\"])\nmodel2 = PCSAFT([\"your_species_1\",\"your_species_2\"];userlocations=[\"dtb_like\",\"dtb_unlike\",\"dtb_assoc\"],ideal_userlocations=[\"dtb_ideal\"])","category":"page"},{"location":"user_guide/custom_dtb/","page":"Custom Databases","title":"Custom Databases","text":"The rest works exactly as it normally would! We recommend reading the background documentation for the various models to ensure the units of the parameters you provide are correct.","category":"page"},{"location":"user_guide/custom_dtb/","page":"Custom Databases","title":"Custom Databases","text":"You can create those parameters without leaving the julia REPL, by using Clapeyron.ParamTable. this function will create a temporary location on where a CSV containing the table is created:","category":"page"},{"location":"user_guide/custom_dtb/","page":"Custom Databases","title":"Custom Databases","text":"data = (species = [\"water\"],Mw = [18.0])\nfile = ParamTable(:single,data,name=\"water_mw\")\nmodel = PR([\"water\"],user_locations = file)\nmodel.params.Mw.values[1] #18.0","category":"page"},{"location":"eos/saft/","page":"SAFT and CPA Models","title":"SAFT and CPA Models","text":"CurrentModule = Clapeyron","category":"page"},{"location":"eos/saft/#Index","page":"SAFT and CPA Models","title":"Index","text":"","category":"section"},{"location":"eos/saft/","page":"SAFT and CPA Models","title":"SAFT and CPA Models","text":"Pages = [\"saft.md\"]","category":"page"},{"location":"eos/saft/#SAFT-Models","page":"SAFT and CPA Models","title":"SAFT Models","text":"","category":"section"},{"location":"eos/saft/","page":"SAFT and CPA Models","title":"SAFT and CPA Models","text":"Clapeyron.ogSAFT\nClapeyron.CKSAFT\nClapeyron.sCKSAFT\nClapeyron.PCSAFT\nClapeyron.sPCSAFT\nClapeyron.pharmaPCSAFT\nClapeyron.softSAFT\nClapeyron.softSAFT2016\nClapeyron.SAFTVRSW\nClapeyron.SAFTVRMie\nClapeyron.SAFTgammaMie","category":"page"},{"location":"eos/saft/#Clapeyron.ogSAFT","page":"SAFT and CPA Models","title":"Clapeyron.ogSAFT","text":"ogSAFTModel <: SAFTModel\n\nogSAFT(components; \nidealmodel=BasicIdeal,\nuserlocations=String[],\nideal_userlocations=String[],\nverbose=false,\nassoc_options = AssocOptions())\n\nInput parameters\n\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nm: Single Parameter (Float64) - Number of segments (no units)\nsigma: Single Parameter (Float64) - Segment Diameter [A°]\nepsilon: Single Parameter (Float64) - Reduced dispersion energy  [K]\nk: Pair Parameter (Float64) - Binary Interaction Paramater (no units)\nepsilon_assoc: Association Parameter (Float64) - Reduced association energy [K]\nbondvol: Association Parameter (Float64) - Association Volume [m^3]\n\nModel Parameters\n\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nsegment: Single Parameter (Float64) - Number of segments (no units)\nsigma: Pair Parameter (Float64) - Mixed segment Diameter [m]\nepsilon: Pair Parameter (Float64) - Mixed reduced dispersion energy[K]\nepsilon_assoc: Association Parameter (Float64) - Reduced association energy [K]\nbondvol: Association Parameter (Float64) - Association Volume\n\nInput models\n\nidealmodel: Ideal Model\n\nDescription\n\n(original) Statistical Associating Fluid Theory (og-SAFT) Equation of State\n\nReferences\n\nChapman, W. G., Gubbins, K. E., Jackson, G., & Radosz, M. (1989). SAFT: Equation-of-state solution model for associating fluids. Fluid Phase Equilibria, 52, 31–38. doi:10.1016/0378-3812(89)80308-5\nChapman, W. G., Gubbins, K. E., Jackson, G., & Radosz, M. (1990). New reference equation of state for associating liquids. Industrial & Engineering Chemistry Research, 29(8), 1709–1721. doi:10.1021/ie00104a021\n\n\n\n\n\n","category":"type"},{"location":"eos/saft/#Clapeyron.CKSAFT","page":"SAFT and CPA Models","title":"Clapeyron.CKSAFT","text":"CKSAFTModel <: SAFTModel\n\nCKSAFT(components; \nidealmodel=BasicIdeal,\nuserlocations=String[],\nideal_userlocations=String[],\nverbose=false,\nassoc_options = AssocOptions())\n\nInput parameters\n\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nm: Single Parameter (Float64) - Number of segments (no units)\nvol: Single Parameter (Float64) - Segment Volume [dm^3]\nepsilon: Single Parameter (Float64) - Reduced dispersion energy  [K]\nk: Pair Parameter (Float64) - Binary Interaction Paramater (no units)\nc: Single Parameter (Float64) - Dispersion T-dependent parameter (no units)\nepsilon_assoc: Association Parameter (Float64) - Reduced association energy [K]\nbondvol: Association Parameter (Float64) - Association Volume [m^3]\n\nModel Parameters\n\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nsegment: Single Parameter (Float64) - Number of segments (no units)\nsigma: Pair Parameter (Float64) - Mixed segment Diameter [m]\nepsilon: Pair Parameter (Float64) - Mixed reduced dispersion energy[K]\nc: Single Parameter (Float64) - Dispersion T-dependent parameter (no units)\nepsilon_assoc: Association Parameter (Float64) - Reduced association energy [K]\nbondvol: Association Parameter (Float64) - Association Volume\n\nInput models\n\nidealmodel: Ideal Model\n\nDescription\n\nChen and Kreglewski SAFT (CK-SAFT)\n\nReferences\n\nHuang, S. H., & Radosz, M. (1990). Equation of state for small, large, polydisperse, and associating molecules. Industrial & Engineering Chemistry Research, 29(11), 2284–2294. doi:10.1021/ie00107a014\nHuang, S. H., & Radosz, M. (1991). Equation of state for small, large, polydisperse, and associating molecules: extension to fluid mixtures. Industrial & Engineering Chemistry Research, 30(8), 1994–2005. doi:10.1021/ie00056a050\n\n\n\n\n\n","category":"type"},{"location":"eos/saft/#Clapeyron.sCKSAFT","page":"SAFT and CPA Models","title":"Clapeyron.sCKSAFT","text":"sCKSAFTModel <: CKSAFTModel\n\nsCKSAFT(components; \nidealmodel=BasicIdeal,\nuserlocations=String[],\nideal_userlocations=String[],\nverbose=false,\nassoc_options = AssocOptions())\n\nInput parameters\n\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nm: Single Parameter (Float64) - Number of segments (no units)\nvol: Single Parameter (Float64) - Segment Volume [dm^3]\nepsilon: Single Parameter (Float64) - Reduced dispersion energy  [K]\nk: Pair Parameter (Float64) - Binary Interaction Paramater (no units)\nepsilon_assoc: Association Parameter (Float64) - Reduced association energy [K]\nbondvol: Association Parameter (Float64) - Association Volume [m^3]\n\nModel Parameters\n\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nsegment: Single Parameter (Float64) - Number of segments (no units)\nsigma: Pair Parameter (Float64) - Mixed segment Diameter [m]\nepsilon: Pair Parameter (Float64) - Mixed reduced dispersion energy[K]\nepsilon_assoc: Association Parameter (Float64) - Reduced association energy [K]\nbondvol: Association Parameter (Float64) - Association Volume\n\nInput models\n\nidealmodel: Ideal Model\n\nDescription\n\nSimplified Chen and Kreglewski SAFT (sCK-SAFT)\n\nReferences\n\nHuang, S. H., & Radosz, M. (1990). Equation of state for small, large, polydisperse, and associating molecules. Industrial & Engineering Chemistry Research, 29(11), 2284–2294. doi:10.1021/ie00107a014\nHuang, S. H., & Radosz, M. (1991). Equation of state for small, large, polydisperse, and associating molecules: extension to fluid mixtures. Industrial & Engineering Chemistry Research, 30(8), 1994–2005. doi:10.1021/ie00056a050\nFu, Y.-H., & Sandler, S. I. (1995). A simplified SAFT equation of state for associating compounds and mixtures. Industrial & Engineering Chemistry Research, 34(5), 1897–1909. doi:10.1021/ie00044a042\n\n\n\n\n\n","category":"type"},{"location":"eos/saft/#Clapeyron.PCSAFT","page":"SAFT and CPA Models","title":"Clapeyron.PCSAFT","text":"PCSAFTModel <: SAFTModel\n\nPCSAFT(components; \nidealmodel=BasicIdeal,\nuserlocations=String[],\nideal_userlocations=String[],\nverbose=false,\nassoc_options = AssocOptions())\n\nInput parameters\n\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nm: Single Parameter (Float64) - Number of segments (no units)\nsigma: Single Parameter (Float64) - Segment Diameter [A°]\nepsilon: Single Parameter (Float64) - Reduced dispersion energy  [K]\nk: Pair Parameter (Float64) - Binary Interaction Paramater (no units)\nepsilon_assoc: Association Parameter (Float64) - Reduced association energy [K]\nbondvol: Association Parameter (Float64) - Association Volume [m^3]\n\nModel Parameters\n\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nsegment: Single Parameter (Float64) - Number of segments (no units)\nsigma: Pair Parameter (Float64) - Mixed segment Diameter [m]\nepsilon: Pair Parameter (Float64) - Mixed reduced dispersion energy[K]\nepsilon_assoc: Association Parameter (Float64) - Reduced association energy [K]\nbondvol: Association Parameter (Float64) - Association Volume\n\nInput models\n\nidealmodel: Ideal Model\n\nDescription\n\nPerturbed-Chain SAFT (PC-SAFT)\n\nReferences\n\nGross, J., & Sadowski, G. (2001). Perturbed-chain SAFT: An equation of state based on a perturbation theory for chain molecules. Industrial & Engineering Chemistry Research, 40(4), 1244–1260. doi:10.1021/ie0003887\nGross, J., & Sadowski, G. (2002). Application of the perturbed-chain SAFT equation of state to associating systems. Industrial & Engineering Chemistry Research, 41(22), 5510–5515. doi:10.1021/ie010954d\n\n\n\n\n\n","category":"type"},{"location":"eos/saft/#Clapeyron.sPCSAFT","page":"SAFT and CPA Models","title":"Clapeyron.sPCSAFT","text":"sPCSAFT <: PCSAFTModel\n\nsPCSAFT(components; \nidealmodel=BasicIdeal,\nuserlocations=String[],\nideal_userlocations=String[],\nverbose=false,\nassoc_options = AssocOptions())\n\nInput parameters\n\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nm: Single Parameter (Float64) - Number of segments (no units)\nsigma: Single Parameter (Float64) - Segment Diameter [A°]\nepsilon: Single Parameter (Float64) - Reduced dispersion energy  [K]\nk: Pair Parameter (Float64) - Binary Interaction Paramater (no units)\nepsilon_assoc: Association Parameter (Float64) - Reduced association energy [K]\nbondvol: Association Parameter (Float64) - Association Volume [m^3]\n\nModel Parameters\n\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nsegment: Single Parameter (Float64) - Number of segments (no units)\nsigma: Pair Parameter (Float64) - Mixed segment Diameter [m]\nepsilon: Pair Parameter (Float64) - Mixed reduced dispersion energy[K]\nepsilon_assoc: Association Parameter (Float64) - Reduced association energy [K]\nbondvol: Association Parameter (Float64) - Association Volume\n\nInput models\n\nidealmodel: Ideal Model\n\nDescription\n\nSimplified Perturbed-Chain SAFT (sPC-SAFT)\n\nReferences\n\nvon Solms, N., Michelsen, M. L., & Kontogeorgis, G. M. (2003). Computational and physical performance of a modified PC-SAFT equation of state for highly asymmetric and associating mixtures. Industrial & Engineering Chemistry Research, 42(5), 1098–1105. doi:10.1021/ie020753p\n\n\n\n\n\n","category":"type"},{"location":"eos/saft/#Clapeyron.pharmaPCSAFT","page":"SAFT and CPA Models","title":"Clapeyron.pharmaPCSAFT","text":"pharmaPCSAFTModel <: PCSAFTModel\n\npharmaPCSAFT(components; \nidealmodel=BasicIdeal,\nuserlocations=String[],\nideal_userlocations=String[],\nverbose=false,\nassoc_options = AssocOptions())\n\nInput parameters\n\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nm: Single Parameter (Float64) - Number of segments (no units)\nsigma: Single Parameter (Float64) - Segment Diameter [A°]\nepsilon: Single Parameter (Float64) - Reduced dispersion energy  [K]\nk: Pair Parameter (Float64) - Constant binary Interaction Paramater (no units)\nkT: Pair Parameter (Float64) - T-dependent inary Interaction Paramater [K^-1]\nepsilon_assoc: Association Parameter (Float64) - Reduced association energy [K]\nbondvol: Association Parameter (Float64) - Association Volume [m^3]\n\nModel Parameters\n\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nsegment: Single Parameter (Float64) - Number of segments (no units)\nsigma: Pair Parameter (Float64) - Mixed segment Diameter [m]\nepsilon: Pair Parameter (Float64) - Mixed reduced dispersion energy[K]\nk: Pair Parameter (Float64) - Constant binary Interaction Paramater (no units)\nkT: Pair Parameter (Float64) - T-dependent inary Interaction Paramater [K^-1]\nepsilon_assoc: Association Parameter (Float64) - Reduced association energy [K]\nbondvol: Association Parameter (Float64) - Association Volume\n\nInput models\n\nidealmodel: Ideal Model\n\nDescription\n\nPerturbed-Chain SAFT (PC-SAFT), with T dependent kij and water correlation [2] for segment diameter. For using the water's sigma correlation, water08 should be selected instead of water.\n\nReferences\n\nPaus, R., Ji, Y., Vahle, L., & Sadowski, G. (2015). Predicting the solubility advantage of amorphous pharmaceuticals: A novel thermodynamic approach. Molecular Pharmaceutics, 12(8), 2823–2833. doi:10.1021/mp500824d\nCameretti, L. F., & Sadowski, G. (2008). Modeling of aqueous amino acid and polypeptide solutions with PC-SAFT. Genie Des Procedes [Chemical Engineering and Processing], 47(6), 1018–1025. doi:10.1016/j.cep.2007.02.034\n\n\n\n\n\n","category":"type"},{"location":"eos/saft/#Clapeyron.softSAFT","page":"SAFT and CPA Models","title":"Clapeyron.softSAFT","text":"softSAFTModel <: SAFTModel\n\nsoftSAFT(components; \nidealmodel=BasicIdeal,\nuserlocations=String[],\nideal_userlocations=String[],\nverbose=false,\nassoc_options = AssocOptions())\n\nInput parameters\n\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nm: Single Parameter (Float64) - Number of segments (no units)\nsigma: Single Parameter (Float64) - Segment Diameter [A°]\nepsilon: Single Parameter (Float64) - Reduced dispersion energy  [K]\nk: Pair Parameter (Float64) - Binary Interaction Paramater (no units)\nepsilon_assoc: Association Parameter (Float64) - Reduced association energy [K]\nbondvol: Association Parameter (Float64) - Association Volume [m^3]\n\nModel Parameters\n\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nsegment: Single Parameter (Float64) - Number of segments (no units)\nsigma: Pair Parameter (Float64) - Mixed segment Diameter [m]\nepsilon: Pair Parameter (Float64) - Mixed reduced dispersion energy[K]\nepsilon_assoc: Association Parameter (Float64) - Reduced association energy [K]\nbondvol: Association Parameter (Float64) - Association Volume\n\nInput models\n\nidealmodel: Ideal Model\n\nDescription\n\nSoft SAFT, with Lennard-Jones function from Johnson et al. (1993)\n\nReferences\n\nJohnson, J. K., Zollweg, J. A., & Gubbins, K. E. (1993). The Lennard-Jones equation of state revisited. Molecular physics, 78(3), 591–618. doi:10.1080/00268979300100411\nFELIPE J. BLAS and LOURDES F. VEGA. (1997). Thermodynamic behaviour of homonuclear and heteronuclear Lennard-Jones chains with association sites from simulation and theory. Molecular physics, 92(1), 135–150. doi:10.1080/002689797170707\n\n\n\n\n\n","category":"type"},{"location":"eos/saft/#Clapeyron.SAFTVRSW","page":"SAFT and CPA Models","title":"Clapeyron.SAFTVRSW","text":"SAFTVRSWModel <: SAFTModel\n\nSAFTVRSW(components; \nidealmodel=BasicIdeal,\nuserlocations=String[],\nideal_userlocations=String[],\nverbose=false,\nassoc_options = AssocOptions())\n\nInput parameters\n\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nm: Single Parameter (Float64) - Number of segments (no units)\nsigma: Single Parameter (Float64) - Segment Diameter [A°]\nepsilon: Single Parameter (Float64) - Reduced dispersion energy  [K]\nlambda: Single Parameter (Float64) - Soft Well range parameter (no units)\nk: Pair Parameter (Float64) - Binary Interaction Paramater (no units)\nepsilon_assoc: Association Parameter (Float64) - Reduced association energy [K]\nbondvol: Association Parameter (Float64) - Association Volume [m^3]\n\nModel Parameters\n\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nsegment: Single Parameter (Float64) - Number of segments (no units)\nsigma: Pair Parameter (Float64) - Mixed segment Diameter [m]\nlambda: Pair Parameter (Float64) - Mixed Soft Well range parameter (no units)\nepsilon: Pair Parameter (Float64) - Mixed reduced dispersion energy[K]\nepsilon_assoc: Association Parameter (Float64) - Reduced association energy [K]\nbondvol: Association Parameter (Float64) - Association Volume\n\nInput models\n\nidealmodel: Ideal Model\n\nDescription\n\nSAFT, Variable Range (VR) ,Square Well (SW)\n\nReferences\n\nGil-Villegas, A., Galindo, A., Whitehead, P. J., Mills, S. J., Jackson, G., & Burgess, A. N. (1997). Statistical associating fluid theory for chain molecules with attractive potentials of variable range. The Journal of chemical physics, 106(10), 4168–4186. doi:10.1063/1.473101\n\n\n\n\n\n","category":"type"},{"location":"eos/saft/#Clapeyron.SAFTVRMie","page":"SAFT and CPA Models","title":"Clapeyron.SAFTVRMie","text":"SAFTVRMieModel <: SAFTModel\n\nSAFTVRMie(components; \nidealmodel=BasicIdeal,\nuserlocations=String[],\nideal_userlocations=String[],\nverbose=false,\nassoc_options = AssocOptions())\n\nInput parameters\n\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nm: Single Parameter (Float64) - Number of segments (no units)\nsigma: Single Parameter (Float64) - Segment Diameter [A°]\nepsilon: Single Parameter (Float64) - Reduced dispersion energy  [K]\nlambda_a: Pair Parameter (Float64) - Atractive range parameter (no units)\nlambda_r: Pair Parameter (Float64) - Repulsive range parameter (no units)\nk: Pair Parameter (Float64) - Binary Interaction Paramater (no units)\nepsilon_assoc: Association Parameter (Float64) - Reduced association energy [K]\nbondvol: Association Parameter (Float64) - Association Volume\n\nModel Parameters\n\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nsegment: Single Parameter (Float64) - Number of segments (no units)\nsigma: Pair Parameter (Float64) - Mixed segment Diameter [m]\nlambda_a: Pair Parameter (Float64) - Atractive range parameter (no units)\nlambda_r: Pair Parameter (Float64) - Repulsive range parameter (no units)\nepsilon: Pair Parameter (Float64) - Mixed reduced dispersion energy[K]\nepsilon_assoc: Association Parameter (Float64) - Reduced association energy [K]\nbondvol: Association Parameter (Float64) - Association Volume\n\nInput models\n\nidealmodel: Ideal Model\n\nDescription\n\nSAFT-VR with Mie potential\n\nReferences\n\nLafitte, T., Apostolakou, A., Avendaño, C., Galindo, A., Adjiman, C. S., Müller, E. A., & Jackson, G. (2013). Accurate statistical associating fluid theory for chain molecules formed from Mie segments. The Journal of Chemical Physics, 139(15), 154504. doi:10.1063/1.4819786\nDufal, S., Lafitte, T., Haslam, A. J., Galindo, A., Clark, G. N. I., Vega, C., & Jackson, G. (2015). The A in SAFT: developing the contribution of association to the Helmholtz free energy within a Wertheim TPT1 treatment of generic Mie fluids. Molecular Physics, 113(9–10), 948–984. doi:10.1080/00268976.2015.1029027\n\n\n\n\n\n","category":"type"},{"location":"eos/saft/#Clapeyron.SAFTgammaMie","page":"SAFT and CPA Models","title":"Clapeyron.SAFTgammaMie","text":"SAFTVRSWModel <: SAFTModel\n\nSAFTVRSW(components; \nidealmodel=BasicIdeal,\nuserlocations=String[],\nideal_userlocations=String[],\nverbose=false,\nassoc_options = AssocOptions())\n\nInput parameters\n\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nm: Single Parameter (Float64) - Number of segments (no units)\nshapefactor: Single Parameter (Float64) - Shape factor for segment (no units)\nsigma: Single Parameter (Float64) - Segment Diameter [A°]\nepsilon: Single Parameter (Float64) - Reduced dispersion energy  [K]\nlambda_a: Pair Parameter (Float64) - Atractive range parameter (no units)\nlambda_r: Pair Parameter (Float64) - Repulsive range parameter (no units)\nepsilon_assoc: Association Parameter (Float64) - Reduced association energy [K]\nbondvol: Association Parameter (Float64) - Association Volume\n\nModel Parameters\n\nsegment: Single Parameter (Float64) - Number of segments (no units)\nshapefactor: Single Parameter (Float64) - Shape factor for segment (no units)\nsigma: Pair Parameter (Float64) - Mixed segment Diameter [m]\nlambda_a: Pair Parameter (Float64) - Atractive range parameter (no units)\nlambda_r: Pair Parameter (Float64) - Repulsive range parameter (no units)\nepsilon: Pair Parameter (Float64) - Mixed reduced dispersion energy[K]\nepsilon_assoc: Association Parameter (Float64) - Reduced association energy [K]\nbondvol: Association Parameter (Float64) - Association Volume\n\nInput models\n\nidealmodel: Ideal Model\n\nDescription\n\nSAFT-γ-Mie EoS\n\nReferences\n\nPapaioannou, V., Lafitte, T., Avendaño, C., Adjiman, C. S., Jackson, G., Müller, E. A., & Galindo, A. (2014). Group contribution methodology based on the statistical associating fluid theory for heteronuclear molecules formed from Mie segments. The Journal of Chemical Physics, 140(5), 054107. doi:10.1063/1.4851455\nDufal, S., Papaioannou, V., Sadeqzadeh, M., Pogiatzis, T., Chremos, A., Adjiman, C. S., … Galindo, A. (2014). Prediction of thermodynamic properties and phase behavior of fluids and mixtures with the SAFT-γ Mie group-contribution equation of state. Journal of Chemical and Engineering Data, 59(10), 3272–3288. doi:10.1021/je500248h\n\n\n\n\n\n","category":"type"},{"location":"eos/saft/","page":"SAFT and CPA Models","title":"SAFT and CPA Models","text":"#CPA Models","category":"page"},{"location":"user_guide/custom_model/#Definitions","page":"Custom Models","title":"Definitions","text":"","category":"section"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"Within Clapeyron, it is possible to create your own model/equation of state whilst still using all of the property estimation tools we provide. In order to do this, you must create the model. We provide a macro to make it easy to set it up. If you wish to create a new model called CustomEoS, you just need call the @newmodel macro with three parameters:","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"@newmodel CustomEoS CustomEosModel CustomEosParam","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"Model struct name\nModel abstract type\nModel parameters struct","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"We will now give a brief overview of each of these aspects.","category":"page"},{"location":"user_guide/custom_model/#Model-struct-name","page":"Custom Models","title":"Model struct name","text":"","category":"section"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"This is the concrete type, which is simply the name of the equation of state which will be used to generate the model. Within Clapeyron, we've tried to keep these names as obvious as possible (e.g. vdW, PR, PCSAFT, SAFTVRMie, GERG2008, etc.). For your own model, this can be whatever you want as long is the identification makes sense to you.","category":"page"},{"location":"user_guide/custom_model/#Model-abstract-type","page":"Custom Models","title":"Model abstract type","text":"","category":"section"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"In Julia, objects can only be sub-types of abstract types (and not concrete types), which will allow you to inherit the behaviour of the parent(s). In order to maintain a hierarchy of models, we highly encourage you to create an abstract type for your model that is a subtype one of these families of EoS, and dispatch on this newly created abstract type instead of on your model's concrete type. This is not enforced, but we suffix all abstract types in this category with Model as a convention. The abstract type that is at the top of the hierarchy is EoSModel. From this parent, we branch into more-specific EoS sub-types:","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"SAFTModel: These are the models which have three parameters in common: segment size, sigma, potential depth, epsilon, and number of segments, m. All other SAFT-type models branch from this parent (PCSAFTModel, SAFTVRMieModel, softSAFTModel, etc.). \nCubicModel: These are the models whose parameters can be obtained from the critical temperature and pressure. With the exception of CPAModel, all cubics have a common structure where one can re-arrange the equation for the pressure as a third-order polynomial. As such, we define a subtype of CubicModel, ABCubicModel (e.g. vdWModel, RKModel, SRKModel, PRModel).\nEmpiricHelmholtzModel: These are the high-accuracy, multi-parameter models for specific species or systems (e.g. GERG2008Model, IAPWS95Model). There is no general structure to the models and they are treated as self-contained.\nIdealModel: Often overlooked, these models supplement the SAFTModel and CubicModel by providing the ideal contribution. Whilst the parameters and structure aren't usually the same between ideal models, this is unnecessary as the equation for the pressure is always pV=Nk_mathrmBT . ","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"For example, if we wish to create a new EoS model called CustomEoS, we will create an abstract type CustomEoSModel, that is a sub-type of another abstract type, say CubicModel (but it could also inherit from something further down the hierarchy, like vdWModel):","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"abstract type CustomEoSModel <: CubicModel end","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"For models that are sub-types of SAFTModel or CubicModel, most methods will be instantly compatible because methods will be able to make use of a set of the EoS parameters for finding the initial guesses. If your model is not of either of these types, it will be necessary to define a few additional functions:","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"lb_volume(model::CustomEoSModel,T,z): This must output the smallest possible value of the volume for your particular model using the model parameters. In SAFT equations, this is equivalent to a packing fraction of one (eta=1) whilst in cubics, it is equivalent to the b parameter.\nT_scale(model::CustomEoSModel,z): This must output the temperature scaling for your model using the model parameters. In SAFT equations, this is usually the potential depth whilst in cubics it is the critical temperature.\np_scale(model::CustomEoSModel,z): This must output the pressure scaling for your model using the model parameters. In cubics, this is the critical pressure whilst in SAFT we use a more complicated definition using the segment sizes and potential depths.","category":"page"},{"location":"user_guide/custom_model/#Model-parameters-struct","page":"Custom Models","title":"Model parameters struct","text":"","category":"section"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"The parameters for a particular system are all stored within a struct that is a subtype of EoSParam. By convention, we suffix these with Param. These structs should contain the model parameters, which comprise objects of types SingleParam{T}, PairParam{T}, and AssocParam{T}, where T is usually a base type (Float64, Integer, String, etc). Below is an example of a generic param struct for a SAFT and cubic model.","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"struct GenericSAFTParam <: EoSParam\n    Mw::SingleParam{Float64}\n    segment::SingleParam{Float64}\n    sigma::PairParam{Float64}\n    epsilon::PairParam{Float64}\n    epsilon_assoc::AssocParam{Float64}\n    bondvol::AssocParam{Float64}\nend","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"struct GenericCubicParam <: EoSParam\n    Tc::SingleParam{Float64}\n    pc::SingleParam{Float64}\n    Mw::SingleParam{Float64}\n    a::PairParam{Float64}\n    b::PairParam{Float64}\nend","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"The parameters are wrapped in one of the following structs:","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"SingleParam{T}: These are the parameters associated with a pure species or indexed by a single index (i). For example, the molecular weight, number of segments, critical temperature and pressure.\nPairParam{T}: These are the parameters associated with a pair of species or indexed by two indices (i and j). If the two indices are the same (i=j), they refer to the like species, otherwise (ineq j), they refer to the unlike species. For example, the cubic a and b parameters, the SAFT segment size (sigma) and potential depth (epsilon) parameters.\nAssocParam{T}: There are the parameters associated with both a pair of species and association sites (see background documentation for what these are). They are indexed by four indices (the species i and j, and the sites a and b). For example, potential depth of the association interaction (epsilon_assoc) and the bonding volume (bondvol).","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"If there exists a model parameter struct that contains exactly the same parameters as the one that you are about to create, you can also directly use that existing struct.","category":"page"},{"location":"user_guide/custom_model/#PC-SAFT-Example","page":"Custom Models","title":"PC-SAFT Example","text":"","category":"section"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"Once all the above has been defined, we are ready to build our own model. Let us imagine we are trying to implement PCSAFT. ","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"We first define the Model name, type and parameters:","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"# Defining an abstract type for this model type\nabstract type PCSAFTModel <: SAFTModel end\n\n# Defining the parameters used by the model\nstruct PCSAFTParam <: EoSParam\n    Mw::SingleParam{Float64}\n    segment::SingleParam{Float64}\n    sigma::PairParam{Float64}\n    epsilon::PairParam{Float64}\n    epsilon_assoc::AssocParam{Float64}\n    bondvol::AssocParam{Float64}\nend\n\n# Creating a model struct called PCSAFT, which is a sub-type of PCSAFTModel, and uses parameters defined in PCSAFTParam\n@newmodel PCSAFT PCSAFTModel PCSAFTParam","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"The next step is to create an outer constructor for the model that you have just defined. It should have the same name as the struct above. It can take the following arguments, although these can be hard-coded if you so wish:\ncomponents: A list of strings that identify the components.\nidealmodel: An ideal model, but this can be left as an optional parameter.\nuserlocations: A list of strings that are paths to the databases that you are using.\nideal_userlocations: Same as above, but for ideal models.\nverbose: For when you want to print more information to the console.\nassoc_options: For use in the association sites solver.","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"function PCSAFT(components; idealmodel=BasicIdeal, userlocations=String[], ideal_userlocations=String[], verbose=false,assoc_options = AssocOptions())\n  \t# Obtain a Dict of parameters. We pass in custom locations through the optional parameter userlocations.\n    params = getparams(components; userlocations=userlocations, verbose=verbose)\n  \n    # For clarity, we assign the contents of the returned dict to their own variables.\n    segment = params[\"m\"]\n    k = params[\"k\"]\n    Mw = params[\"Mw\"]\n    # Here, we modify the values of the sigma parameter first.\n    params[\"sigma\"].values .*= 1E-10\n  \n    # In some cases, we may not have the unlike parameters and will need to use combining rules. You can also define your own combining rules for this.\n    sigma = sigma_LorentzBerthelot(params[\"sigma\"])\n    epsilon = epsilon_LorentzBerthelot(params[\"epsilon\"], k)\n  \n    epsilon_assoc = params[\"epsilon_assoc\"]\n    bondvol = params[\"bondvol\"]\n  \n    # Build the sites object for associating species. The input is a Dict that links the name of the site with the multiplicity.\n    sites = SiteParam(Dict(\"e\" => params[\"n_e\"], \"H\" => params[\"n_H\"]))\n  \n    # Now we can create the parameter struct that we have defined.\n    packagedparams = PCSAFTParam(Mw, segment, sigma, epsilon, epsilon_assoc, bondvol)\n  \n    # Although optional, it's generally good practise to cite your models!\n    references = [\"10.1021/ie0003887\", \"10.1021/ie010954d\"]\n\n    # Build the model.\n    model = PCSAFT(packagedparams, sites, idealmodel; ideal_userlocations=ideal_userlocations, references=references, verbose=verbose,assoc_options = assoc_options)\n  \n    # Return the PCSAFT object that you have just created.\n    return model\nend","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"Define all of the model equations. We encourage you to use the full range of Unicode characters where it makes your code clearer to read!\nAs convention, the first four arguments should be model, V, T and z; any other variables should come after them.\nIf we obey that convention, we may use the @f macro, which automatically substitutes the first four parameters for compactness. For example, @f(func,i,j) is equivalent to calling func(model,V,T,z,i,j).\nfunction a_res(model::PCSAFTModel, V, T, z)\n    return @f(a_hc) + @f(a_disp) + @f(a_assoc)\nend\n\nfunction a_hc(model::PCSAFTModel, V, T, z)\n    x = z/∑(z)\n    m = model.params.segment.values\n    m̄ = ∑(x .* m)\n    return m̄*@f(a_hs) - ∑(x[i]*(m[i]-1)*log(@f(g_hs,i,i)) for i ∈ @comps)\nend\n\nfunction d(model::PCSAFTModel, V, T, z, i)\n    ϵii = model.params.epsilon.diagvalues[i]\n    σii = model.params.sigma.diagvalues[i]\n    return σii * (1 - 0.12exp(-3ϵii/T))\nend\n\nfunction ζ(model::PCSAFTModel, V, T, z, n)\n    ∑z = ∑(z)\n    x = z * (one(∑z)/∑z)\n    m = model.params.segment.values\n    res = N_A*∑z*π/6/V * ∑((x[i]*m[i]*@f(d,i)^n for i ∈ @comps))\nend\n\nfunction g_hs(model::PCSAFTModel, V, T, z, i, j)\n    di = @f(d,i)\n    dj = @f(d,j)\n    ζ2 = @f(ζ,2)\n    ζ3 = @f(ζ,3)\n    return 1/(1-ζ3) + di*dj/(di+dj)*3ζ2/(1-ζ3)^2 + (di*dj/(di+dj))^2*2ζ2^2/(1-ζ3)^3\nend\n\nfunction a_hs(model::PCSAFTModel, V, T, z)\n    ζ0 = @f(ζ,0)\n    ζ1 = @f(ζ,1)\n    ζ2 = @f(ζ,2)\n    ζ3 = @f(ζ,3)\n    return 1/ζ0 * (3ζ1*ζ2/(1-ζ3) + ζ2^3/(ζ3*(1-ζ3)^2) + (ζ2^3/ζ3^2-ζ0)*log(1-ζ3))\nend\n\n# INSERT REST OF CODE\nWith all the above defined in a single script, we can save the file as PCSAFT.jl and then include it in our jupyter notebooks (for example) and use the model with all of our existing method:\ninclude(\"PCSAFT.jl\")\n\nmodel = PCSAFT([\"carbon dioxide\"])\n\np = 20e6\nT = range(290,460,length=200)\n\nCp = isobaric_heat_capacity.(model, p, T)\n\n(T_c, p_c, V_c) = crit_pure(model)\n\nT_sat = range(220,T_c,length=200)\n\n(p_sat, V_l_sat, V_v_sat) = saturation_pressure(model,T_sat)","category":"page"},{"location":"user_guide/custom_model/#sPC-SAFT-Example","page":"Custom Models","title":"sPC-SAFT Example","text":"","category":"section"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"Instead of developing an entirely new model, some of us may want to modify or extend an existing one. sPCSAFT is an example where we want to modify parts of regular PCSAFT but keep the rest the same. We can do this in a very succinct way making this new model a sub-type of the abstract type associated with another model.","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"When we define the model type, sPCSAFT is a sub-type of PCSAFT:\nabstract type sPCSAFTModel <: PCSAFTModel end\nSince the parameters are the same, we can just use the same model params when creating the model:\n@newmodel sPCSAFT sPCSAFTModel PCSAFTParam\nThis may not be the case if we're extending a model (e.g. if we're adding polar or ionic terms, we may need to define a new parameter struct to include the new parameters).\nWhen defining the model equations, we only need to write those that have been changed in sPCSAFT:\nfunction a_hc(model::sPCSAFTModel, V, T, z)\n    x = z/sum(z)\n    m = model.params.segment.values\n    m̄ = ∑(x .* m)\n    return m̄*@f(a_hs) - (m̄-1)*log(@f(g_hs))\nend\n\nfunction g_hs(model::sPCSAFTModel, V, T, z)\n    η = @f(ζ,3)\n    return (1-η/2)/(1-η)^3\nend\n\nfunction a_hs(model::sPCSAFTModel, V, T, z)\n    η = @f(ζ,3)\n    return (4η-3η^2)/(1-η)^2\nend","category":"page"},{"location":"user_guide/custom_model/","page":"Custom Models","title":"Custom Models","text":"The rest works exactly as it would with the PCSAFT example.","category":"page"},{"location":"eos/activity/","page":"Activity Models","title":"Activity Models","text":"CurrentModule = Clapeyron","category":"page"},{"location":"eos/activity/#Index","page":"Activity Models","title":"Index","text":"","category":"section"},{"location":"eos/activity/","page":"Activity Models","title":"Activity Models","text":"Pages = [\"activity.md\"]","category":"page"},{"location":"eos/activity/#Activity-Models","page":"Activity Models","title":"Activity Models","text":"","category":"section"},{"location":"eos/activity/","page":"Activity Models","title":"Activity Models","text":"There are two alternatives on the definition of an activity model:","category":"page"},{"location":"eos/activity/","page":"Activity Models","title":"Activity Models","text":"Defining an excess gibbs energy function\nDefining an activity coefficient function","category":"page"},{"location":"eos/activity/","page":"Activity Models","title":"Activity Models","text":"those two can be converted between one form to another via:","category":"page"},{"location":"eos/activity/","page":"Activity Models","title":"Activity Models","text":"gamma_i = fracpartialG^Epartialn_i","category":"page"},{"location":"eos/activity/","page":"Activity Models","title":"Activity Models","text":"lngamma_i = frac1RTfracpartialG^Epartialn_i","category":"page"},{"location":"eos/activity/","page":"Activity Models","title":"Activity Models","text":"When defining one form, the other is derived automatically.","category":"page"},{"location":"eos/activity/","page":"Activity Models","title":"Activity Models","text":"Those functions can also be derived from any arbitrary equation of state:","category":"page"},{"location":"eos/activity/","page":"Activity Models","title":"Activity Models","text":"fracpartialG^Epartialn_i= mu_i - mu^0_i","category":"page"},{"location":"eos/activity/","page":"Activity Models","title":"Activity Models","text":"Where mu_i and mu^0_i are the mixture and pure chemical potentials of component i. in this case, those potentials are dependent of the pressure. whereas activity models are usually only temperature and composition dependent.","category":"page"},{"location":"eos/activity/","page":"Activity Models","title":"Activity Models","text":"Clapeyron.Wilson\nClapeyron.NRTL\nClapeyron.UNIQUAC\nClapeyron.ogUNIFAC\nClapeyron.UNIFAC\nClapeyron.PSRKUNIFAC\nClapeyron.VTPRUNIFAC","category":"page"},{"location":"eos/activity/#Clapeyron.Wilson","page":"Activity Models","title":"Clapeyron.Wilson","text":"Wilson <: ActivityModel\n\nWilson(components::Vector{String};\npuremodel = PR,\nuserlocations = String[], \npure_userlocations = String[],\nverbose = false)\n\nInput parameters\n\nTc: Single Parameter (Float64) - Critical Temperature [K]\nPc: Single Parameter (Float64) - Critical Pressure [Pa]\nZRA: Single Parameter (Float64) - Rackett Compresibility factor\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\ng: Pair Parameter (Float64, asymetrical, defaults to 0) - Interaction Parameter\n\nInput models\n\npuremodel: model to calculate pure pressure-dependent properties\n\nDescription\n\nWilson activity model, with Rackett correlation for liquid volume:\n\nGᴱ = nRT∑xᵢlog(∑xⱼjΛᵢⱼ)\nΛᵢⱼ = exp(-gᵢⱼ/T)*Vⱼ/Vᵢ\nVᵢ = (RTcᵢ/Pcᵢ)(0.29056 - 0.08775ZRAᵢ)^(1 + (1-T/Tcᵢ)^2/7)\n\nReferences\n\nWilson, G. M. (1964). Vapor-liquid equilibrium. XI. A new expression for the excess free energy of mixing. Journal of the American Chemical Society, 86(2), 127–130. doi:10.1021/ja01056a002\n\n\n\n\n\n","category":"type"},{"location":"eos/activity/#Clapeyron.NRTL","page":"Activity Models","title":"Clapeyron.NRTL","text":"NRTL <: ActivityModel\n\nfunction NRTL(components::Vector{String};\npuremodel=PR,\nuserlocations=String[],\npure_userlocations = String[],\nverbose=false)\n\nInput parameters\n\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\na: Pair Parameter (Float64, asymetrical, defaults to 0) - Interaction Parameter\nb: Pair Parameter (Float64, asymetrical, defaults to 0) - Interaction Parameter\nc: Pair Parameter (Float64, asymetrical, defaults to 0) - Interaction Parameter\n\nInput models\n\npuremodel: model to calculate pure pressure-dependent properties\n\nDescription\n\nNRTL (Non Random Two Fluid) activity model:\n\nGᴱ = nRT∑[xᵢ(∑τⱼᵢGⱼᵢxⱼ)/(∑Gⱼᵢxⱼ)]\nGᵢⱼ exp(-cᵢⱼτᵢⱼ)\nτᵢⱼ = aᵢⱼ + bᵢⱼ/T\n\nReferences\n\nRenon, H., & Prausnitz, J. M. (1968). Local compositions in thermodynamic excess functions for liquid mixtures. AIChE journal. American Institute of Chemical Engineers, 14(1), 135–144. doi:10.1002/aic.690140124\n\n\n\n\n\n","category":"type"},{"location":"eos/activity/#Clapeyron.UNIQUAC","page":"Activity Models","title":"Clapeyron.UNIQUAC","text":"UNIQUACModel <: ActivityModel\n\nUNIQUAC(components::Vector{String};\npuremodel = PR,\nuserlocations = String[], \npure_userlocations = String[],\nverbose = false)\n\nInput parameters\n\na: Pair Parameter (Float64, asymetrical, defaults to 0) - Binary Interaction Energy Parameter\nr: Single Parameter (Float64)  - Normalized Van der Vals volume\nq: Single Parameter (Float64) - Normalized Surface Area\nq_p: Single Parameter (Float64) - Modified Normalized Surface Area \nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\n\nInput models\n\npuremodel: model to calculate pure pressure-dependent properties\n\nUNIQUAC (Universal QuasiChemical Activity Coefficients) activity model:\n\nGᴱ = nRT(gᴱ(comb) + gᴱ(res))\ngᴱ(comb) = ∑[xᵢlog(Φᵢ/xᵢ) + 5qᵢxᵢlog(θᵢ/Φᵢ)]\ngᴱ(res) = -∑xᵢqᵖᵢlog(∑θᵖⱼτⱼᵢ)\nθᵢ = qᵢxᵢ/∑qᵢxᵢ\nθᵖ = qᵖᵢxᵢ/∑qᵖᵢxᵢ\nΦᵢ = rᵢxᵢ/∑rᵢxᵢ\nτᵢⱼ = exp(-aᵢⱼ/T)\n\nReferences\n\nAbrams, D. S., & Prausnitz, J. M. (1975). Statistical thermodynamics of liquid mixtures: A new expression for the excess Gibbs energy of partly or completely miscible systems. AIChE journal. American Institute of Chemical Engineers, 21(1), 116–128. doi:10.1002/aic.690210115\n\n\n\n\n\n","category":"type"},{"location":"eos/activity/#Clapeyron.ogUNIFAC","page":"Activity Models","title":"Clapeyron.ogUNIFAC","text":"ogUNIFACModel <: UNIFACModel\n\nogUNIFAC(components::Vector{String};\npuremodel = PR, \nuserlocations = String[],\npure_userlocations = String[],\nverbose = false)\n\nInput parameters\n\nR: Single Parameter (Float64)  - Normalized group Van der Vals volume\nQ: Single Parameter (Float64) - Normalized group Surface Area\nA: Pair Parameter (Float64, asymetrical, defaults to 0) - Binary group Interaction Energy Parameter\n\nInput models\n\npuremodel: model to calculate pure pressure-dependent properties\n\nUNIFAC (UNIQUAC Functional-group Activity Coefficients) activity model.\n\nOriginal formulation.\n\nThe Combinatorial part corresponds to an GC-averaged modified UNIQUAC model. The residual part iterates over groups instead of components.\n\nGᴱ = nRT(gᴱ(comb) + gᴱ(res))\n\nCombinatorial part:\n\ngᴱ(comb) = ∑[xᵢlog(Φᵢ/xᵢ) + 5qᵢxᵢlog(θᵢ/Φᵢ)]\nθᵢ = qᵢxᵢ/∑qᵢxᵢ\nΦᵢ = rᵢxᵢ/∑rᵢxᵢ\nrᵢ = ∑Rₖνᵢₖ for k ∈ groups\nqᵢ = ∑Qₖνᵢₖ for k ∈ groups\n\nResidual Part:\n\ngᴱ(residual) = -v̄∑XₖQₖlog(∑ΘₘΨₘₖ)\nv̄ = ∑∑xᵢνᵢₖ for k ∈ groups,  for i ∈ components\nXₖ = (∑xᵢνᵢₖ)/v̄ for i ∈ components \nΘₖ = QₖXₖ/∑QₖXₖ\nΨₖₘ = exp(-(Aₖₘ/T)\n\nReferences\n\nFredenslund, A., Gmehling, J., Michelsen, M. L., Rasmussen, P., & Prausnitz, J. M. (1977). Computerized design of multicomponent distillation columns using the UNIFAC group contribution method for calculation of activity coefficients. Industrial & Engineering Chemistry Process Design and Development, 16(4), 450–462. doi:10.1021/i260064a004\n\n\n\n\n\n","category":"type"},{"location":"eos/activity/#Clapeyron.UNIFAC","page":"Activity Models","title":"Clapeyron.UNIFAC","text":"UNIFACModel <: ActivityModel\n\nUNIFAC(components::Vector{String};\npuremodel = PR,\nuserlocations = String[], \npure_userlocations = String[],\nverbose = false)\n\nInput parameters\n\nR: Single Parameter (Float64)  - Normalized group Van der Vals volume\nQ: Single Parameter (Float64) - Normalized group Surface Area\nA: Pair Parameter (Float64, asymetrical, defaults to 0) - Binary group Interaction Energy Parameter\nB: Pair Parameter (Float64, asymetrical, defaults to 0) - Binary group Interaction Energy Parameter\nC: Pair Parameter (Float64, asymetrical, defaults to 0) - Binary group Interaction Energy Parameter\n\nInput models\n\npuremodel: model to calculate pure pressure-dependent properties\n\nDescription\n\nUNIFAC (UNIQUAC Functional-group Activity Coefficients) activity model.\n\nModified UNIFAC (Dortmund) implementation.\n\nThe Combinatorial part corresponds to an GC-averaged modified UNIQUAC model. The residual part iterates over groups instead of components.\n\nGᴱ = nRT(gᴱ(comb) + gᴱ(res))\n\nCombinatorial part:\n\ngᴱ(comb) = ∑[xᵢlog(Φ'ᵢ) + 5qᵢxᵢlog(θᵢ/Φᵢ)]\nθᵢ = qᵢxᵢ/∑qᵢxᵢ\nΦᵢ = rᵢxᵢ/∑rᵢxᵢ\nΦ'ᵢ = rᵢ^(0.75)/∑xᵢrᵢ^(0.75)\nrᵢ = ∑Rₖνᵢₖ for k ∈ groups\nqᵢ = ∑Qₖνᵢₖ for k ∈ groups\n\nResidual Part:\n\ngᴱ(residual) = -v̄∑XₖQₖlog(∑ΘₘΨₘₖ)\nv̄ = ∑∑xᵢνᵢₖ for k ∈ groups,  for i ∈ components\nXₖ = (∑xᵢνᵢₖ)/v̄ for i ∈ components \nΘₖ = QₖXₖ/∑QₖXₖ\nΨₖₘ = exp(-(Aₖₘ + BₖₘT + CₖₘT²)/T)\n\nReferences\n\nFredenslund, A., Gmehling, J., Michelsen, M. L., Rasmussen, P., & Prausnitz, J. M. (1977). Computerized design of multicomponent distillation columns using the UNIFAC group contribution method for calculation of activity coefficients. Industrial & Engineering Chemistry Process Design and Development, 16(4), 450–462. doi:10.1021/i260064a004\nWeidlich, U.; Gmehling, J. A modified UNIFAC model. 1. Prediction of VLE, hE, and.gamma..infin. Ind. Eng. Chem. Res. 1987, 26, 1372–1381.\n\n\n\n\n\n","category":"type"},{"location":"eos/activity/#Clapeyron.PSRKUNIFAC","page":"Activity Models","title":"Clapeyron.PSRKUNIFAC","text":"PSRKUNIFACModel <: UNIFACModel\n\nPSRKUNIFAC(components::Vector{String};\npuremodel = PR,\nuserlocations = String[], \npure_userlocations = String[],\nverbose = false)\n\nInput parameters\n\nR: Single Parameter (Float64)  - Normalized group Van der Vals volume\nQ: Single Parameter (Float64) - Normalized group Surface Area\nA: Pair Parameter (Float64, asymetrical, defaults to 0) - Binary group Interaction Energy Parameter\nB: Pair Parameter (Float64, asymetrical, defaults to 0) - Binary group Interaction Energy Parameter\nC: Pair Parameter (Float64, asymetrical, defaults to 0) - Binary group Interaction Energy Parameter\n\nInput models\n\npuremodel: model to calculate pure pressure-dependent properties\n\nDescription\n\nUNIFAC (UNIQUAC Functional-group Activity Coefficients) activity model.\n\nModified UNIFAC (Dortmund) implementation, with parameters tuned to the Predictive Soave-Redlich-Kwong (PSRK) EoS.\n\nThe Combinatorial part corresponds to an GC-averaged modified UNIQUAC model. The residual part iterates over groups instead of components.\n\nGᴱ = nRT(gᴱ(comb) + gᴱ(res))\n\nCombinatorial part:\n\ngᴱ(comb) = ∑[xᵢlog(Φ'ᵢ) + 5qᵢxᵢlog(θᵢ/Φᵢ)]\nθᵢ = qᵢxᵢ/∑qᵢxᵢ\nΦᵢ = rᵢxᵢ/∑rᵢxᵢ\nΦ'ᵢ = rᵢ^(0.75)/∑xᵢrᵢ^(0.75)\nrᵢ = ∑Rₖνᵢₖ for k ∈ groups\nqᵢ = ∑Qₖνᵢₖ for k ∈ groups\n\nResidual Part:\n\ngᴱ(residual) = -v̄∑XₖQₖlog(∑ΘₘΨₘₖ)\nv̄ = ∑∑xᵢνᵢₖ for k ∈ groups,  for i ∈ components\nXₖ = (∑xᵢνᵢₖ)/v̄ for i ∈ components \nΘₖ = QₖXₖ/∑QₖXₖ\nΨₖₘ = exp(-(Aₖₘ + BₖₘT + CₖₘT²)/T)\n\nReferences\n\nFredenslund, A., Gmehling, J., Michelsen, M. L., Rasmussen, P., & Prausnitz, J. M. (1977). Computerized design of multicomponent distillation columns using the UNIFAC group contribution method for calculation of activity coefficients. Industrial & Engineering Chemistry Process Design and Development, 16(4), 450–462. doi:10.1021/i260064a004\nWeidlich, U.; Gmehling, J. A modified UNIFAC model. 1. Prediction of VLE, hE, and.gamma..infin. Ind. Eng. Chem. Res. 1987, 26, 1372–1381.\nHorstmann, S., Jabłoniec, A., Krafczyk, J., Fischer, K., & Gmehling, J. (2005). PSRK group contribution equation of state: comprehensive revision and extension IV, including critical constants and α-function parameters for 1000 components. Fluid Phase Equilibria, 227(2), 157–164. doi:10.1016/j.fluid.2004.11.002\n\n\n\n\n\n","category":"type"},{"location":"eos/activity/#Clapeyron.VTPRUNIFAC","page":"Activity Models","title":"Clapeyron.VTPRUNIFAC","text":"VTPRUNIFACModel <: UNIFACModel\n\nVTPRUNIFAC(components::Vector{String};\npuremodel = PR,\nuserlocations = String[], \npure_userlocations = String[],\nverbose = false)\n\nInput parameters\n\nQ: Single Parameter (Float64) - Normalized group Surface Area\nA: Pair Parameter (Float64, asymetrical, defaults to 0) - Binary group Interaction Energy Parameter\nB: Pair Parameter (Float64, asymetrical, defaults to 0) - Binary group Interaction Energy Parameter\nC: Pair Parameter (Float64, asymetrical, defaults to 0) - Binary group Interaction Energy Parameter\n\nInput models\n\npuremodel: model to calculate pure pressure-dependent properties\n\nDescription\n\nUNIFAC (UNIQUAC Functional-group Activity Coefficients) activity model.\n\nModified UNIFAC (Dortmund) implementation, only residual part, activity model used for the Volume-Translated Peng-Robinson (VTPR) EoS.\n\nThe residual part iterates over groups instead of components.\n\nGᴱ = nRT(gᴱ(res))\ngᴱ(res) = -v̄∑XₖQₖlog(∑ΘₘΨₘₖ)\nv̄ = ∑∑xᵢνᵢₖ for k ∈ groups,  for i ∈ components\nXₖ = (∑xᵢνᵢₖ)/v̄ for i ∈ components \nΘₖ = QₖXₖ/∑QₖXₖ\nΨₖₘ = exp(-(Aₖₘ + BₖₘT + CₖₘT²)/T)\n\nReferences\n\nFredenslund, A., Gmehling, J., Michelsen, M. L., Rasmussen, P., & Prausnitz, J. M. (1977). Computerized design of multicomponent distillation columns using the UNIFAC group contribution method for calculation of activity coefficients. Industrial & Engineering Chemistry Process Design and Development, 16(4), 450–462. doi:10.1021/i260064a004\nWeidlich, U.; Gmehling, J. A modified UNIFAC model. 1. Prediction of VLE, hE, and.gamma..infin. Ind. Eng. Chem. Res. 1987, 26, 1372–1381.\nAhlers, J., & Gmehling, J. (2001). Development of an universal group contribution equation of state. Fluid Phase Equilibria, 191(1–2), 177–188. doi:10.1016/s0378-3812(01)00626-4\n\n\n\n\n\n","category":"type"},{"location":"eos/empiric/","page":"Empiric Helmholtz Models","title":"Empiric Helmholtz Models","text":"CurrentModule = Clapeyron","category":"page"},{"location":"eos/empiric/#Index","page":"Empiric Helmholtz Models","title":"Index","text":"","category":"section"},{"location":"eos/empiric/","page":"Empiric Helmholtz Models","title":"Empiric Helmholtz Models","text":"Pages = [\"empiric.md\"]","category":"page"},{"location":"eos/empiric/#Empiric-Helmholtz-Models","page":"Empiric Helmholtz Models","title":"Empiric Helmholtz Models","text":"","category":"section"},{"location":"eos/empiric/","page":"Empiric Helmholtz Models","title":"Empiric Helmholtz Models","text":"Clapeyron.IAPWS95\nClapeyron.PropaneRef\nClapeyron.LJRef\nClapeyron.GERG2008\nClapeyron.EOS_LNG","category":"page"},{"location":"eos/empiric/#Clapeyron.IAPWS95","page":"Empiric Helmholtz Models","title":"Clapeyron.IAPWS95","text":"IAPWS95 <: EmpiricHelmholtzModel\nIAPWS95()\n\nInput parameters\n\nNone\n\nDescription\n\nIAPWS95 (International Association for the Properties of Water and Steam) Pure water Model, 2018 update.\n\nδ = ρ/ρc\nτ = T/Tc\na⁰(δ,τ) = log(δ) + n⁰₁ + n⁰₂τ + n⁰₃log(τ) + ∑n⁰ᵢ(1-exp(-γ⁰ᵢτ)), i ∈ 4:8\naʳ(δ,τ)  = aʳ₁+ aʳ₂ + aʳ₃ + aʳ₄\naʳ₁(δ,τ)  =  ∑nᵢδ^(dᵢ)τ^(tᵢ), i ∈ 1:7\naʳ₂(δ,τ)  =  ∑nᵢexp(-δ^cᵢ)δ^(dᵢ)τ^(tᵢ), i ∈ 8:51\naʳ₃(δ,τ)  =  ∑nᵢexp(-αᵢ(δ - εᵢ)^2 - βᵢ(τ - γᵢ)^2)δ^(dᵢ)τ^(tᵢ), i ∈ 52:54\naʳ₄(δ,τ) = ∑nᵢδΨΔ^(bᵢ), i ∈ 55:56\nΔ = θ^2 + Bᵢ[(δ - 1)^2]^aᵢ\nθ = (1 - τ) + Aᵢ[(δ - 1)^2]^(1/2βᵢ)\nΨ = exp(-Cᵢ(δ - 1)^2 - Dᵢ(τ - 1)^2)\n\nparameters n⁰,γ⁰,n,t,d,c,α,β,γ,ε,A,B,C,D where obtained via fitting.\n\nReferences\n\nWagner, W., & Pruß, A. (2002). The IAPWS formulation 1995 for the thermodynamic properties of ordinary water substance for general and scientific use. Journal of physical and chemical reference data, 31(2), 387–535. doi:10.1063/1.1461829\nIAPWS R6-95 (2018). Revised Release on the IAPWS Formulation 1995 for the Thermodynamic Properties of Ordinary Water Substance for General and Scientific Use\n\n\n\n\n\n","category":"type"},{"location":"eos/empiric/#Clapeyron.PropaneRef","page":"Empiric Helmholtz Models","title":"Clapeyron.PropaneRef","text":"PropaneRef <: EmpiricHelmholtzModel\nPropaneRef()\n\nInput parameters\n\nNone\n\nDescription\n\nPropane Reference Equation of State\n\nδ = ρ/ρc\nτ = T/Tc\na⁰(δ,τ) = log(δ) + n⁰₁ + n⁰₂τ + n⁰₃log(τ) + ∑n⁰ᵢ(1-exp(-γ⁰ᵢτ)), i ∈ 4:7\naʳ(δ,τ)  = aʳ₁+ aʳ₂ + aʳ₃\naʳ₁(δ,τ)  =  ∑nᵢδ^(dᵢ)τ^(tᵢ), i ∈ 1:5\naʳ₂(δ,τ)  =  ∑nᵢexp(-δ^cᵢ)δ^(dᵢ)τ^(tᵢ), i ∈ 6:11\naʳ₃(δ,τ)  =  ∑nᵢexp(-ηᵢ(δ - εᵢ)^2 - βᵢ(τ - γᵢ)^2)δ^(dᵢ)τ^(tᵢ), i ∈ 12:18\n\n\nparameters  n⁰,γ⁰,n,t,d,c,η,β,γ,ε where obtained via fitting.\n\nReferences\n\nLemmon, E. W., McLinden, M. O., & Wagner, W. (2009). Thermodynamic properties of propane. III. A reference equation of state for temperatures from the melting line to 650 K and pressures up to 1000 MPa. Journal of Chemical and Engineering Data, 54(12), 3141–3180. doi:10.1021/je900217v\n\n\n\n\n\n","category":"type"},{"location":"eos/empiric/#Clapeyron.LJRef","page":"Empiric Helmholtz Models","title":"Clapeyron.LJRef","text":"LJRef <: EmpiricHelmholtzModel\nLJRef(components;\nuserlocations=String[],\nverbose=false)\n\nInput parameters\n\nsigma: Single Parameter (Float64) - particle size [Å]\nepsilon: Single Parameter (Float64) - dispersion energy [K]\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nk: Pair Parameter (Float64) - sigma mixing coefficient\n\nModel Parameters\n\nsigma: Pair Parameter (Float64) - particle size [m]\nepsilon: Pair Parameter (Float64) - dispersion energy [K]\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\n\nDescription\n\nLennard-Jones Reference equation of state. valid from 0.5 < T/Tc < 7 and pressures up to p/pc = 500.\n\nσᵢⱼ = (σᵢ + σⱼ)/2\nϵᵢⱼ = (1-kᵢⱼ)√(ϵⱼϵⱼ)\nσ^3 = Σxᵢxⱼσᵢⱼ^3\nϵ = Σxᵢxⱼϵᵢⱼσᵢⱼ^3/σ^3\n\nτᵢ = 1.32ϵᵢ/T\nδᵢ = n(Nₐσᵢ^3)/0.31V\na⁰ᵢ(δ,τ) = log(δᵢ) + 1.5log(τᵢ) + 1.515151515τᵢ + 6.262265814 \na⁰(δ,τ,z) = ∑xᵢ(a⁰ᵢ + log(xᵢ))\n\nτ = 1.32ϵ/T\nδ = n(Nₐσ^3)/0.31V\n\naʳ(δ,τ)  = aʳ₁+ aʳ₂ + aʳ₃ + aʳ₄\naʳ₁(δ,τ)  =  ∑nᵢδ^(dᵢ)τ^(tᵢ), i ∈ 1:6\naʳ₂(δ,τ)  =  ∑nᵢexp(-δ^cᵢ)δ^(dᵢ)τ^(tᵢ), i ∈ 7:12\naʳ₃(δ,τ)  =  ∑nᵢexp(-ηᵢ(δ - εᵢ)^2 - βᵢ(τ - γᵢ)^2)δ^(dᵢ)τ^(tᵢ), i ∈ 13:23\n\nparameters n,t,d,c,η,β,γ,ε where obtained via fitting.\n\nwarning: Mutiple component warning\nThe original model was done with only one component in mind. to support multiple components, a VDW 1-fluid mixing rule (shown above) is implemented, but it is not tested.\n\nReferences\n\nThol, M., Rutkai, G., Köster, A., Lustig, R., Span, R., & Vrabec, J. (2016). Equation of state for the Lennard-Jones fluid. Journal of physical and chemical reference data, 45(2), 023101. doi:10.1063/1.4945000\n\n\n\n\n\n","category":"type"},{"location":"eos/empiric/#Clapeyron.GERG2008","page":"Empiric Helmholtz Models","title":"Clapeyron.GERG2008","text":"GERG2008 <: MultiFluidModel\nGERG2008(components::Vector{String})\n\nImput Parameters\n\nNone\n\nDescription\n\nThe GERG-2008 Wide-Range Equation of State for Natural Gases and Other Mixtures. valid for 21 compounds (Clapeyron.GERG2008_names). \n\n\na = a⁰ + aʳ\n\na⁰ = ∑xᵢ(a⁰ᵢ(τᵢ,δᵢ) + ln(xᵢ))\nδᵢ = ρ/ρcᵢ\nτᵢ = Tcᵢ/T\na⁰ᵢ = ln(δᵢ) + R∗/R[n⁰ᵢ₋₁ + n⁰ᵢ₋₂τᵢ + n⁰ᵢ₋₃ln(τᵢ) + ∑n⁰ᵢ₋ₖln(abs(sinh(ϑ₀ᵢ₋ₖτᵢ))) + ∑n⁰ᵢ₋ₖln(cosh(ϑ₀ᵢ₋ₖτᵢ))]\nR∗ = 8.314510\nR = 8.314472\n\nτ = Tᵣ/T\nδ = ρ/ρᵣ\n(1/ρᵣ) = ∑∑xᵢxⱼβᵥ₋ᵢⱼγᵥ₋ᵢⱼ[(xᵢ+xⱼ)/(xᵢβᵥ₋ᵢⱼ^2 + xⱼ)]•1/8(1/∛ρcᵢ + 1/∛ρcⱼ)^2\nTᵣ = ∑∑xᵢxⱼβₜ₋ᵢⱼγₜ₋ᵢⱼ[(xᵢ+xⱼ)/(xᵢβₜ₋ᵢⱼ^2 + xⱼ)]•√(TcᵢTcⱼ)\naʳ = ∑xᵢaᵣᵢ(τ,δ) + ∑∑xᵢxⱼFᵢⱼaʳᵢⱼ(τ,δ)\naʳᵢ = ∑nᵢ₋ₖδ^(dᵢ₋ₖ)τ^(tᵢ₋ₖ)  + ∑nᵢ₋ₖδ^(dᵢ₋ₖ)τ^(tᵢ₋ₖ)exp(-δ^cᵢ₋ₖ)\naʳᵢⱼ = ∑nᵢⱼ₋ₖδ^(dᵢⱼ₋ₖ)τ^(tᵢⱼ₋ₖ)  + ∑nᵢⱼ₋ₖδ^(dᵢⱼ₋ₖ)τ^(tᵢⱼ₋ₖ)exp(ηᵢⱼ₋ₖ(δ-εᵢⱼ₋ₖ)^2 + βᵢⱼ₋ₖ(δ-γᵢⱼ₋ₖ)) \n\nReferences\n\nKunz, O., & Wagner, W. (2012). The GERG-2008 wide-range equation of state for natural gases and other mixtures: An expansion of GERG-2004. Journal of Chemical and Engineering Data, 57(11), 3032–3091. doi:10.1021/je300655b\n\n\n\n\n\n","category":"type"},{"location":"eos/empiric/#Clapeyron.EOS_LNG","page":"Empiric Helmholtz Models","title":"Clapeyron.EOS_LNG","text":"EOS_LNG <: MultiFluidModel\nEOS_LNG(components::Vector{String})\n\nImput Parameters\n\nNone\n\nDescription\n\nEOS-LNG: A Fundamental Equation of State for the Calculation of Thermodynamic Properties of Liquefied Natural Gases. valid for 21 compounds (Clapeyron.GERG2008_names). the EoS has new binary-specific parameters for methane + n-butane, methane + isobutane, methane + n-pentane, and methane + isopentane.\n\nIt uses the same functional form as GERG2008.\n\nReferences\n\nThol, M., Richter, M., May, E. F., Lemmon, E. W., & Span, R. (2019). EOS-LNG: A fundamental equation of state for the calculation of thermodynamic properties of liquefied natural gases. Journal of Physical and Chemical Reference Data, 48(3), 033102. doi:10.1063/1.5093800\nKunz, O., & Wagner, W. (2012). The GERG-2008 wide-range equation of state for natural gases and other mixtures: An expansion of GERG-2004. Journal of Chemical and Engineering Data, 57(11), 3032–3091. doi:10.1021/je300655b\n\n\n\n\n\n","category":"type"},{"location":"theory/background/#Models","page":"Background","title":"Models","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"Here, we give a high-level description of equations of state and the models provided by Clapeyron.","category":"page"},{"location":"theory/background/#Equations-of-state","page":"Background","title":"Equations of state","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"An equation of state is a functional form, f (say), that allows us to obtain a thermodynamic property, F, at given conditions boldsymbolOmega:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"F = f(boldsymbolOmegaboldsymbolXi).","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"There are many ways one can develop an equation of state, however, these must respect the constraints on the number of properties we can specify, as required by the Gibbs Phase Rule:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"mathrmDoF = N_mathrmspecies - N_mathrmphase + 2","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Here, mathrmDoF means \"Degrees of Freedom\"; this is the number of so-called intensive state properties (or, in other words, those that are independent of system size) that we can specify. As we can see, the largest number of degrees of freedom we can have is N_mathrmspecies+1; system size itself is not included so, in practise, this represents one more variable that we can specify, giving N_mathrmspecies+2. Thus, taking the simple case of a single species, we can specify at most three conditions in our system. For a traditional equation of state, we specify volume, V, temperature, T, and the size of the system – for example the number of particles, N, or moles, n; the equation of state then returns the pressure, p. Many modern equations of state are derived using what is known as the canonical ensemble (more information can be found in Statistical Mechanics textbooks) and, accordingly, the three variable chosen are again usually T, V and  N; the output of these equations is usually the Helmholtz free energy, A. ","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Many equations of state are based on an underlying molecular model. Consequently, it is also typical for an equation of state to require parameters, boldsymbolXi, to model certain species. The nature of these parameters depends on the equation of state.","category":"page"},{"location":"theory/background/#Ideal-gas-equation-of-state","page":"Background","title":"Ideal-gas equation of state","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"One equation of state that most engineers and scientists should be very familiar with is the ideal-gas equation, commonly expressed as:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"pV = Nk_mathrmBT","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"where p is the pressure, N is the total number of particles and k_mathrmB is the Boltzmann constant. Ideal-gas molecules are \"invisible\" to each other; there is zero interaction between ideal-gas molecules (this is, in essence, the ideal-gas model), so you can think of them as being infinitely small. This equation was first written down (although in slightly different form) in 1834 by Émile Clapeyron (in whose honour Clapeyron is named). Most (if not all) subsequent equations of state are descended from Clapeyron's equation, which is surprisingly appropriate for a wide variety of species in the gas phase at high-enough temperature and low-enough pressure.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Unfortunately, if we wish to determine other thermodynamic properties this equation is a little inconvenient. It would be much easier if it was expressed in the form of the free energy, from which other properties can then be evaluated using standard thermodynamic relationships. Accordingly, we could first integrate the above equation with respect to volume to determine the Helmholtz free energy:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"A_mathrmideal =- int pmathrmdV =- Nk_mathrmBTlnV+c(TN)","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"This is still a little inconvenient, however, since we have to deal with a tricky constant of integration. Fortunately, we can instead derive A_mathrmideal from statistical mechanics (using just a few well-known results from quantum mechanics). Following this route, we obtain (for a pure component (i.e., a single species))","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"fracA_mathrmidealNk_mathrmBT = ln(rhoLambda^3)-1,","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"where rho = NV is the number density, and Lambda is the thermal de Broglie wavelength, which introduces the kinetic contributions to the free energy (strictly speaking, with this notation only translations are included). We can generalise this as a sum over species i for a multicomponent mixture:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"fracA_mathrmidealNk_mathrmBT = left(sum_ix_iln(rho_iLambda_i^3)right)-1,","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"where x_i is the molar composition, and the subscript denote that the variable so decorated relates to species i. This equation represnts the MonomerIdeal form in Clapeyron. For the purposes of vapour–liquid-equilibrium properties, one can even ignore Lambda_i (since it cancels out in solving the phase equilibrium); we therefore use this as the default BasicIdeal model. ","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"The kinetic energy of polyatomic species includes contributions from vibrational and rotational modes of motion, as well as translational; we must also account for these in the ideal free energy. The statistical-mechanical derivation of the ideal free energy becomes a little more complicated but can still be done, resulting in the following expression:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"fracA_mathrmidealNk_mathrmBT=sum_ix_ibigglnleft(rho_iLambda_i^3right)-fracN_mathrmroti2 ln fracTtheta_mathrmroti+sum^N_mathrmvibi_mathrmvg_imathrmvleftfractheta_mathrmvibimathrmv2T+lnleft(1-exp-(theta_mathrmvibimathrmvT)right)right-1bigg.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Here N_mathrmroti, theta_mathrmroti and N_mathrmvibi are the number of rotations, the number of vibrations and the rotational temperature of a species i, respectively; g_imathrmv and theta_mathrmvibimathrmv represent the degeneracy and vibrational temperature of a vibrational mode mathrmv of species i. The WalkerIdeal model provides the necessary parameters to use such an equation. However, the more-commonly used approach is through the use of correlations of the ideal isobaric heat capacity, C_pi^0, such as the ReidIdeal, WilhoitIdeal and AlyLeeIdeal models. From the ideal isobaric heat capacity, it is possible to determine the ideal Helmholtz free energy using the following equation:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"fracA_mathrmidealNk_mathrmBT = sum_i=1^N_mathrmComponent x_ileftlnfracrho_irho_0     + frac1Nk_mathrmBT int_T_0^T C_pi^0 dT + fracH_0iNk_mathrmBT- frac1Nk_Bint_T_0^T fracC_pi^0T dT -lnfracTT_0-fracS_0iNk_mathrmB - 1right","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Note that the reference states, rho_0, H_0i and S_0i, can typically be neglected as these will not impact or contribute to most thermodynamic properties of interest.","category":"page"},{"location":"theory/background/#Cubic-equations-of-state","page":"Background","title":"Cubic equations of state","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"This is the most-popular class of equations of state. The progenitor of these is the van der Waals (vdW) equation of state, published in 1873, which can be written as:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"p = fracNk_mathrmBTV-Nb-fracN^2aV^2","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"where a and b are the model parameters. Although the vdW equation was phenomenological in origin, it, too, can be derived from statistical thermodynamics. Strictly speaking, b accounts for the space taken up by the molecules themselves (it corresponds to the excluded volume per molecule) and a quantifies the magnitude of attraction between species. As a result, the first term is often thought of as accounting for the repulsive interactions between molecules, while the second accounts for attractive interactions. In principle, therefore, one could obtain values of a and b for a particular species from (for example) spectroscopic information. However, since a and b can be related to the critical temperature and pressure of the vdW fluid, to relate the equation of state to a particular species, it is conventional to use the critical temperature and pressure of the species to obtain working values of the parameters. ","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Unfortunately, although its simple functional form makes calculations quite straight-forward, the vdW equation is inadequate for quantitative modelling, particularly for volumetric properties, and is most useful only for providing a qualitative description of the thermodynamic properties of the fluid.  As a result, many other engineering cubic equations have been developed, retaining (as far as possible) the simple mathematical form of van der Waals' equation. The first noteworthy one of these is the Redlich-Kwong (RK) equation:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"p = fracNk_mathrmBTV-Nb-fracN^2asqrtTV(V+Nb)","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"There is no physical justification for the change in the second term; its origin is entirely empirical. The authors made the modification so that the equation would provide better gas-phase fugacities. This equation was subsequently improved upon by Soave, resulting in the SRK equation of state:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"p = fracNk_mathrmBTV-Nb-fracN^2alpha(Tomega)V(V+Nb)","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"The alpha function requires an additional parameter, the acentric factor (or acentricity), which is effectively a measure of the location of the saturation pressure when TT_mathrmc=07, where T_mathrmc is the critical temperature. The idea behind this is, if you can capture both the critical point and another point along the vapour-pressure curve, you will improve the accuracy of your equation of state. This is indeed what happened. Although Soave described his equation as a \"modified Redlich–Kwong equation\", in truth it is more than this. The introduction of the alpha function represents a giant step forwards; the inclusion of a similar alpha function is probably the key feature in the equation of Peng and Robinson, who introduced their equation of state (PR) to provide improved liquid-phase volumetric properties. In addition to the inclusion of an alpha function, Peng and Robinson further revised the attractive term:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"p = fracNk_mathrmBTV-Nb-fracN^2alpha(Tomega)V^2+2NbV+b^2N^2","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"The SRK and PR equations of state are comparable in performance, although the latter generally provides liquid densities with a greater degree of accuracy, while the former usually provides better fugacities. However, when it comes to modelling complex species such as polymers (macromolecules), or associating species, both equations struggle to perform well. This is unsurprising, since the underlying molecular model remains, in essence, a \"van der Waalsian sphere\" – in other words,a hard spherical core surrounded by a region of attraction. A more-sophisticated molecular model is required to account well for the increased molecular complexitiies of these species.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Before moving on from cubic equations of state we note that, within Clapeyron, the cubic plus association (CPA) equation of state is supported. A CPA equation is the amalgamation of a cubic equation (usually SRK, as in Clapeyron, or PR) with the association term from the SAFT equation, which we will meet later. Strictly speaking, it is neither a cubic nor a SAFT equation of state but, rather, occupies a middle ground between these two classes of equation. ","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Something that may be apparent in all these equations is the fact that these are all functions that return the pressure and, thus, must be integrated to obtain the Helmholtz free energy. Like the ideal-gas equation, there will be missing temperature and compositional dependences which need to be included.","category":"page"},{"location":"theory/background/#Mixtures-with-cubic-equations-of-state","page":"Background","title":"Mixtures with cubic equations of state","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"One may wonder how to model mixtures using such equations. This can be achieved using mixing rules, in conjunction with combining rules. Although there are many variants, one of the more-popular mixing rules is the van der Waals one-fluid mixing rule: the mixture is treated as a hypothetical pure fluid, characterised by parameters bara and barb that are given by","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"bara=sum_isum_jx_ix_ja_ij","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"barb=sum_isum_jx_ix_jb_ij","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"When i=j, a and b are just the normal van der Waals parameters for the pure. However, when ineq j, these parameter characterise the unlike interactions between i and j. We typically need to use combining rules (not to be confused with mixing rules) to determine the unlike parameters. Examples of these include:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"b_ij=fracb_i+b_j2","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"a_ij = (1-k_ij)sqrta_ia_j","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"where k_ij can be set to 0 but, using either more-advanced combining rules or regression to experimental data, can be tuned to improve the effectiveness of the combining rule. Further details on this will be given for the SAFT models.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"More-complicated mixing rules (such as the Wong-Sandler mixing rule) are available and implemented in Clapeyron. ","category":"page"},{"location":"theory/background/#SAFT-equations-of-state","page":"Background","title":"SAFT equations of state","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"In comparison to the cubic equations of state, equations based on the Statistical Associating Fluid Theory (SAFT) are based on a more-theoretical approach, although still can be considered as descendents of van der Waals' equation. As mentioned earlier, the van der Waals equation can be derived from statistical mechanics, whereby the Helmholtz free energy of the van der Waals fluid is obtained as","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"fracANk_mathrmBT = fracA_mathrmidealNk_mathrmBT+fracA_mathrmHSNk_mathrmBT+fracA_mathrm1(Nk_mathrmBT)^2;","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"here the ideal and hard-sphere (HS) terms combine to give the repulsive term (of the pressure form of the equation) whilst the A_1 term results in the attractive term. We can see from this that, using the van der Waals equation, species are effectively modelled as hard spheres with dispersive interactions (we sometimes call these London dispersion interactions). The latter two terms can be merged into what is referred to as the monomer or segment term. ","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Whilst, as already noted, this is clearly a step up from the ideal gas, most species can't be modelled effectively as single spheres; they may be highly non-speherical in shape (as is usually the case with large molecules), or they may experience interactions that are more complex than simple dispersion. A classic example of the latter is water; although the water molecule is small and (at first glance) may appear simple, the behaviour of water is very strongly influenced by hydrogen-bonding interactions.  ","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Using Wertheim's TPT1 theory of association, it is possible to model molecules as chains of spheres; the shape of the model molecule can thereby be tailored to represent that of the real molecule far better than a single sphere. Wertheim's TPT1 theory can also be used to account for intermolecular association interactions (such as dipole–dipole interactions, or hydrogen bonding), which are strongly directional. These are described using associations sites that are located on one or more of the spherical segments comprising the chain molecule. This results in the addition of two extra contributions to the Helmholtz free energy (note that the HS and dispersive terms have been merged into a monomer term):","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"fracANk_mathrmBT = fracA_mathrmidealNk_mathrmBT+fracA_mathrmmonoNk_mathrmBT+fracA_mathrmchainNk_mathrmBT+fracA_mathrmassocNk_mathrmBT","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"The chain term accounts for the formation of chains of spherical segments and is generally expressed as","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"fracA_mathrmchainNk_mathrmBT=-sum_ix_i(m_i-1)lng_ii(d_ii),","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"where g_ii(r_ii) is the pair distribution function for species i (which carries information about the structure of the fluid; it expresses how likely it is that a segment of species i is present at a distance r_ii from another segment of species i) . Many SAFT equations differ in how this pair distribution function is expressed. We note here the introduction of the Barker-Henderson hard-sphere diameter, d_ii which is given (dropping the subscripts for clarity) by","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"d = int_0^sigma (1-exp-betaphi(r))dr;","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"here phi(r) is our effective pair potential and beta=1(k_mathrmBT). This effectively gives a temperature dependence to the size of our segment and accounts for our segment becoming softer as temperature rises.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"The association term accounts for the highly-directional associative interactions (for example, hydrogen bonding). For most SAFT equations of state, it is expressed as:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"fracA_mathrmassocNk_mathrmBT=sum_ix_ileft(sum_aleft(lnX_ia-fracX_ia2right)+fracM_i2right)","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"where X_ia is the fraction of association sites a on species i not bonded to another and M_i is the number of association sites on species i.  X_ia can be obtained by solving the following system of equations:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"X_ia = (1+rhosum_jx_jsum_bX_jbDelta_ijab)^-1","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"An important aspect of the association term is that the above system of equations typically needs to be solved iteratively; this greatly increases the computational cost of the SAFT equations when modelling associating species (compared to modelling non-associating species, for example, or to using cubic equations of state). Delta_ijab is the association strength between site a on species i with site b on species j; this is also an aspect where SAFT equations usually differ but can all be written generally as","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Delta_ijab = F_ijabK_ijabI_ijab","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"where F_ijab is Mayer's function, given by","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"F = exp-betaepsilon^mathrmassoc-1,","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"where epsilon^mathrmassoc is the potential depth of the association interaction. K and I differ between equations but, generally, these represent the length scale of the interaction and the likelihood that the sites are correctly orientated such that they overlap, respectively.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Surprisingly, the monomer term is one of the aspects that most distinguishes the different SAFT equations; no two variants use the same equation. However, in general, the monomer term is composed of more than one term:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"fracA_mathrmmonoNk_mathrmBT=fracA_mathrmHSNk_mathrmBT+fracA_mathrm1(Nk_mathrmBT)^2+fracA_mathrm2(Nk_mathrmBT)^3+fracA_mathrm3(Nk_mathrmBT)^4+","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"This exprerssion is known as a Barker–Henderson perturbative expansion. These terms generally account for the dispersive interactions between segments; the n^mathrmth order term account for interactions between n segments. In most SAFT equations, this expansion is truncated at just the second-order term.","category":"page"},{"location":"theory/background/#Parameters","page":"Background","title":"Parameters","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"Although different SAFT equations use different parameters, most share a common set. These include the parameters that characterise the dispersive interactions (which are usually modelled as pair potentials): the potential depth epsilon (usually expressed as epsilon  k_mathrmB, in Kelvin) and the segment size sigma (in Angstrom). We point out here that this potential (and its parameters) is not a bare pair potential, which accounts only for the interactions of two species (in vacuum); it is an effective pair potential, which accounts for the effects of other species being around the interacting pair, in some cases quantum effects and, if associative interactions are not modelled separately, account for non-dispersive interactions.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"As species can now be modelled as chains of segments, the number of segments, m, also becomes a parameter. One thing to point out about this parameter is that it need not be an integer (despite what its name suggests); non-integer values of m can usually be interpreted as segments merging within the chain. ","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"In the case of associating species, SAFT equations usually require a parameter for the potential well depth of the association, epsilon^mathrmassoc (analogously to epsilon, this is usually expressed as epsilon^mathrmassoc  k_mathrmB, in Kelvin) and a parameter characterising the length-scale of the interaction (either a bonding volume, kappa^mathrmassoc, usually expressed in Å^3, or a length, r_c^mathrmassoc, either in meters or dimensionless (reduced by the segment size)). In the case of the dispersive and associative interaction parameters, there will also be the equivalent parameters characterising unlike interactions between species in a mixture (which can also be obtained from combining rules).","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Unfortunately, due to the complex function form of SAFT equations, it is impossible to directly relate these parameters to critical properties, as is done with the engineering cubics. Instead, these parameters are typically obtained by regression using experimental data (typically pure-component saturation-pressure and saturated-liquid-density data).","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"We will next go through each of the variants of the SAFT equation available in Clapeyron and what makes these unique.","category":"page"},{"location":"theory/background/#Original-SAFT","page":"Background","title":"Original SAFT","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"Derived by Chapman et al. (1990), this is the first variant of the SAFT equation of state. This equation can be seen as a `proof of concept' as not many parameters are available (none for mixtures). Nevertheless, a noteworthy feature of this equation is the use of a semi-empirical equation to obtain the hard-sphere diameter that depends on the number of segments of a species (in no other SAFT variant is this done). The hard-sphere pair-distribution is used in the chain term; this has a much-simpler analytical form than what is chosen for use in some other SAFT equations. The association strength, Delta is evaluated in a unique way as well:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Delta_ijab=d_ij^3g_ij^mathrmHSF_ijabkappa_ijab","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"where kappa_ijab is dimensionless. Unfortunately, the implementation of ogSAFT in Clapeyron cannot yet replicate the figures from the original paper. The reason for this is that the monomer / segment term presented in the paper is not the one used to generate the results. The actual term used is developed by Twu et al. (1980) and we are currently attempting to implement this within Clapeyron but it is not clear, as of yet, how it was implemented within the original equation.","category":"page"},{"location":"theory/background/#CK-SAFT","page":"Background","title":"CK-SAFT","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"If the SAFT equation derived by Chapman et al. was the prototype, the variant developed by Huang and Radosz (1990) was the first usable SAFT equation, with over 100 pure-component parameters and many unlike parameters available. Many of the computationally-intensive parts of ogSAFT are simplified in CKSAFT; a simpler equation is used to obtain the hard-sphere diameter, and the monomer term provided within the paper is the correct one. The chain term is identical in the two equations. Similarly, the association strength only has a minor change:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Delta_ijab=sigma_ij^3g_ij^mathrmHSF_ijabkappa_ijab;","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"this slightly reduces the computational cost. However, the most-noteworthy simplification came with the association term. As mentioned earlier, the association fraction needs to be solved for iteratively. However, Huang and Radosz proposed approximations of the association fraction that could be used to solve for the association term explicitly, greatly reducing the computational intensity of these calculations. These approximations have not been implemented within Clapeyron as of yet, but these only impact calculations for species other than alcohols and carboxylic acids. We also point out that Huang and Radosz introduced the concept of association schemes, which helps classify species based on how they interaction through association.","category":"page"},{"location":"theory/background/#SAFT-VR-SW","page":"Background","title":"SAFT-VR SW","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"Gil-Villegas et al. (1997) developed a new class of SAFT equations known as SAFT variable range. Here, more emphasis was placed on the potentials used to characterise dispersion interactions, and a new parameter was introduced through the potential shape. Whilst many versions of SAFT-VR are proposed, each using different underlying potentials, the one that was chosen as the default was SAFT-VR square-well (SW) with the additional potential-shape-parameter lambda (characterising the width of the potential well). Within this framework, novel expressions for the monomer and chain terms were proposed, both being based on the SW potential. The association term remained largely unchanged, with the association strength having the most-noteworthy modification:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Delta_ijab=g_ij^mathrmSWF_ijabkappa_ijab.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Here, kappa_ijab now carries units of volume. Not many parameters are available for this equation of state, primarily being used to model alkanes and perfluoro-alkanes. However, compared to most other SAFT variants, SAFT-VR SW has possibly seen the most extensions, having a group-contribution alternative (SAFT-gamma SW), electrolyte (SAFT-VRE SW) and cross-over theory (SAFT-VRX SW). ","category":"page"},{"location":"theory/background/#soft-SAFT","page":"Background","title":"soft-SAFT","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"Developed by Blas and Vega (2001), whereas the SAFT equations discussed up until now had been based on a hard-sphere reference from which to build the equation of state, in soft-SAFT a Lennard-Jones reference is used instead. Because of this, compared to all other SAFT equations, soft-SAFT relies heavily on correlations obtained from molecular-dynamics simulations to obtain the monomer term, pair distribution function and association strength. Like SAFT-VR SW, soft-SAFT does not have an extensive database of parameters, but has been extended multiple times (cross-over theory being the more-noteworthy extension).","category":"page"},{"location":"theory/background/#PC-SAFT","page":"Background","title":"PC-SAFT","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"Possibly the most-popular variant of the SAFT equation, Perturbed-Chain (not polymer-chain) SAFT was developed by Gross and Sadowski (2001) and, like soft-SAFT, a different reference state is chosen, as compared with previous SAFT equations. This time, we start from the hard-chain (HC), not the hard-sphere, expressing the SAFT equation as:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"fracANk_mathrmBT = fracA_mathrmidealNk_mathrmBT+fracA_mathrmHCNk_mathrmBT+fracA_mathrmdispNk_mathrmBT+fracA_mathrmassocNk_mathrmBT","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"This isn't as significant a change as one might initially think as, effectively, the hard-sphere and chain terms (which uses a hard-sphere pair distribution function like CK-SAFT) are combined into the hard-chain term. The dispersion term is then simply another correlation, only this time depending on the number of segments as well. It carries many similarities with CK-SAFT, using the same expression for the hard-sphere diameter, pair distribution function and association term.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"The primary reasons behind PC-SAFT's popularity are three-fold. For one, the code for PC-SAFT is available open-source. Secondly, there is an abundance of parameters available (over 250), including unlike parameters. Finally, many variants of the PC-SAFT equation have been developed. These include:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Polar PC-SAFT (PPC-SAFT)\nPC-Polar SAFT (PCP-SAFT); yes, these are distinct equations\nElectrolyte PC-SAFT (ePC-SAFT)\nElectrolyte PPC-SAFT (ePPC-SAFT)\nPolyelectrolyte ePC-SAFT (epPC-SAFT)\nCritical-point based PC-SAFT (CP-PC-SAFT)\nCritical-point based PPC-SAFT (CP-PPC-SAFT)\nGroup-contribution PC-SAFT (GC-PC-SAFT)\nGroup contribution PPC-SAFT (GC-PPC-SAFT)","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"We will aim to provide some of these variants at a later date.","category":"page"},{"location":"theory/background/#sPC-SAFT","page":"Background","title":"sPC-SAFT","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"We do already provide one of the PC-SAFT variants, namely the simplified PC-SAFT equation (developed by Von Solms et al. (2003)). Here, the only modifications are to the hard-chain and association terms where, instead of using the generalised expressions for the hard-sphere term and hard-sphere pair distribution function, by averaging the hard-sphere diameter (effectively treating mixtures as being made up of identically sized segments), the pure-component versions of these properties are used instead. The benefit of this is that pure-component parameters determined for PC-SAFT can still be used here, and only the unlike parameters need to be modified.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Similar to PC-SAFT, variants of the sPC-SAFT equation also exist, although nowhere near as extensive. Most notably, a significant group-contribution method is available.","category":"page"},{"location":"theory/background/#SAFT-VR-Mie","page":"Background","title":"SAFT-VR Mie","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"One of the most-novel SAFT equations of state, derived by Lafitte et al. (2013), this equation is effectively an extension of the SAFT-VR framework developed by Gil-Villegas et al. (1997), with further improvements. First of these is extending the Barker–Henderson perturbative expansion to third order instead of second order:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"fracA_mathrmmonoNk_mathrmBT=fracA_mathrmHSNk_mathrmBT+fracA_mathrm1(Nk_mathrmBT)^2+fracA_mathrm2(Nk_mathrmBT)^3+fracA_mathrm3(Nk_mathrmBT)^4","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"We do point out that, whilst the first two terms are developed following the SAFT-VR framework, the third-order term is more akin to a correlation regressed using molecular-dynamics simulation data for Mie fluids. This third-order term resulted in significant improvements in the modelling of properties near the critical point (without using cross-over theory). The chain term also received further improvements as a result. This is also the only SAFT equation in which the hard-sphere diameter is evaluated analytically, although numerical approximations are needed (we note that the original SAFT-VR Mie equation used 10-point Gauss-Legendre quadrature, whilst the newer version uses 5-point Gauss-Laguerre quadrature).","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"However, three different versions of the association strength have been developed:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Hard-sphere kernel:\nDelta_ijab=sigma_ij^3g_ij^mathrmHSF_ijabK_ijab\nLennard-Jones kernel:\nDelta_ijab=F_ijabK_ijabI_ijab(epsilon_ijsigma_ij)\nMie kernel:\nDelta_ijab=F_ijabK_ijabI_ijab(epsilon_ijsigma_ijlambda_ij)","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Unfortunately, it seems that there have been inconsistencies between which of these kernels is used in different publications. In the current 'default' SAFT-VR Mie equation the Lennard-Jones kernel is used; as such, this is the one used in Clapeyron. We do intend to provide the option to switch between these kernels.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"As a Mie potential is characterised by two shape parameters, lambda_mathrma (characterising the attractive part) and lambda_mathrmr (characterising the repulsive part), both of these have become parameters for each species (although lambda_mathrma is usually set to 6). As we have different association terms, we also have different sets of parameters where the only difference is the length-scale. In the Lennard-Jones and Mie kernels, K_ijab is the 'bonding volume', whereas, in the hard-sphere kernel, it is a 'bonding length', r_ijab^c.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"The SAFT-VR Mie does not have a significantly large repository of parameters (compensated by its group-contribution variant) and has only been extended to electrolytes (SAFT-VRE Mie and eSAFT-VR Mie). ","category":"page"},{"location":"theory/background/#SAFT-VRQ-Mie","page":"Background","title":"SAFT-VRQ Mie","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"A very recent extension of the SAFT-VR Mie equation is the SAFT-VRQ Mie equation developed by Aasen et al. (2019) in which the underlying Mie potential is modified using a Feynman-Hibbs potential, which means that a single species is represented by a sum of three Mie potentials. This method attempts to classically account for quantum effects present in small species such as helium, hydrogen and neon. Unfortunately, this equation is limited to just the monomer term and, even then, it is very computationally intensive. We do note that the current implementation in Clapeyron can only model pure-component properties, but we will extend this to mixtures in future versions.","category":"page"},{"location":"theory/background/#SAFT-\\gamma-Mie","page":"Background","title":"SAFT-gamma Mie","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"The group-contribution version of SAFT-VR Mie, developed by Papaioannou et al. (2014), the SAFT-gamma Mie equation rests on the same general framework as SAFT-VR Mie, although, as it is a group-contribution method, we are able to model heterogenous chains (in SAFT equations discussed previously, all segments in a chain were the same size). The group-contribution methodology is based on that developed by Lymperiadis et al. (2008). An interesting aesthetic change is with the number of segments where this is now separated into the shape factor, S, and the number of segments v^*. The latter must now be an integer and the former is a direct measure of how 'fused' the segments are. Approximately 60 groups are currently available for this equation. A noteworthy advantage of using groups is that unlike parameters between groups can be estimated from pure-component data; these can then be readily extended to mixtures without further regression. ","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"This equation has also been extended to electrolytes through SAFT-gammaE Mie.","category":"page"},{"location":"theory/background/#Methods","page":"Background","title":"Methods","text":"","category":"section"},{"location":"theory/background/#The-problem","page":"Background","title":"The problem","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"The aim of this document is to outline all of the various tools used to obtain the relevant properties from a SAFT-type equation of state. In short, SAFT equations of state provide the Helmholtz free energy of a system at a given composition mathbfz, volume V and temperature T:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"A=A(mathbfzVT)","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Taking derivatives of this function (within the Clapeyron module, this is done using automatic differentiation) can give us a wide range of properties which are given in the appendix. However, it is more common that we are interested in the state of a system at certain conditions (mathbfz_0, p_0 , T_0). The answer to this can be determined from the following, deceptively simple, minimisation of the Gibbs free energy:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"min G(mathbfz_0p_0T_0)","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"In the case of SAFT-type equations of state, this can be expressed as:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"min A(mathbfz_0VT_0)+p_0V","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"What isn't obvious in this formulation of the problem is how to identify the variables that are to be optimised. Re-expressing this problem in greater detail:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"min sum_i=1^n_mathrmphasephi_i(A(mathbfz_iV_iT_0)+p_0V_i)","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"mathrmst left(sum_i=1^n_mathrmphasesphi_iz_jiright)-z_j0=0quadforall j in 1n_mathrmspecies","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"where the subscript i denotes properties related to a phase i, and phi_i is the molar fraction of phase i. One can already see the difficulties behind solving such a problem as we do not often know beforehand how many phases there may be at the conditions (mathbfz_0, p_0 , T_0) and thus, we won't know which variables to optimise. In addition, we will want the global minimum and, particularly in systems with many components, there may be many local minima that we will need to eliminate.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Nevertheless, if we know certain things about the system beforehand, we can reduce the problem to one that is easier to solve.","category":"page"},{"location":"theory/background/#Volume-solvers","page":"Background","title":"Volume solvers","text":"","category":"section"},{"location":"theory/background/","page":"Background","title":"Background","text":"Let us make one simplifying assumption: we know that the system exists in a single phase. This greatly simplifies the problem to:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"min_V A(mathbfz_0VT_0)+p_0V","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"where, as there is no phase split, the only variable we need to optimise is the volume. We can see that this is equivalent to solving for the volume at which the pressure predicted by the equation of state equals p_0:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"min_V A(mathbfz_0VT_0)+p_0Vrightarrowfracpartial partial V(A(mathbfz_0VT_0)+p_0V)=fracpartial Apartial V(mathbfz_0VT_0)+p_0=-p(mathbfz_0VT_0)+p_0=0","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Effectively, we can re-word this as a root-finding problem. One slight issue with this is that there is often more than one root (there can actually be up to five, even in SAFT-type equations). The true root will be the one that minimises the Gibbs free energy; thus we must first find the candidate phases and determine their Gibbs free energy before reporting the volume.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"For the cubics, this problem is quite straightforward given that (as the name suggests) all these equations can be rearranged as a cubic equation in V:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"p_0=fracRT_0V-b-fraca(V-c_1)(V-c_2)rightarrow a_0+a_1V+a_2V^2+a_3V^3=0.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Thus, it is very easy to solve for all the roots in a cubic using analytical expressions. However, for other equations of state, we must use non-linear root-finding algorithms. In order to avoid the unstable phases, we try to use initial guesses close to what will be the 'true' phases:","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"Vapour: Since we can use automatic differentiation to obtain the virial coefficient for any model, we can actually obtain an initial guess extremely close to the final solution using\nfracp_0RT_0 = fracn_0V+fracn_0V^2B(T)rightarrow V_0=fracRT_0p_0frac-1+sqrt1+4p_0B(T_0)(RT_0)2 .\nLiquid: The best we can do here is to obtain the volume corresponding to a large packing fraction (we typically pick 0.6-0.8): V_0 = fracN_mathrmApi6times 08msigma^3. We are still looking for ways to improve this but the volume function is quite reliable as of now.","category":"page"},{"location":"theory/background/","page":"Background","title":"Background","text":"One other issue to consider when solving this problem is that, within the liquid phase, the gradients are very large; this can be difficult for algorithms to handle (even when providing the exact derivatives through automatic differentiation). We try to reduce magnitude of these derivatives by solving for the logarithm of the volume instead. ","category":"page"},{"location":"user_guide/custom_methods/#Definitions","page":"Custom Methods","title":"Definitions","text":"","category":"section"},{"location":"user_guide/custom_methods/","page":"Custom Methods","title":"Custom Methods","text":"Within Clapeyron, we provide a few methods which we use to obtain thermodynamic properties (you can find out more details on how we implement these methods in our background information):","category":"page"},{"location":"user_guide/custom_methods/","page":"Custom Methods","title":"Custom Methods","text":"volume(model, p, T, z): Obtains the volume of a system at a given temperature, pressure and composition. If the phase is unknown, it will find the vapour and liquid roots and return the one that minimises the Gibbs free energy. This function is called by all of our bulk property methods.\nsaturation_pressure(model, T): Obtains the saturation pressures and volumes for a pure species.\ncrit_pure(model): Obtains the critical point for a pure species.","category":"page"},{"location":"user_guide/custom_methods/","page":"Custom Methods","title":"Custom Methods","text":"Clearly this is not an exhaustive list and we make absolutely no guarantees as to the quality of these methods. However, if you have a new method or algorithm you would like to implement or test out, it is possible to do so.","category":"page"},{"location":"user_guide/custom_methods/#Custom-initial-guesses-example","page":"Custom Methods","title":"Custom initial guesses example","text":"","category":"section"},{"location":"user_guide/custom_methods/","page":"Custom Methods","title":"Custom Methods","text":"One of the most common reasons for our methods to fail (that we've seen) is due to poor initial guesses. If you are experiencing issues with our saturation_pressure method specifically, you could try modifying the initial guess for a particular equation of state (see the custom models documentation for explanation on abstract types):","category":"page"},{"location":"user_guide/custom_methods/","page":"Custom Methods","title":"Custom Methods","text":"function Clapeyron.x0_sat_pure(model::PCSAFTModel,T,z=SA[1.0])\n  # Obtain the volume lower bound for that particular system\n  Vlb = lb_volume(model,z)*one(T)\n  \n  # Relative to the lower bound, define your initial guesses. We log10 the results as our solvers solve for the log10 of the volume.\n  return log10.([Vlb*1.5,Vlb*100])\nend","category":"page"},{"location":"user_guide/custom_methods/","page":"Custom Methods","title":"Custom Methods","text":"Note that we do need prefix x0_sat_pure with Clapeyron. as we do not export this function normally; including this function in our script with force Clapeyron to use it instead of the default. These modifications can also be done for x0_crit_pure although crit_pure has proven to be quite reliable.","category":"page"},{"location":"user_guide/custom_methods/#Custom-volume-solver-example","page":"Custom Methods","title":"Custom volume solver example","text":"","category":"section"},{"location":"user_guide/custom_methods/","page":"Custom Methods","title":"Custom Methods","text":"For something a bit more substantial, you can also modify the volume function itself. Since this function is exported in Clapeyron, you do not need to prefix with Clapeyron.:","category":"page"},{"location":"user_guide/custom_methods/","page":"Custom Methods","title":"Custom Methods","text":"function volume(model::EoSModel,p,T,z=SA[1.0];phase=:unknown,threaded=true)\n  \n  # INSERT YOUR ALGORITHM HERE\n  \n  return vol\nend","category":"page"},{"location":"user_guide/custom_methods/","page":"Custom Methods","title":"Custom Methods","text":"Clapeyron will automatically overwrite the default function and use this one instead. ","category":"page"},{"location":"user_guide/custom_methods/","page":"Custom Methods","title":"Custom Methods","text":"If your custom methods end up being more-efficient than ours or you develop one that we do not currently support, please do start a pull request and we will gladly add it to the package!","category":"page"},{"location":"api/parameters/","page":"Parameters","title":"Parameters","text":"CurrentModule = Clapeyron","category":"page"},{"location":"api/parameters/#Contents","page":"Parameters","title":"Contents","text":"","category":"section"},{"location":"api/parameters/","page":"Parameters","title":"Parameters","text":"Pages = [\"parameters.md\"]","category":"page"},{"location":"api/parameters/#Index","page":"Parameters","title":"Index","text":"","category":"section"},{"location":"api/parameters/","page":"Parameters","title":"Parameters","text":"Pages = [\"parameters.md\"]","category":"page"},{"location":"api/parameters/#Parsing-Parameters-from-Files","page":"Parameters","title":"Parsing Parameters from Files","text":"","category":"section"},{"location":"api/parameters/","page":"Parameters","title":"Parameters","text":"Clapeyron.ParamOptions\nClapeyron.getparams","category":"page"},{"location":"api/parameters/#Clapeyron.ParamOptions","page":"Parameters","title":"Clapeyron.ParamOptions","text":"ParamOptions(;kwargs...)\n\nStruct containing all the options related to parameter parsing:\n\nuserlocations::Vector{String} = String[]: List of used-defined locations to search.\nusergrouplocations::Vector{String} = String[]: List of used-defined group locations to search.\nasymmetricparams::Vector{String} = String[]: List of pair or association parameters that follow that param[i,j] ≠ param[j,i]\nignore_headers::Vector{String} =  [\"dipprnumber\", \"smiles\"]: List of ignored headers.\nignore_missing_singleparams::Vector{String} = String[]: List of parameters where checking for missing single parameter values are ignored.\nverbose::Bool = false: If true, show all operations done by getparams displayed in the terminal. this includes the warnings emmited by CSV.jl \nspecies_columnreference::String =\"species\": column name to check for components. in pair and association params, it will check for #species#1 and #species#2, where #species# is the value of this option.\nsite_columnreference::String =\"site\": column name to check for sites in association params, it will check for #site#1 and #site#2, where #site# is the value of this option.\ngroup_columnreference::String = \"groups\": column name to check for groups in group data.\nnormalisecomponents::Bool = true: If true, performs normalization of strings, on the CSV and input components\nn_sites_columns::Dict{String,String} = Dict( \"e\" => \"n_e\",\"e1\" => \"n_e1\",\"e2\" => \"n_e2\",\"H\" => \"n_H\"): dictionary to look number of sites. the number of sites is stored as columns in a single parameter csv file. for example, the number of sites of name e will be looked on the column n_e\nreturn_sites::Bool = true: If set to false, association params will be ignored and sites will not be created, even if they exist in the list of locations.\ncomponent_delimiter::String = \"~|~\": When there are multiple component names to match, seperate them by this delimiter.\n\n\n\n\n\n","category":"type"},{"location":"api/parameters/#Clapeyron.getparams","page":"Parameters","title":"Clapeyron.getparams","text":"params, sites = getparams(components,locations;kwargs...)\n\nreturns a Dict{String,ClapeyronParam} containing all the parameters found for the list of components in the available CSVs. locations are the locations relative to Clapeyron database. the available keywords are the ones used in ParamOptions\n\nif return_sites is set to false, getparams will only return the found params.\n\n\n\n\n\n","category":"function"},{"location":"api/parameters/#Creating-Files-from-Parameters","page":"Parameters","title":"Creating Files from Parameters","text":"","category":"section"},{"location":"api/parameters/","page":"Parameters","title":"Parameters","text":"Clapeyron.ParamTable\nClapeyron.cleartemp!","category":"page"},{"location":"api/parameters/#Clapeyron.ParamTable","page":"Parameters","title":"Clapeyron.ParamTable","text":"ParamTable(type::Symbol,table,location = nothing,name = nothing, options = ParamOptions())\n\nCreates a clapeyron CSV file and returns the location of that file. the type determines the table type:\n\n:single creates a table with single parameters\n:pair creates a table with pair parameters\n:assoc creates a table with association parameters\n:group creates a table with association parameters\n\nBy default, the name is generated randomly, and the table is stored as a temporary scratch space (provided by Scratch.jl).  You can clean said scratch space by using Clapeyron.cleartemp!(). \n\nExamples:\n\njulia> data = (species = [\"water\"],Mw = [18.03]) #it could be a Dict, a named tuple, or any Tables.jl compatible table\n(species = [\"water\"], Mw = [18.9])\n\njulia> file = ParamTable(:single,data ,name=\"water_new_mw\")\n\"C:\\Users\\user\\.julia\\scratchspaces\\7c7805af-46cc-48c9-995b-ed0ed2dc909a\\ParamTables\\singledata_water_new_mw.csv\"\n\njulia> model = PCSAFT([\"water\",\"methanol\"],userlocations = [file])\nPCSAFT{BasicIdeal} with 2 components:\n \"water\"\n \"methanol\"\nContains parameters: Mw, segment, sigma,\nepsilon, epsilon_assoc, bondvol\n\njulia> model.params.Mw\nSingleParam{Float64}(\"Mw\") with 2 components:\n \"water\" => 18.9\n \"methanol\" => 32.042\n\n\n\n\n\n","category":"function"},{"location":"api/parameters/#Clapeyron.cleartemp!","page":"Parameters","title":"Clapeyron.cleartemp!","text":"cleartemp!()\n\nDeletes all files in the temporary Clapeyron scratch space, used to store the csvs created by ParamTable.\n\n\n\n\n\n","category":"function"},{"location":"api/parameters/#Parameter-types","page":"Parameters","title":"Parameter types","text":"","category":"section"},{"location":"api/parameters/","page":"Parameters","title":"Parameters","text":"Clapeyron.SingleParam\nClapeyron.PairParam\nClapeyron.AssocParam\nClapeyron.GroupParam\nClapeyron.SiteParam\nClapeyron.AssocOptions","category":"page"},{"location":"api/parameters/#Clapeyron.SingleParam","page":"Parameters","title":"Clapeyron.SingleParam","text":"SingleParam{T}\n\nStruct designed to contain single parameters. Basically a vector with some extra info.\n\nCreation:\n\njulia> mw = SingleParam(\"molecular weight\",[\"water\",\"ammonia\"],[18.01,17.03])\nSingleParam{Float64}(\"molecular weight\") with 2 components:\n \"water\" => 18.01\n \"ammonia\" => 17.03\n\njulia> mw.values\n2-element Vector{Float64}:\n 18.01\n 17.03\n\njulia> mw.components\n2-element Vector{String}:\n \"water\"\n \"ammonia\"\n\njulia> mw2 = SingleParam(mw,\"new name\")\nSingleParam{Float64}(\"new name\") with 2 components:\n \"water\" => 18.01\n \"ammonia\" => 17.03\n\njulia> has_oxigen = [true,false]; has_o = SingleParam(mw2,has_oxigen)\nSingleParam{Bool}(\"new name\") with 2 components:\n \"water\" => true\n \"ammonia\" => false\n\n\nExample usage in models:\n\nfunction molecular_weight(model,molar_frac)\n    mw = model.params.mw.values\n    res = zero(eltype(molarfrac))\n    for i in @comps #iterating through all components\n        res += molar_frac[i]*mw[i]\n    end\n    return res\nend\n\n\n\n\n\n","category":"type"},{"location":"api/parameters/#Clapeyron.PairParam","page":"Parameters","title":"Clapeyron.PairParam","text":"PairParam{T}\n\nStruct designed to contain pair data. used a matrix as underlying data storage.\n\nCreation:\n\njulia> kij = PairParam(\"interaction params\",[\"water\",\"ammonia\"],[0.1 0.0;0.1 0.0])\nPairParam{Float64}[\"water\", \"ammonia\"]) with values:\n2×2 Matrix{Float64}:\n 0.1  0.0\n 0.1  0.0\n\njulia> kij.values\n2×2 Matrix{Float64}:\n 0.1  0.0\n 0.1  0.0\n\njulia> kij.diagvalues\n2-element view(::Vector{Float64}, \n1:3:4) with eltype Float64:\n 0.1\n 0.0\n\nExample usage in models:\n\n#lets compute ∑xᵢxⱼkᵢⱼ\nfunction alpha(model,x)\n    kij = model.params.kij.values\n    ki = model.params.kij.diagvalues\n    res = zero(eltype(molarfrac))\n    for i in @comps \n        @show ki[i] #diagonal values\n        for j in @comps \n            res += x[i]*x[j]*kij[i,j]\n        end\n    end\n    return res\nend\n\n\n\n\n\n","category":"type"},{"location":"api/parameters/#Clapeyron.AssocParam","page":"Parameters","title":"Clapeyron.AssocParam","text":"AssocParam{T}\n\nStruct holding association parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/parameters/#Clapeyron.GroupParam","page":"Parameters","title":"Clapeyron.GroupParam","text":"GroupParam\n\nStruct holding group parameters.contains:\n\ncomponents: a list of all components\ngroups: a list of groups names for each component\ni_groups: a list containing the number of groups for each component\nn_groups: a list of the group multiplicity of each group corresponding to each group in i_groups\nflattenedgroups: a list of all unique groups–the parameters correspond to this list\nn_flattenedgroups: the group multiplicities corresponding to each group in flattenedgroups\ni_flattenedgroups: an iterator that goes through the indices for each flattened group\n\nYou can create a group param by passing a `Vector{Tuple{String, Vector{Pair{String, Int64}}}}. For example:\n\njulia> grouplist = [\n           (\"ethanol\", [\"CH3\"=>1, \"CH2\"=>1, \"OH\"=>1]), \n           (\"nonadecanol\", [\"CH3\"=>1, \"CH2\"=>18, \"OH\"=>1]),\n           (\"ibuprofen\", [\"CH3\"=>3, \"COOH\"=>1, \"aCCH\"=>1, \"aCCH2\"=>1, \"aCH\"=>4])];\n\njulia> groups = GroupParam(grouplist)\nGroupParam with 3 components:\n \"ethanol\": \"CH3\" => 1, \"CH2\" => 1, \"OH\" => 1\n \"nonadecanol\": \"CH3\" => 1, \"CH2\" => 18, \"OH\" => 1    \n \"ibuprofen\": \"CH3\" => 3, \"COOH\" => 1, \"aCCH\" => 1, \"aCCH2\" => 1, \"aCH\" => 4\n\njulia> groups.flattenedgroups\n7-element Vector{String}:\n \"CH3\"\n \"CH2\"\n \"OH\"\n \"COOH\"\n \"aCCH\"\n \"aCCH2\"\n \"aCH\"\n\njulia> groups.i_groups\n3-element Vector{Vector{Int64}}:\n [1, 2, 3]\n [1, 2, 3]\n [1, 4, 5, 6, 7]\n\njulia> groups.n_groups\n3-element Vector{Vector{Int64}}:\n [1, 1, 1]\n [1, 18, 1]\n [3, 1, 1, 1, 4]\n\njulia> groups.n_flattenedgroups\n 3-element Vector{Vector{Int64}}:\n [1, 1, 1, 0, 0, 0, 0]\n [1, 18, 1, 0, 0, 0, 0]\n [3, 0, 0, 1, 1, 1, 4]\n\nif you have CSV with group data, you can also pass those, to automatically query the missing groups in your input vector:\n\njulia> grouplist = [\n           \"ethanol\", \n           (\"nonadecanol\", [\"CH3\"=>1, \"CH2\"=>18, \"OH\"=>1]),\n           (\"ibuprofen\", [\"CH3\"=>3, \"COOH\"=>1, \"aCCH\"=>1, \"aCCH2\"=>1, \"aCH\"=>4])];\n\n           julia> groups = GroupParam(grouplist, [\"SAFT/SAFTgammaMie/SAFTgammaMie_groups.csv\"])\n           GroupParam with 3 components:\n            \"ethanol\": \"CH2OH\" => 1, \"CH3\" => 1\n            \"nonadecanol\": \"CH3\" => 1, \"CH2\" => 18, \"OH\" => 1    \n            \"ibuprofen\": \"CH3\" => 3, \"COOH\" => 1, \"aCCH\" => 1, \"aCCH2\" => 1, \"aCH\" => 4\n\nIn this case, SAFTGammaMie files support the second order group CH2OH.\n\n\n\n\n\n","category":"type"},{"location":"api/parameters/#Clapeyron.SiteParam","page":"Parameters","title":"Clapeyron.SiteParam","text":"SiteParam\n\nStruct holding site parameters. Is built by parsing all association parameters in the input CSV files. It has the following fields:\n\ncomponents: a list of all components (or groups in Group Contribution models)\nsites: a list containing a list of all sites corresponding to each component (or group) in the components field\nn_sites: a list of the site multiplicities corresponding to each site in flattenedsites\nflattenedsites: a list of all unique sites\ni_sites: an iterator that goes through the indices corresponding  to each site in flattenedsites\nn_flattenedsites: the site multiplicities corresponding to each site in flattenedsites\ni_flattenedsites: an iterator that goes through the indices for each flattened site\n\nLet's explore the sites in a 3-component SAFTGammaMie model:\n\n\njulia> model3 = SAFTgammaMie([    \n                \"ethanol\",\n                (\"nonadecanol\", [\"CH3\"=>1, \"CH2\"=>18, \"OH\"=>1]),     \n                (\"ibuprofen\", [\"CH3\"=>3, \"COOH\"=>1, \"aCCH\"=>1, \"aCCH2\"=>1, \"aCH\"=>4])\n                               ])\n\nSAFTgammaMie{BasicIdeal} with 3 components:\n \"ethanol\"\n \"nonadecanol\"\n \"ibuprofen\"\nContains parameters: segment, shapefactor, lambda_a, lambda_r, sigma, epsilon, epsilon_assoc, bondvol \n\njulia> model3.sites\nSiteParam with 8 sites:\n \"CH2OH\": \"H\" => 1, \"e1\" => 2     \n \"CH3\": (no sites)\n \"CH2\": (no sites)\n \"OH\": \"H\" => 1, \"e1\" => 2        \n \"COOH\": \"e2\" => 2, \"H\" => 1, \"e1\" => 2\n \"aCCH\": (no sites)\n \"aCCH2\": (no sites)\n \"aCH\": (no sites)\n\njulia> model3.sites.flattenedsites\n3-element Vector{String}:\n \"H\"\n \"e1\"\n \"e2\"\n\njulia> model3.sites.i_sites       \n8-element Vector{Vector{Int64}}:\n [1, 2]\n []\n []\n [1, 2]\n [1, 2, 3]\n []\n []\n []\n\njulia> model3.sites.n_sites       \n8-element Vector{Vector{Int64}}:\n [1, 2]\n []\n []\n [1, 2]\n [2, 1, 2]\n []\n []\n []\n\n\n\n\n\n","category":"type"},{"location":"api/parameters/#Clapeyron.AssocOptions","page":"Parameters","title":"Clapeyron.AssocOptions","text":"AssocOptions(;rtol = 1e-12,atol = 1e-12,max_iters = 1000,dampingfactor = 0.5,combining =:nocombining)\n\nStruct containing iteration parameters for the solver of association sites.\n\nthe combining option controls the type of combining rule applied to the association strength:\n\nsparse_nocombining (default). Does not perform any combination rules over the association strength, and returns a sparse matrix.\ndense_nocombining. Does not perform any combination rules over the association strength, and returns a dense matrix.\nelliott combining rule: Δ(i,j,a,b) = √(Δ(i,i,a,b)*Δ(j,j,a,b)). Returns a dense matrix.\n\ninfo: Association Scheme matters\nElliott's rule requires that both Δ(i,i,a,b) and  Δ(j,j,a,b) are non-zero, that means that components that don't self associate will not be combined.\n\n\n\n\n\n","category":"type"},{"location":"api/parameters/#Combining-Rules","page":"Parameters","title":"Combining Rules","text":"","category":"section"},{"location":"api/parameters/","page":"Parameters","title":"Parameters","text":"Clapeyron.kij_mix\nClapeyron.pair_mix\nClapeyron.sigma_LorentzBerthelot\nClapeyron.epsilon_LorentzBerthelot\nClapeyron.epsilon_HudsenMcCoubrey\nClapeyron.lambda_LorentzBerthelot\nClapeyron.lambda_squarewell","category":"page"},{"location":"api/parameters/#Clapeyron.kij_mix","page":"Parameters","title":"Clapeyron.kij_mix","text":"kij_mix(f,p::ClapeyronParam,k::PairParam)::PairParam\nkij_mix(f,p::ClapeyronParam)::PairParam\n\nGeneral combining rule for pair parameter with a kᵢⱼ interaction parameter. returns a pair parameter with non diagonal entries equal to:\n\npᵢⱼ = f(pᵢ,pⱼ,kᵢⱼ)\n\nWhere f is a 'combining' function that follows the rules:\n\nf(pᵢ,pⱼ,0) = f(pⱼ,pᵢ,0)\nf(pᵢ,pᵢ,0) = pᵢ\n\nand k must follow:\n\nkᵢᵢ = 0 \n\nIgnores non-diagonal entries already set.\n\nIf a Single Parameter is passed as input, it will be converted to a Pair Parameter with pᵢᵢ = pᵢ.\n\n\n\n\n\n","category":"function"},{"location":"api/parameters/#Clapeyron.pair_mix","page":"Parameters","title":"Clapeyron.pair_mix","text":"pair_mix(g,P::ClapeyronParam,Q::ClapeyronParam)::PairParam\npair_mix(g,P::ClapeyronParam,Q::ClapeyronParam)::PairParam\n\nGeneral combining rule for a pair and a single parameter. returns a pair parameter P with non diagonal entries equal to:\n\nPᵢⱼ = g(Pᵢ,Pⱼ,Qᵢ,Qⱼ,Qᵢⱼ)\n\nWhere f is a 'combining' function that follows the rules:\n\nPᵢⱼ = Pⱼᵢ = g(Pᵢ,Pⱼ,Qᵢ,Qⱼ,Qᵢⱼ) = g(Pⱼ,Pᵢ,Qⱼ,Qᵢ,Qᵢⱼ)\ng(Pᵢ,Pᵢ,Qᵢ,Qᵢ,Qᵢ) = Pᵢ\n\nit is a more general form of kij_mix, where kij_mix(f,P,Q) == pair_mix(g,P,Q) is correct if:\n\nf(Pᵢ,Pⱼ,Qᵢⱼ) = g(Pᵢ,Pⱼ,_,_,Qᵢⱼ)\n\n\n\n\n\n","category":"function"},{"location":"api/parameters/#Clapeyron.sigma_LorentzBerthelot","page":"Parameters","title":"Clapeyron.sigma_LorentzBerthelot","text":"sigma_LorentzBerthelot(σ::ClapeyronParam,ζ::PairParam)::PairParam\nsigma_LorentzBerthelot(σ::ClapeyronParam)::PairParam\n\nCombining rule for a single or pair parameter. returns a pair parameter with non diagonal entries equal to:\n\nσᵢⱼ = (1 - ζᵢⱼ)*(σᵢ + σⱼ)/2\n\nIf ζᵢⱼ is not defined, the definition is reduced to a simple arithmetic mean:\n\nσᵢⱼ = (σᵢ + σⱼ)/2\n\nIgnores non-diagonal entries already set.\n\nIf a Single Parameter is passed as input, it will be converted to a Pair Parameter with σᵢᵢ = σᵢ.\n\n\n\n\n\n","category":"function"},{"location":"api/parameters/#Clapeyron.epsilon_LorentzBerthelot","page":"Parameters","title":"Clapeyron.epsilon_LorentzBerthelot","text":"epsilon_LorentzBerthelot(ϵ::ClapeyronParam,k::PairParam)::PairParam\nepsilon_LorentzBerthelot(ϵ::ClapeyronParam)::PairParam\n\nCombining rule for a single or pair parameter. returns a pair parameter with non diagonal entries equal to:\n\nϵᵢⱼ = (1 - kᵢⱼ)*√(ϵᵢϵⱼ)\n\nIf kᵢⱼ is not defined, the definition is reduced to a simple geometric mean:\n\nϵᵢⱼ = √(ϵᵢϵⱼ)\n\nIgnores non-diagonal entries already set.\n\nIf a Single Parameter is passed as input, it will be converted to a Pair Parameter with ϵᵢᵢ = ϵᵢ.\n\n\n\n\n\n","category":"function"},{"location":"api/parameters/#Clapeyron.epsilon_HudsenMcCoubrey","page":"Parameters","title":"Clapeyron.epsilon_HudsenMcCoubrey","text":"epsilon_HudsenMcCoubrey(ϵ::ClapeyronParam,σ::PairParam)::PairParam\nepsilon_HudsenMcCoubrey(ϵ::ClapeyronParam)::PairParam\n\nCombining rule for a single or pair parameter. returns a pair parameter with non diagonal entries equal to:\n\nϵᵢⱼ = √(ϵᵢϵⱼ)*(σᵢᵢ^3 * σⱼⱼ^3)/σᵢⱼ^6 \n\nIf σᵢⱼ is not defined, the definition is reduced to a simple geometric mean:\n\nϵᵢⱼ = √(ϵᵢϵⱼ)\n\nIgnores non-diagonal entries already set.\n\nIf a Single Parameter is passed as input, it will be converted to a Pair Parameter with ϵᵢᵢ = ϵᵢ.\n\n\n\n\n\n","category":"function"},{"location":"api/parameters/#Clapeyron.lambda_LorentzBerthelot","page":"Parameters","title":"Clapeyron.lambda_LorentzBerthelot","text":"lambda_LorentzBerthelot(λ::ClapeyronParam,k = 3)::PairParam\n\nCombining rule for a single or pair parameter. returns a pair parameter with non diagonal entries equal to:\n\nλᵢⱼ = k + √((λᵢᵢ - k)(λⱼⱼ - k))\n\nwith k = 0 the definition is reduced to a simple geometric mean:\n\nϵᵢⱼ = √(ϵᵢϵⱼ)\n\nIgnores non-diagonal entries already set.\n\nIf a Single Parameter is passed as input, it will be converted to a Pair Parameter with λᵢᵢ = λᵢ.\n\n\n\n\n\n","category":"function"},{"location":"api/parameters/#Clapeyron.lambda_squarewell","page":"Parameters","title":"Clapeyron.lambda_squarewell","text":"lambda_squarewell(λ::ClapeyronParam,σ::PairParam)::PairParam\n\nCombining rule for a single or pair parameter. returns a pair parameter with non diagonal entries equal to:\n\nλᵢⱼ = (σᵢᵢλᵢᵢ + σⱼⱼλⱼⱼ)/(σᵢᵢ + σⱼⱼ)\n\nIgnores non-diagonal entries already set.\n\nIf a Single Parameter is passed as input, it will be converted to a Pair Parameter with λᵢᵢ = λᵢ.\n\n\n\n\n\n","category":"function"},{"location":"api/parameters/#Group-Combining-Rules","page":"Parameters","title":"Group Combining Rules","text":"","category":"section"},{"location":"api/parameters/","page":"Parameters","title":"Parameters","text":"Clapeyron.group_sum\nClapeyron.group_pairmean\nClapeyron.group_matrix","category":"page"},{"location":"api/parameters/#Clapeyron.group_sum","page":"Parameters","title":"Clapeyron.group_sum","text":"group_sum(groups::GroupParam,P::SingleParameter)\n\nGiven a GroupParam and a Single Parameter P for group data, it will return a single parameter p of component data, where:\n\npᵢ = ∑Pₖνᵢₖ\n\nwhere νᵢₖ is the number of groups k at component i.\n\n\n\n\n\ngroup_sum(groups::GroupParam,P::AbstractVector)\n\nGiven a GroupParam and a Vector P for group data, it will return a Vector p of component data, where:\n\npᵢ = ∑Pₖνᵢₖ\n\nwhere νᵢₖ is the number of groups k at component i.\n\n\n\n\n\ngroup_sum(groups::GroupParam,::Nothing)\n\nGiven a GroupParam, it will return a vector p of component data, where:\n\npᵢ = ∑νᵢₖ\n\nwhere νᵢₖ is the number of groups k at component i.\n\n\n\n\n\n","category":"function"},{"location":"api/parameters/#Clapeyron.group_pairmean","page":"Parameters","title":"Clapeyron.group_pairmean","text":"group_pairmean(groups::GroupParam,param::PairParam)\ngroup_pairmean(f,groups::GroupParam,param::SingleParam)\n\nGiven a GroupParamand a parameter P it will return a single parameter p of component data, where:\n\npᵢ = ∑νᵢₖ(∑(νᵢₗ*P(i,j))) / ∑νᵢₖ(∑νᵢₗ)\n\nwhere νᵢₖ is the number of groups k at component i and P(i,j) depends on the type of P:\n\nif P is a single paremeter, then P(i,j) = f(P[i],P[j])\nif P is a pair paremeter, then P(i,j) = p[i,j]\n\n\n\n\n\n","category":"function"},{"location":"api/parameters/#Clapeyron.group_matrix","page":"Parameters","title":"Clapeyron.group_matrix","text":"group_matrix(groups::GroupParam)\n\nreturns a matrix of size (k,i) with values νₖᵢ. when multiplied with a molar amount, it returns the amount of moles of each group.\n\n\n\n\n\n","category":"function"},{"location":"api/parameters/#Model-Splitting","page":"Parameters","title":"Model Splitting","text":"","category":"section"},{"location":"api/parameters/","page":"Parameters","title":"Parameters","text":"Clapeyron.split_model\nClapeyron.is_splittable\nClapeyron.index_reduction","category":"page"},{"location":"api/parameters/#Clapeyron.split_model","page":"Parameters","title":"Clapeyron.split_model","text":"split_model(model::EoSModel)\n\nTakes in a model for a multi-component system and returns a vector of model for each pure system.\n\nExample:\n\njulia> gerg2 = GERG2008([\"propane\",\"pentane\"])\nGERG008 model with 2 components:\n\"propane\"\n\"pentane\"\n\njulia> split_model(gerg2)\n2-element Vector{GERG2008}:\n GERG2008(\"propane\")\n GERG2008(\"pentane\")\n\n\n\n\n\n","category":"function"},{"location":"api/parameters/#Clapeyron.is_splittable","page":"Parameters","title":"Clapeyron.is_splittable","text":"is_splittable(model)::Bool\n\nTrait to determine if a EoSModel should be splitted by itself or can be simply filled into a vector. This is useful in the case of models without any parameters, as those models are impossible by definition to split, because they don't have any underlying data.\n\nThe Default is is_splittable(model) = true.\n\n\n\n\n\n","category":"function"},{"location":"api/parameters/#Clapeyron.index_reduction","page":"Parameters","title":"Clapeyron.index_reduction","text":"index_reduction(model::EoSModel,z,zmin = sum(z)*4*eps(eltype(z)))\n\nRemoves any component with composition z[i] < zmin. returns a reduced model model_r and a vector of indices idx_r, such as:\n\nmodel_r,idx_r = index_reduction(model,z)\neos(model,V,T,z) ≈ eos(model_r,V,T,z[idx_r])\n\nif the model does not have empty compositions, it will just return the input model\n\n\n\n\n\n","category":"function"},{"location":"eos/cubic/","page":"Cubic Models","title":"Cubic Models","text":"CurrentModule = Clapeyron","category":"page"},{"location":"eos/cubic/#Index","page":"Cubic Models","title":"Index","text":"","category":"section"},{"location":"eos/cubic/","page":"Cubic Models","title":"Cubic Models","text":"Pages = [\"cubic.md\"]","category":"page"},{"location":"eos/cubic/#Cubic-Models","page":"Cubic Models","title":"Cubic Models","text":"","category":"section"},{"location":"eos/cubic/","page":"Cubic Models","title":"Cubic Models","text":"All cubic models in Clapeyron.jl follow a common evaluation order:","category":"page"},{"location":"eos/cubic/","page":"Cubic Models","title":"Cubic Models","text":"\nfunction CubicModel(args...)\n    #get params for database, initialize other models, etc\n    #we need Tc,pc and kij for the generation of the matrices aᵢⱼ and bᵢⱼ\n    a,b = a,b = ab_premixing(CubicModel,mixing_model,Tc,pc,k)\n    #rest of the initialization, return model\nend\n\nfunction cubic_ab(model::CubicModel,V,T,z=SA[1.0])\n    invn2 = (one(n)/n)^2\n    a = model.params.a.values\n    b = model.params.b.values\n    α = α_function(model,V,T,z,model.alpha)\n    c = translation(model,V,T,z,model.translation)\n    ā,b̄,c̄ = mixing_rule(model,V,T,z,model.mixing,α,a,b,c)\n    return ā ,b̄, c̄\nend\n\nfunction a_res(model::CubicModel,V,T,z)\n    ā ,b̄, c̄ = cubic_ab(model,V,T,z)\n    #depends on the specific EoS\n    return result\nend","category":"page"},{"location":"eos/cubic/","page":"Cubic Models","title":"Cubic Models","text":"A Mixing Rule Model creates aᵢⱼ and bᵢⱼ from the critical temperature, critical pressure and a matrix of pair coefficients.\nAn Alpha Model creates a vector of αᵢ(T) values\nA Translation Model creates a vector of cᵢ values\nThe same Mixing rule, given aᵢⱼ, bᵢⱼ, αᵢ(T) and cᵢ returns the the mixture values of ā, b̄ and c̄ that are then used by the corresponding cubic model. a Mixing Rule can contain activity models to participate in the mixing (for example, Huron-Vidal rules)","category":"page"},{"location":"eos/cubic/#Main-Models","page":"Cubic Models","title":"Main Models","text":"","category":"section"},{"location":"eos/cubic/","page":"Cubic Models","title":"Cubic Models","text":"Clapeyron.vdW\nClapeyron.RK\nClapeyron.PR","category":"page"},{"location":"eos/cubic/#Clapeyron.vdW","page":"Cubic Models","title":"Clapeyron.vdW","text":"vdW(components::Vector{String};\nidealmodel=BasicIdeal,\nalpha = NoAlpha,\nmixing = vdW1fRule,\nactivity=nothing,\ntranslation=NoTranslation,\nuserlocations=String[], \nideal_userlocations=String[],\nalpha_userlocations = String[],\nmixing_userlocations = String[],\nactivity_userlocations = String[],\ntranslation_userlocations = String[],\nverbose=false)\n\nInput parameters\n\nTc: Single Parameter (Float64) - Critical Temperature [K]\nPc: Single Parameter (Float64) - Critical Pressure [Pa]\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nk: Pair Parameter (Float64)\n\nModel Parameters\n\nTc: Single Parameter (Float64) - Critical Temperature [K]\nPc: Single Parameter (Float64) - Critical Pressure [Pa]\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\na: Pair Parameter (Float64)\nb: Pair Parameter (Float64)\n\nInput models\n\nidealmodel: Ideal Model\nalpha: Alpha model\nmixing: Mixing model\nactivity: Activity Model, used in the creation of the mixing model.\ntranslation: Translation Model\n\nDescription\n\nvan der Wals Equation of state.\n\nP = RT/(V-Nb) + a•α(T)/V²\n\nReferences\n\nvan der Waals JD. Over de Continuiteit van den Gasen Vloeistoftoestand. PhD thesis, University of Leiden; 1873\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Clapeyron.RK","page":"Cubic Models","title":"Clapeyron.RK","text":"RK(components::Vector{String}; idealmodel=BasicIdeal,\nalpha = PRAlpha,\nmixing = vdW1fRule,\nactivity=nothing,\ntranslation=NoTranslation,\nuserlocations=String[],\nideal_userlocations=String[],\nalpha_userlocations = String[],\nmixing_userlocations = String[],\nactivity_userlocations = String[],\ntranslation_userlocations = String[],\nverbose=false)\n\nInput parameters\n\nTc: Single Parameter (Float64) - Critical Temperature [K]\nPc: Single Parameter (Float64) - Critical Pressure [Pa]\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nk: Pair Parameter (Float64)\n\nModel Parameters\n\nTc: Single Parameter (Float64) - Critical Temperature [K]\nPc: Single Parameter (Float64) - Critical Pressure [Pa]\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\na: Pair Parameter (Float64)\nb: Pair Parameter (Float64)\n\nInput models\n\nidealmodel: Ideal Model\nalpha: Alpha model\nmixing: Mixing model\nactivity: Activity Model, used in the creation of the mixing model.\ntranslation: Translation Model\n\nDescription\n\nRedlich-Kwong Equation of state.\n\nP = RT/(V-Nb) + a•α(T)/(V(V+Nb))\n\nReferences\n\nRedlich, O., & Kwong, J. N. S. (1949). On the thermodynamics of solutions; an equation of state; fugacities of gaseous solutions. Chemical Reviews, 44(1), 233–244. doi:10.1021/cr60137a013\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Clapeyron.PR","page":"Cubic Models","title":"Clapeyron.PR","text":"PR(components::Vector{String}; idealmodel=BasicIdeal,\nalpha = PRAlpha,\nmixing = vdW1fRule,\nactivity=nothing,\ntranslation=NoTranslation,\nuserlocations=String[],\nideal_userlocations=String[],\nalpha_userlocations = String[],\nmixing_userlocations = String[],\nactivity_userlocations = String[],\ntranslation_userlocations = String[],\nverbose=false)\n\nInput parameters\n\nTc: Single Parameter (Float64) - Critical Temperature [K]\nPc: Single Parameter (Float64) - Critical Pressure [Pa]\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\nk: Pair Parameter (Float64)\n\nModel Parameters\n\nTc: Single Parameter (Float64) - Critical Temperature [K]\nPc: Single Parameter (Float64) - Critical Pressure [Pa]\nMw: Single Parameter (Float64) - Molecular Weight [g/mol]\na: Pair Parameter (Float64)\nb: Pair Parameter (Float64)\n\nInput models\n\nidealmodel: Ideal Model\nalpha: Alpha model\nmixing: Mixing model\nactivity: Activity Model, used in the creation of the mixing model.\ntranslation: Translation Model\n\nDescription\n\nPeng-Robinson Equation of state.\n\nP = RT/(V-Nb) + a•α(T)/(V-Nb₁)(V-Nb₂)\nb₁ = (1 + √2)b\nb₂ = (1 - √2)b\n\nReferences\n\nPeng, D.Y., & Robinson, D.B. (1976). A New Two-Constant Equation of State. Industrial & Engineering Chemistry Fundamentals, 15, 59-64. doi:10.1021/I160057A011\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Variant-Models","page":"Cubic Models","title":"Variant Models","text":"","category":"section"},{"location":"eos/cubic/","page":"Cubic Models","title":"Cubic Models","text":"Clapeyron.SRK\nClapeyron.PSRK\nClapeyron.PR78\nClapeyron.EPPR78\nClapeyron.UMRPR\nClapeyron.VTPR\nClapeyron.QCPR","category":"page"},{"location":"eos/cubic/#Clapeyron.SRK","page":"Cubic Models","title":"Clapeyron.SRK","text":"SRK(components::Vector{String}; idealmodel=BasicIdeal,\nalpha = SoaveAlpha,\nmixing = vdW1fRule,\nactivity = nothing,\ntranslation=NoTranslation,\nuserlocations=String[], \nideal_userlocations=String[],\nalpha_userlocations = String[],\nmixing_userlocations = String[],\nactivity_userlocations = String[],\ntranslation_userlocations = String[],\nverbose=false)\n\nDescription\n\nSoave-Redlich-Kwong equation of state. it uses the following models:\n\nTranslation Model: NoTranslation\nAlpha Model: SoaveAlpha\nMixing Rule Model: vdW1fRule\n\nReferences\n\nSoave, G. (1972). Equilibrium constants from a modified Redlich-Kwong equation of state. Chemical Engineering Science, 27(6), 1197–1203. doi:10.1016/0009-2509(72)80096-4\n\n\n\n\n\n","category":"function"},{"location":"eos/cubic/#Clapeyron.PSRK","page":"Cubic Models","title":"Clapeyron.PSRK","text":"function PSRK(components::Vector{String}; idealmodel=BasicIdeal,\nalpha = SoaveAlpha,\nmixing = PSRKRule,\nactivity = PSRKUNIFAC,\ntranslation=PenelouxTranslation,\nuserlocations=String[], \nideal_userlocations=String[],\nalpha_userlocations = String[],\nmixing_userlocations = String[],\nactivity_userlocations = String[],\ntranslation_userlocations = String[],\nverbose=false)\n\nDescription\n\nPredictive Soave-Redlich-Kwong equation of state. it uses the following models:\n\nTranslation Model: NoTranslation\nAlpha Model: SoaveAlpha\nMixing Rule Model: PSRKRule with PSRKUNIFAC activity model \n\nReferences\n\nHorstmann, S., Jabłoniec, A., Krafczyk, J., Fischer, K., & Gmehling, J. (2005). PSRK group contribution equation of state: comprehensive revision and extension IV, including critical constants and α-function parameters for 1000 components. Fluid Phase Equilibria, 227(2), 157–164. doi:10.1016/j.fluid.2004.11.002\n\n\n\n\n\n","category":"function"},{"location":"eos/cubic/#Clapeyron.PR78","page":"Cubic Models","title":"Clapeyron.PR78","text":"PR78(components::Vector{String}; idealmodel=BasicIdeal,\nalpha = PR78Alpha,\nmixing = vdW1fRule,\nactivity = nothing,\ntranslation=NoTranslation,\nuserlocations=String[], \nideal_userlocations=String[],\nalpha_userlocations = String[],\nmixing_userlocations = String[],\ntranslation_userlocations = String[],\nverbose=false)\n\nPeng Robinson (1978) equation of state. it uses the following models:\n\nTranslation Model: NoTranslation\nAlpha Model: PR78Alpha\nMixing Rule Model: vdW1fRule\n\nReferences\n\nRobinson DB, Peng DY. The characterization of the heptanes and heavier fractions for the GPA Peng-Robinson programs. Tulsa: Gas Processors Association; 1978\n\n\n\n\n\n","category":"function"},{"location":"eos/cubic/#Clapeyron.EPPR78","page":"Cubic Models","title":"Clapeyron.EPPR78","text":"EPPR78(components::Vector{String}; idealmodel=BasicIdeal,\nalpha = PR78Alpha,\nmixing = PPR78Rule,\nactivity = nothing,\ntranslation=NoTranslation,\nuserlocations=String[], \nideal_userlocations=String[],\nalpha_userlocations = String[],\nmixing_userlocations = String[],\ntranslation_userlocations = String[],\nverbose=false)\n\nEnhanced Predictive Peng Robinson equation of state. it uses the following models:\n\nTranslation Model: NoTranslation\nAlpha Model: PR78Alpha\nMixing Rule Model: PPR78Rule\n\nReferences\n\nJaubert, J.-N., Privat, R., & Mutelet, F. (2010). Predicting the phase equilibria of synthetic petroleum fluids with the PPR78 approach. AIChE Journal. American Institute of Chemical Engineers, 56(12), 3225–3235. doi:10.1002/aic.12232\nJaubert, J.-N., Qian, J.-W., Lasala, S., & Privat, R. (2022). The impressive impact of including enthalpy and heat capacity of mixing data when parameterising equations of state. Application to the development of the E-PPR78 (Enhanced-Predictive-Peng-Robinson-78) model. Fluid Phase Equilibria, (113456), 113456. doi:10.1016/j.fluid.2022.113456\n\n\n\n\n\n","category":"function"},{"location":"eos/cubic/#Clapeyron.UMRPR","page":"Cubic Models","title":"Clapeyron.UMRPR","text":"UMRPR(components::Vector{String}; idealmodel=BasicIdeal,\nalpha = MTAlpha,\nmixing = UMRRule,\nactivity = UNIFAC,\ntranslation=MTTranslation,\nuserlocations=String[], \nideal_userlocations=String[],\nalpha_userlocations = String[],\nmixing_userlocations = String[],\nactivity_userlocations = String[],\ntranslation_userlocations = String[],\nverbose=false)\n\nUniversal Mixing Rule Peng Robinson equation of state. it uses the following models:\n\nTranslation Model: MTTranslation\nAlpha Model: MTAlpha\nMixing Rule Model: UMRRule with (UNIFAC)(@ref) activity\n\nReferences\n\nVoutsas, E., Magoulas, K., & Tassios, D. (2004). Universal mixing rule for cubic equations of state applicable to symmetric and asymmetric systems: Results with the Peng−Robinson equation of state. Industrial & Engineering Chemistry Research, 43(19), 6238–6246. doi:10.1021/ie049580p\n\n\n\n\n\n","category":"function"},{"location":"eos/cubic/#Clapeyron.VTPR","page":"Cubic Models","title":"Clapeyron.VTPR","text":"VTPR(components::Vector{String}; idealmodel=BasicIdeal,\nmixing = VTPRRule,\nalpha = TwuAlpha,\ntranslation = RackettTranslation,\nactivity = VTPRUNIFAC,\nuserlocations=String[], \nideal_userlocations=String[],\nalpha_userlocations = String[],\nmixing_userlocations = String[],\nactivity_userlocations = String[],\ntranslation_userlocations = String[],\nverbose=false)\n\nVolume-translated Peng Robinson equation of state. it uses the following models:\n\nTranslation Model: RackettTranslation\nAlpha Model: TwuAlpha\nMixing Rule Model: VTPRRule with VTPRUNIFAC activity\n\nReferences\n\nAhlers, J., & Gmehling, J. (2001). Development of an universal group contribution equation of state. Fluid Phase Equilibria, 191(1–2), 177–188. doi:10.1016/s0378-3812(01)00626-4\n\n\n\n\n\n","category":"function"},{"location":"eos/cubic/#Clapeyron.QCPR","page":"Cubic Models","title":"Clapeyron.QCPR","text":"QCPR(components::Vector{String}; idealmodel=BasicIdeal,\n    userlocations=String[], \n    ideal_userlocations=String[],\n    alpha_userlocations = String[],\n    mixing_userlocations = String[],\n    activity_userlocations = String[],\n    translation_userlocations = String[],\n    verbose=false)\n\nQuantum-corrected Peng Robinson equation of state. it uses the following models:\n\nTranslation Model: ConstantTranslation\nAlpha Model: TwuAlpha\nMixing Rule Model: QCPRRule\n\nReferences\n\nAasen, A., Hammer, M., Lasala, S., Jaubert, J.-N., & Wilhelmsen, Ø. (2020). Accurate quantum-corrected cubic equations of state for helium, neon, hydrogen, deuterium and their mixtures. Fluid Phase Equilibria, 524(112790), 112790. doi:10.1016/j.fluid.2020.112790\n\n\n\n\n\n","category":"function"},{"location":"eos/cubic/#Alpha-(α(T))-Models","page":"Cubic Models","title":"Alpha (α(T)) Models","text":"","category":"section"},{"location":"eos/cubic/","page":"Cubic Models","title":"Cubic Models","text":"Clapeyron.α_function\nClapeyron.NoAlpha\nClapeyron.RKAlpha\nClapeyron.SoaveAlpha\nClapeyron.PRAlpha\nClapeyron.PR78Alpha\nClapeyron.CPAAlpha\nClapeyron.sCPAAlpha\nClapeyron.MTAlpha\nClapeyron.BMAlpha\nClapeyron.TwuAlpha","category":"page"},{"location":"eos/cubic/#Clapeyron.α_function","page":"Cubic Models","title":"Clapeyron.α_function","text":"α_function(model::CubicModel,V,T,z,αmodel::AlphaModel)\n\nInterface function used in cubic models. it should return a vector of αᵢ(T).\n\nExample:\n\nfunction α_function(model::CubicModel,V,T,z,alpha_model::RKAlphaModel)\n    return 1 ./ sqrt.(T ./ Tc)\nend\n\n\n\n\n\n","category":"function"},{"location":"eos/cubic/#Clapeyron.NoAlpha","page":"Cubic Models","title":"Clapeyron.NoAlpha","text":"NoAlpha(args...) <: NoAlphaModel\n\nInput Parameters\n\nNone\n\nDescription\n\nCubic alpha (α(T)) model. Default for vdW EoS\n\nαᵢ = 1 ∀ i\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Clapeyron.RKAlpha","page":"Cubic Models","title":"Clapeyron.RKAlpha","text":"RKAlpha <: RKAlphaModel\n\nRKAlpha(components::Vector{String};\nuserlocations::Vector{String}=String[],\nverbose::Bool=false)\n\nInput Parameters\n\nw: Single Parameter (Float64)\n\nModel Parameters\n\nacentricfactor: Single Parameter (Float64)\n\nDescription\n\nCubic alpha (α(T)) model. Default for RK EoS.\n\nαᵢ = 1/√(Trᵢ)\nTrᵢ = T/Tcᵢ\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Clapeyron.SoaveAlpha","page":"Cubic Models","title":"Clapeyron.SoaveAlpha","text":"SoaveAlpha <: SoaveAlphaModel\n\nSoaveAlpha(components::Vector{String};\nuserlocations::Vector{String}=String[],\nverbose::Bool=false)\n\nInput Parameters\n\nw: Single Parameter (Float64)\n\nModel Parameters\n\nacentricfactor: Single Parameter (Float64)\n\nDescription\n\nCubic alpha (α(T)) model. Default for SRK EoS.\n\nαᵢ = (1+mᵢ(1-√(Trᵢ)))^2\nTrᵢ = T/Tcᵢ\nmᵢ = 0.480 + 1.547ωᵢ - 0.176ωᵢ^2\n\nto use different polynomial coefficients for mᵢ, overload Clapeyron.α_m(::CubicModel,::SoaveAlphaModel) = (c₁,c₂,...cₙ)\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Clapeyron.PRAlpha","page":"Cubic Models","title":"Clapeyron.PRAlpha","text":"PRAlpha <: SoaveAlphaModel\n\nPRAlpha(components::Vector{String};\nuserlocations::Vector{String}=String[],\nverbose::Bool=false)\n\nInput Parameters\n\nw: Single Parameter (Float64)\n\nModel Parameters\n\nacentricfactor: Single Parameter (Float64)\n\nDescription\n\nCubic alpha (α(T)) model. Default for PR EoS.\n\nαᵢ = (1+mᵢ(1-√(Trᵢ)))^2\nTrᵢ = T/Tcᵢ\nmᵢ = 0.37464 + 1.54226ωᵢ - 0.26992ωᵢ^2\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Clapeyron.PR78Alpha","page":"Cubic Models","title":"Clapeyron.PR78Alpha","text":"PR78Alpha <: PR78AlphaModel\n\nPR78Alpha(components::Vector{String};\nuserlocations::Vector{String}=String[],\nverbose::Bool=false)\n\nInput Parameters\n\nw: Single Parameter (Float64)\n\nModel Parameters\n\nacentricfactor: Single Parameter (Float64)\n\nDescription\n\nCubic alpha (α(T)) model. Default for PR78 and EPPR78 EoS.\n\nαᵢ = (1+mᵢ(1-√(Trᵢ)))^2\nTrᵢ = T/Tcᵢ\nif ωᵢ ≤ 0.491\n    mᵢ = 0.37464 + 1.54226ωᵢ - 0.26992ωᵢ^2\nelse\n    mᵢ = 0.379642 + 1.487503ωᵢ - 0.164423ωᵢ^2 - 0.016666ωᵢ^3\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Clapeyron.CPAAlpha","page":"Cubic Models","title":"Clapeyron.CPAAlpha","text":"CPAAlpha <: CPAAlphaModel\n\nCPAAlpha(components::Vector{String};\nuserlocations::Vector{String}=String[],\nverbose::Bool=false)\n\nInput Parameters\n\nc1: Single Parameter (Float64)\n\nDescription\n\nCubic alpha (α(T)) model. Default for CPA EoS.\n\nαᵢ = (1+c¹ᵢ(1-√(Trᵢ)))^2\n\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Clapeyron.sCPAAlpha","page":"Cubic Models","title":"Clapeyron.sCPAAlpha","text":"sCPAAlpha <: sCPAAlphaModel\n\nCPAAlpha(components::Vector{String};\nuserlocations::Vector{String}=String[],\nverbose::Bool=false)\n\nInput Parameters\n\nc1: Single Parameter\n\nDescription\n\nCubic alpha (α(T)) model. Default for sCPA EoS.\n\nαᵢ = (1+c¹ᵢ(1-√(Trᵢ)))^2\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Clapeyron.MTAlpha","page":"Cubic Models","title":"Clapeyron.MTAlpha","text":"MTAlpha <: MTAlphaModel\n\nMTAlpha(components::Vector{String};\nuserlocations::Vector{String}=String[],\nverbose::Bool=false)\n\nInput Parameters\n\nw: Single Parameter (Float64)\n\nModel Parameters\n\nacentricfactor: Single Parameter (Float64)\n\nDescription\n\nMagoulas & Tassios Cubic alpha (α(T)) model. Default for UMRPR EoS.\n\nαᵢ = (1+mᵢ(1-√(Trᵢ)))^2\nTrᵢ = T/Tcᵢ\nmᵢ = 0.384401 + 1.52276ωᵢ - 0.213808ωᵢ^2 + 0.034616ωᵢ^3 - 0.001976ωᵢ^4 \n\nReferences\n\nMagoulas, K., & Tassios, D. (1990). Thermophysical properties of n-Alkanes from C1 to C20 and their prediction for higher ones. Fluid Phase Equilibria, 56, 119–140. doi:10.1016/0378-3812(90)85098-u\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Clapeyron.BMAlpha","page":"Cubic Models","title":"Clapeyron.BMAlpha","text":"BMAlpha <: BMAlphaModel\n\nMTAlpha(components::Vector{String};\nuserlocations::Vector{String}=String[],\nverbose::Bool=false)\n\nInput Parameters\n\nw: Single Parameter (Float64)\n\nModel Parameters\n\nacentricfactor: Single Parameter (Float64)\n\nDescription\n\nBoston Mathias Cubic alpha (α(T)) model.\n\nif Trᵢ > 1\n    αᵢ = (exp((1-2/(2+mᵢ))*(1-Trᵢ^(1+mᵢ/2))))^2\nelse\n    αᵢ = (1+mᵢ*(1-√(Trᵢ)))^2\n\nTrᵢ = T/Tcᵢ\n\nfor PR models:\n    mᵢ = 0.37464 + 1.54226ωᵢ - 0.26992ωᵢ^2\nfor RK models:\n    mᵢ = 0.480 + 1.547ωᵢ - 0.176ωᵢ^2\n\nReferences\n\n.M. Boston, P.M. Mathias, Proceedings of the 2nd International Conference on Phase Equilibria and Fluid Properties in the Chemical Process Industries, West Berlin, March, 1980, pp. 823–849\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Clapeyron.TwuAlpha","page":"Cubic Models","title":"Clapeyron.TwuAlpha","text":"TwuAlpha <: TwuAlphaModel\n\nTwuAlpha(components::Vector{String};\nuserlocations::Vector{String}=String[],\nverbose::Bool=false)\n\nInput Parameters\n\nM: Single Parameter\nN: Single Parameter\nL: Single Parameter\n\nModel Parameters\n\nM: Single Parameter\nN: Single Parameter\nL: Single Parameter\n\nDescription\n\nCubic alpha (α(T)) model. Default for VTPR EoS.\n\n\nαᵢ = Trᵢ^(N*(M-1))*exp(L*(1-Trᵢ^(N*M))\nTrᵢ = T/Tcᵢ\n\nReferences\n\nTwu, C. H., Lee, L. L., & Starling, K. E. (1980). Improved analytical representation of argon thermodynamic behavior. Fluid Phase Equilibria, 4(1–2), 35–44. doi:10.1016/0378-3812(80)80003-3\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Volume-Translation-Models","page":"Cubic Models","title":"Volume Translation Models","text":"","category":"section"},{"location":"eos/cubic/","page":"Cubic Models","title":"Cubic Models","text":"Clapeyron.translation\nClapeyron.NoTranslation\nClapeyron.ConstantTranslation\nClapeyron.RackettTranslation\nClapeyron.PenelouxTranslation\nClapeyron.MTTranslation","category":"page"},{"location":"eos/cubic/#Clapeyron.translation","page":"Cubic Models","title":"Clapeyron.translation","text":"translation(model::CubicModel,V,T,z,translation_model::TranslationModel)\n\nInterface function used in cubic models. it should return a vector of cᵢ. such as Ṽ = V + mixing(c,z)\n\nExample:\n\nfunction α_function(model::CubicModel,V,T,z,translation_model::RackettTranslation)\n    Tc = model.params.Tc.values\n    Pc = model.params.Pc.values\n    Vc = translation_model.params.Vc.values\n    R = Clapeyron.R̄\n    Zc = Pc .* Vc ./ (R .* Tc)\n    c = 0.40768 .* (0.29441 .- Zc) .* R .* Tc ./ Pc\n    return c\nend\n\n\n\n\n\n","category":"function"},{"location":"eos/cubic/#Clapeyron.NoTranslation","page":"Cubic Models","title":"Clapeyron.NoTranslation","text":"NoTranslation(args...) <: TranslationModel\n\nInput Parameters\n\nNone\n\nDescription\n\nDefault volume translation model for cubic models. it performs no translation:\n\nV = V₀ + mixing_rule(cᵢ)\ncᵢ = 0 ∀ i\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Clapeyron.ConstantTranslation","page":"Cubic Models","title":"Clapeyron.ConstantTranslation","text":"ConstantTranslation <: ConstantTranslationModel\n\nConstantTranslation(components::Vector{String};\nuserlocations::Vector{String}=String[],\nverbose::Bool=false)\n\nInput Parameters\n\nc: Single Parameter (Float64) - Volume shift [m³/mol]\n\nDescription\n\nConstant Translation model for cubics:\n\nV = V₀ + mixing_rule(cᵢ)\n\nwhere cᵢ is constant. \n\nIt does not have parameters by default, the volume shifts must be user-supplied.\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Clapeyron.RackettTranslation","page":"Cubic Models","title":"Clapeyron.RackettTranslation","text":"RackettTranslation <: RackettTranslationModel\n\nRackettTranslation(components::Vector{String};\nuserlocations::Vector{String}=String[],\nverbose::Bool=false)\n\nInput Parameters\n\nvc: Single Parameter (Float64) - Critical Volume [m³/mol]\n\nDescription\n\nRackett Translation model for cubics:\n\nV = V₀ + mixing_rule(cᵢ)\ncᵢ = 0.40768*RTcᵢ/Pcᵢ*(0.29441-Zcᵢ)\nZcᵢ = Pcᵢ*Vcᵢ/(RTcᵢ)\n\nReferences\n\nRackett, H. G. (1970). Equation of state for saturated liquids. Journal of Chemical and Engineering Data, 15(4), 514–517. doi:10.1021/je60047a012\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Clapeyron.PenelouxTranslation","page":"Cubic Models","title":"Clapeyron.PenelouxTranslation","text":"PenelouxTranslation <: PenelouxTranslationModel\n\nPenelouxTranslation(components::Vector{String};\nuserlocations::Vector{String}=String[],\nverbose::Bool=false)\n\nInput Parameters\n\nvc: Single Parameter (Float64) - Critical Volume [m³/mol]\n\nDescription\n\nPeneloux Translation model for cubics:\n\nV = V₀ + mixing_rule(cᵢ)\ncᵢ = -0.252*RTcᵢ/Pcᵢ*(1.5448Zcᵢ - 0.4024)\nZcᵢ = Pcᵢ*Vcᵢ/(RTcᵢ)\n\nReferences\n\nPéneloux A, Rauzy E, Fréze R. (1982) A consistent correction for Redlich‐Kwong‐Soave volumes. Fluid Phase Equilibria 1, 8(1), 7–23. doi:10.1016/0378-3812(82)80002-2\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Clapeyron.MTTranslation","page":"Cubic Models","title":"Clapeyron.MTTranslation","text":"MTTranslation <: MTTranslationModel\n\nMTTranslation(components::Vector{String};\nuserlocations::Vector{String}=String[],\nverbose::Bool=false)\n\nInput Parameters\n\nw: Single Parameter (Float64)\n\nModel Parameters\n\nacentricfactor: Single Parameter (Float64)\n\nDescription\n\nMagoulas Tassios Translation model for cubics:\n\nV = V₀ + mixing_rule(cᵢ)\ncᵢ = T₀ᵢ+(T̄cᵢ-T̄₀ᵢ)*exp(β*abs(1-Trᵢ))\nTrᵢ = T/T̄cᵢ\nT̄cᵢ = (RTcᵢ/Pcᵢ)*(0.3074-Zcᵢ)\nT̄₀ᵢ = (RTcᵢ/Pcᵢ)*(-0.014471 + 0.067498ωᵢ - 0.084852ωᵢ^2 + 0.067298ωᵢ^3 - 0.017366ωᵢ^4)\nZcᵢ = 0.289 - 0.0701ωᵢ - 0.0207ωᵢ^2\nβᵢ  = -10.2447 - 28.6312ωᵢ\n\nReferences\n\nMagoulas, K., & Tassios, D. (1990). Thermophysical properties of n-Alkanes from C1 to C20 and their prediction for higher ones. Fluid Phase Equilibria, 56, 119–140. doi:10.1016/0378-3812(90)85098-u\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Mixing-Rule-Models","page":"Cubic Models","title":"Mixing Rule Models","text":"","category":"section"},{"location":"eos/cubic/","page":"Cubic Models","title":"Cubic Models","text":"Clapeyron.ab_premixing\nClapeyron.mixing_rule\nClapeyron.vdW1fRule\nClapeyron.KayRule\nClapeyron.HVRule\nClapeyron.MHV1Rule\nClapeyron.MHV2Rule\nClapeyron.LCVMRule\nClapeyron.WSRule\nClapeyron.VTPRRule\nClapeyron.PSRKRule\nClapeyron.QCPRRule\nClapeyron.PPR78Rule","category":"page"},{"location":"eos/cubic/#Clapeyron.ab_premixing","page":"Cubic Models","title":"Clapeyron.ab_premixing","text":"ab_premixing(::Type{T},mixing,Tc,pc,kij) where T <: ABCubicModel\n\ngiven Tc::SingleParam, pc::SingleParam, kij::PairParam and mixing <: MixingRule, it will return  PairParams a and b, containing values aᵢⱼ and bᵢⱼ. by default, it performs the van der Wals One-Fluid mixing rule. that is:\n\naᵢⱼ = sqrt(aᵢ*aⱼ)*(1-kᵢⱼ)\nbᵢⱼ = (bᵢ + bⱼ)/2\n\n\n\n\n\n","category":"function"},{"location":"eos/cubic/#Clapeyron.mixing_rule","page":"Cubic Models","title":"Clapeyron.mixing_rule","text":"mixing_rule(model::CubicModel,V,T,z,mixing_model::MixingRule,α,a,b,c)\n\nInterface function used by cubic models. with matrices a and b, vectors α and c, a model::CubicModel and mixing_model::MixingRule, returns the scalars ā,b̄ and c̄, corresponding to the values mixed by the amount of components and the specifics of the mixing rule.\n\nExample\n\nfunction mixing_rule(model::CubicModel,V,T,z,mixing_model::vdW1fRule,α,a,b,c)\n    ∑z = sum(z)\n    ā = dot(z .* sqrt(α),a,z .* sqrt(α))/(∑z*∑z) #∑∑aᵢⱼxᵢxⱼ√(αᵢαⱼ)\n    b̄ = dot(z,b,z)/(∑z*∑z)  #∑∑bᵢⱼxᵢxⱼ\n    c̄ = dot(z,c)/∑z ∑cᵢxᵢ\n    return ā,b̄,c̄\nend\n\n\n\n\n\n","category":"function"},{"location":"eos/cubic/#Clapeyron.vdW1fRule","page":"Cubic Models","title":"Clapeyron.vdW1fRule","text":"vdW1fRule <: vdW1fRuleModel\n\nvdW1fRule(components::Vector{String};\nuserlocations::Vector{String}=String[],\nverbose::Bool=false)\n\nInput Parameters\n\nNone\n\nDescription\n\nvan der Wals One-Fluid mixing rule for cubic parameters:\n\naᵢⱼ = √(aᵢaⱼ)(1-kᵢⱼ)\nbᵢⱼ = (bᵢ + bⱼ)/2\nā = ∑aᵢⱼxᵢxⱼ√(αᵢ(T)αⱼ(T))\nb̄ = ∑bᵢⱼxᵢxⱼ\nc̄ = ∑cᵢxᵢ\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Clapeyron.KayRule","page":"Cubic Models","title":"Clapeyron.KayRule","text":"KayRule <: KayRuleModel\n\nKayRule(components::Vector{String};\nuserlocations::Vector{String}=String[],\nverbose::Bool=false)\n\nInput Parameters\n\nNone\n\nDescription\n\nKay mixing rule for cubic parameters:\n\naᵢⱼ = √(aᵢaⱼ)(1-kᵢⱼ)\nbᵢⱼ = (bᵢ + bⱼ)/2\nā = b̄*(∑[aᵢⱼxᵢxⱼ√(αᵢ(T)αⱼ(T))/bᵢⱼ])^2\nb̄ = (∑∛(bᵢⱼ)xᵢxⱼ)^3\nc̄ = ∑cᵢxᵢ\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Clapeyron.HVRule","page":"Cubic Models","title":"Clapeyron.HVRule","text":"HVRule{γ} <: HVRuleModel\n\nHVRule(components::Vector{String};\nactivity = Wilson,\nuserlocations::Vector{String}=String[],\nactivity_userlocations::Vector{String}=String[],\nverbose::Bool=false)\n\nInput Parameters\n\nNone\n\nInput models\n\nactivity: Activity Model\n\nDescription\n\nHuron-Vidal Mixing Rule \n\naᵢⱼ = √(aᵢaⱼ)(1-kᵢⱼ)\nbᵢⱼ = (bᵢ +bⱼ)/2\nb̄ = ∑bᵢⱼxᵢxⱼ\nc̄ = ∑cᵢxᵢ\nā = b̄(∑[xᵢaᵢᵢαᵢ/(bᵢᵢ)] - gᴱ/λ)\nfor Redlich-Kwong:\n    λ = log(2) (0.6931471805599453)\nfor Peng-Robinson:\n    λ = 1/(2√(2))log((2+√(2))/(2-√(2))) (0.6232252401402305)\n\nλ is a coefficient indicating the relation between gᴱ and gᴱ(cubic) at infinite pressure. see [1] for more information. it can be customized by defining HV_λ(::HVRuleModel,::CubicModel)\n\nReferences\n\nHuron, M.-J., & Vidal, J. (1979). New mixing rules in simple equations of state for representing vapour-liquid equilibria of strongly non-ideal mixtures. Fluid Phase Equilibria, 3(4), 255–271. doi:10.1016/0378-3812(79)80001-1\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Clapeyron.MHV1Rule","page":"Cubic Models","title":"Clapeyron.MHV1Rule","text":"MHV1Rule{γ} <: MHV1RuleModel\n\nMHV1Rule(components::Vector{String};\nactivity = Wilson,\nuserlocations::Vector{String}=String[],\nactivity_userlocations::Vector{String}=String[],\nverbose::Bool=false)\n\nInput Parameters\n\nNone\n\nInput models\n\nactivity: Activity Model\n\nDescription\n\nModified Huron-Vidal Mixing Rule, First Order \n\naᵢⱼ = √(aᵢaⱼ)(1-kᵢⱼ)\nbᵢⱼ = (bᵢ + bⱼ)/2\nb̄ = ∑bᵢⱼxᵢxⱼ\nc̄ = ∑cᵢxᵢ\nā = b̄RT(∑[xᵢaᵢᵢαᵢ/(RTbᵢᵢ)] - [gᴱ/RT + ∑log(bᵢᵢ/b̄)]/q)\n\nif the model is Peng-Robinson:\n    q = 0.53\nif the model is Redlich-Kwong:\n    q = 0.593\n\nto use different values for q, overload Clapeyron.MHV1q(::CubicModel,::MHV1Model) = q\n\nReferences\n\nMichelsen, M. L. (1990). A modified Huron-Vidal mixing rule for cubic equations of state. Fluid Phase Equilibria, 60(1–2), 213–219. doi:10.1016/0378-3812(90)85053-d\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Clapeyron.MHV2Rule","page":"Cubic Models","title":"Clapeyron.MHV2Rule","text":"MHV2Rule{γ} <: MHV2RuleModel\n\nMHV2Rule(components::Vector{String};\nactivity = Wilson,\nuserlocations::Vector{String}=String[],\nactivity_userlocations::Vector{String}=String[],\nverbose::Bool=false)\n\nInput Parameters\n\nNone\n\nInput models\n\nactivity: Activity Model\n\nDescription\n\nModified Huron-Vidal Mixing Rule, Second Order.\n\naᵢⱼ = √(aᵢaⱼ)(1 - kᵢⱼ)\nbᵢⱼ = (bᵢ + bⱼ)/2\nb̄ = ∑bᵢⱼxᵢxⱼ\nc̄ = ∑cᵢxᵢ\nᾱᵢ  = aᵢαᵢ/bᵢRT\nċ = -q₁*Σᾱᵢxᵢ - q₂*Σᾱᵢxᵢ^2 - gᴱ/RT - ∑log(bᵢᵢ/b̄)\nā = (-q₁ - √(q₁^2 - 4q₂ċ))/(2q₂)\n\nif the model is Peng-Robinson:\n    q₁ = -0.4347, q₂ = -0.003654\nif the model is Redlich-Kwong:\n    q₁ = -0.4783, q₂ = -0.0047\n    (-0.4783,-0.0047)\n\nto use different values for q₁ and q₂, overload Clapeyron.MHV1q(::CubicModel,::MHV2Model) = (q₁,q₂)\n\nReferences\n\nMichelsen, M. L. (1990). A modified Huron-Vidal mixing rule for cubic equations of state. Fluid Phase Equilibria, 60(1–2), 213–219. doi:10.1016/0378-3812(90)85053-d\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Clapeyron.LCVMRule","page":"Cubic Models","title":"Clapeyron.LCVMRule","text":"LCVMRule{γ} <: LCVMRuleModel\n\nLCVMRule(components::Vector{String};\nactivity = Wilson,\nuserlocations::Vector{String}=String[],\nactivity_userlocations::Vector{String}=String[],\nverbose::Bool=false)\n\nInput Parameters\n\nNone\n\nInput models\n\nactivity: Activity Model\n\nDescription\n\nLinear Combination of Vidal and Michaelsen (LCVM) Mixing Rule\n\naᵢⱼ = √(aᵢaⱼ)(1 - kᵢⱼ)\nbᵢⱼ = (bᵢ + bⱼ)/2\nb̄ = ∑bᵢⱼxᵢxⱼ\nc̄ = ∑cᵢxᵢ\nᾱᵢ  = aᵢαᵢ/bᵢRT\nċ = -q₁*Σᾱᵢxᵢ - q₂*Σᾱᵢxᵢ^2 - gᴱ/RT - ∑log(bᵢᵢ/b̄)\nā = b̄RT(-1.827[gᴱ/RT - 0.3∑log(bᵢᵢ/b̄)] + Σᾱᵢxᵢ)\n\nReferences\n\nBoukouvalas, C., Spiliotis, N., Coutsikos, P., Tzouvaras, N., & Tassios, D. (1994). Prediction of vapor-liquid equilibrium with the LCVM model: a linear combination of the Vidal and Michelsen mixing rules coupled with the original UNIFAC. Fluid Phase Equilibria, 92, 75–106. doi:10.1016/0378-3812(94)80043-x\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Clapeyron.WSRule","page":"Cubic Models","title":"Clapeyron.WSRule","text":"WSRule{γ} <: WSRuleModel\n\nWSRule(components::Vector{String};\nactivity = Wilson,\nuserlocations::Vector{String}=String[],\nactivity_userlocations::Vector{String}=String[],\nverbose::Bool=false)\n\nInput Parameters\n\nNone\n\nInput models\n\nactivity: Activity Model\n\nDescription\n\nWong-Sandler Mixing Rule.\n\naᵢⱼ = √(aᵢaⱼ)(1 - kᵢⱼ)\nbᵢⱼ = (bᵢ + bⱼ)/2\nc̄ = ∑cᵢxᵢ\nB̄ = Σxᵢxⱼ(bᵢⱼ - aᵢⱼ√(αᵢαⱼ)/RT)\nb̄  = B̄/(1 - gᴱ/λRT - Σxᵢaᵢαᵢ/bᵢRT)\nā = RT(b̄ - B̄)\nfor Redlich-Kwong:\n    λ = log(2) (0.6931471805599453)\nfor Peng-Robinson:\n    λ = 1/(2√(2))log((2+√(2))/(2-√(2))) (0.6232252401402305)\n\nλ is a coefficient indicating the relation between gᴱ and gᴱ(cubic) at infinite pressure. see [1] for more information. it can be customized by defining WS_λ(::WSRuleModel,::CubicModel)\n\nReferences\n\nWong, D. S. H., & Sandler, S. I. (1992). A theoretically correct mixing rule for cubic equations of state. AIChE journal. American Institute of Chemical Engineers, 38(5), 671–680. doi:10.1002/aic.690380505\nOrbey, H., & Sandler, S. I. (1995). Reformulation of Wong-Sandler mixing rule for cubic equations of state. AIChE journal. American Institute of Chemical Engineers, 41(3), 683–690. doi:10.1002/aic.690410325\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Clapeyron.VTPRRule","page":"Cubic Models","title":"Clapeyron.VTPRRule","text":"VTPRRule{γ} <: VTPRRuleModel\n\nVTPRRule(components::Vector{String};\nactivity = UNIFAC,\nuserlocations::Vector{String}=String[],\nactivity_userlocations::Vector{String}=String[],\nverbose::Bool=false)\n\nInput Parameters\n\nNone\n\nInput models\n\nactivity: Activity Model\n\nDescription\n\nMixing Rule used by the Volume-translated Peng-Robinson VTPR equation of state. only works with activity models that define an excess residual gibbs energy function Clapeyron.excess_g_res(model,P,T,z) function (like UNIQUAC and UNIFAC models)\n\naᵢⱼ = √(aᵢaⱼ)(1-kᵢⱼ)\nbᵢⱼ = ((bᵢ^(3/4) + bⱼ^(3/4))/2)^(4/3)\nlog(γʳ)ᵢ = lnγ_res(model.activity,V,T,z) \ngᴱᵣₑₛ = ∑RTlog(γʳ)ᵢxᵢ\nb̄ = ∑bᵢⱼxᵢxⱼ\nc̄ = ∑cᵢxᵢ\nā = b̄RT(∑[xᵢaᵢᵢαᵢ/(RTbᵢᵢ)] - gᴱᵣₑₛ/(0.53087RT))\n\nReferences\n\nAhlers, J., & Gmehling, J. (2001). Development of an universal group contribution equation of state. Fluid Phase Equilibria, 191(1–2), 177–188. doi:10.1016/s0378-3812(01)00626-4\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Clapeyron.PSRKRule","page":"Cubic Models","title":"Clapeyron.PSRKRule","text":"PSRKRule{γ} <: MHV1RuleModel\n\nPSRKRule(components::Vector{String};\nactivity = Wilson,\nuserlocations::Vector{String}=String[],\nactivity_userlocations::Vector{String}=String[],\nverbose::Bool=false)\n\nInput Parameters\n\nNone\n\nInput models\n\nactivity: Activity Model\n\nDescription\n\nMixing Rule used by the Predictive Soave-Redlich-Kwong PSRK EoS,  derived from the First Order modified Huron-Vidal Mixing Rule.\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Clapeyron.QCPRRule","page":"Cubic Models","title":"Clapeyron.QCPRRule","text":"QCPRRule <: MHV2RuleModel\n\nQCPRRule(components::Vector{String};\nactivity = Wilson,\nuserlocations::Vector{String}=String[],\nactivity_userlocations::Vector{String}=String[],\nverbose::Bool=false)\n\nInput Parameters\n\nNone\n\nInput models\n\nactivity: Activity Model\n\nDescription\n\nQuantum-Corrected Mixing Rule, used by QCPR EoS:\n\naᵢⱼ = √(aᵢaⱼ)(1 - kᵢⱼ)\nbᵢⱼ = (1-lᵢⱼ)(bqᵢ + bqⱼ)/2\nbqᵢ = bᵢβᵢ(T)\nβᵢ(T) = (1 + Aᵢ/(T + Bᵢ))^3 / (1 + Aᵢ/(Tcᵢ + Bᵢ))^3\nā = ∑aᵢⱼxᵢxⱼ√(αᵢ(T)αⱼ(T))\nb̄ = ∑bᵢⱼxᵢxⱼ\nc̄ = ∑cᵢxᵢ\n\nReferences\n\nAasen, A., Hammer, M., Lasala, S., Jaubert, J.-N., & Wilhelmsen, Ø. (2020). Accurate quantum-corrected cubic equations of state for helium, neon, hydrogen, deuterium and their mixtures. Fluid Phase Equilibria, 524(112790), 112790. doi:10.1016/j.fluid.2020.112790\n\n\n\n\n\n","category":"type"},{"location":"eos/cubic/#Clapeyron.PPR78Rule","page":"Cubic Models","title":"Clapeyron.PPR78Rule","text":"PPR78Rule <: PPR78RuleModel\n\nPPR78Rule(components;\nuserlocations::Vector{String}=String[],\nverbose::Bool=false)\n\nInput Parameters\n\nA: Pair Parameter (Float64) - Fitted Parameter [K]\nB: Pair Parameter (Float64) - Fitted Parameter [K]\n\nDescription\n\nPPR78 Mixing Rule, Uses E-PPR78 Group params. Default for EPPR78 EoS.\n\naᵢⱼ = √(aᵢaⱼ)\nbᵢⱼ = (bᵢ +bⱼ)/2\nb̄ = ∑bᵢⱼxᵢxⱼ\nc̄ = ∑cᵢxᵢ\nā = b̄(∑[xᵢaᵢᵢαᵢ/(bᵢᵢ)] - ∑xᵢxⱼbᵢbⱼEᵢⱼ/2b̄)\nEᵢⱼ = ∑(z̄ᵢₖ - z̄ⱼₖ)(z̄ᵢₗ - z̄ⱼₗ) × Aₖₗ × (298.15/T)^(Aₖₗ/Bₖₗ - 1)\n\nReferences\n\nJaubert, J.-N., Privat, R., & Mutelet, F. (2010). Predicting the phase equilibria of synthetic petroleum fluids with the PPR78 approach. AIChE Journal. American Institute of Chemical Engineers, 56(12), 3225–3235. doi:10.1002/aic.12232\nJaubert, J.-N., Qian, J.-W., Lasala, S., & Privat, R. (2022). The impressive impact of including enthalpy and heat capacity of mixing data when parameterising equations of state. Application to the development of the E-PPR78 (Enhanced-Predictive-Peng-Robinson-78) model. Fluid Phase Equilibria, (113456), 113456. doi:10.1016/j.fluid.2022.113456\n\n\n\n\n\n","category":"type"},{"location":"#Clapeyron.jl","page":"Home","title":"Clapeyron.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for the modelling of fluids using thermodynamic equations of state. These include the standard cubics (van der Waals, Redlich-Kwong, Peng-Robinson, etc.), SAFT-type equations (PC-SAFT, SAFT-VR Mie, SAFT-gamma Mie, etc.), empirical equations (GERG2008, IAWPS95) and many more.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The documentation is laid out as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Background: Find more information about the origin and differences for each equation of state provided in this package, as well as some of the methods used to obtain the various thermodynamic properties.\nBasic Usage: Find out how to use the equations of state provided in the package.\nCustomization: how to use your own parameters, implement your own equation of state or algorithm.\nNotebook Examples: A list of available notebooks showcasing different functionalities of the package.\nAvailable Models: A list of all available Equations of State present in the package.\nAPI: A list of all available methods.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pierre J. Walker, California Institute of Technology\nHon-Wa (Paul) Yew, Imperial College London\nAndrés Riedemann, University of Concepción","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Clapeyron.jl is licensed under the MIT license.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Clapeyron.jl is a registered package, it can be installed from the general registry by:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Clapeyron","category":"page"}]
}
